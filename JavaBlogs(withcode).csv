,Blog,Target
0,"Java is one of the most popular and widely used programming language.
Simple Hello World Program : Output : Overview, Basics,   OOP concepts, Inheritance   Operators,   Strings,   Input and Output, Arrays , Arrays Class,  Important Keywords in Java ,Java vs C++,   Methods in Java,   Constructors,   Exception Handling,  Interfaces and Abstract Classes, Java Packages, Multithreading,   Garbage Collection, Wrapper Classes, Reflection in Java,   File Handling,   Collection in Java, Collection Interview FAQ’s  ,Collections Class (Contains utility functions on Collections),   Useful and/or Advanced Features,   Image Processing,  Networking in Java, Interview Questions, Misc, Multiple Choice Questions, Java 8 Stream MethodsApache in JavaJava Recent Articles!
Java Output & Multiple Choice Questions",java
1,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.
Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.However to become proficient in any programming language, one Firstly needs to understand the basics of that language.Therefore, below are the basics of Java in the format in which it will help you the most to get the headstart:Learn about setting up the Java environment here: Setting up the environment in JavaLearn about printing “Hello World” in Java here: Beginning Java programming with Hello World Example
Learn about Comments in Java here: Comments in Java Learn about different data types in Java here: Data types in Java Learn about Variables in Java here: Variables in Java
Learn about Keywords in Java here: Keywords in Java
Learn about Operators in Java here: Operators in Java
Learn about Decision Making in Java here: Decision Making in Java
Learn about Loops in Java here: Loops in Java GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
2,C Programming Mock TestsData Structures Mock TestsAlgorithms Mock TestsOperating Systems Mock TestsC++ Programming Mock TestsJava Programming Mock TestsPython Programming Mock TestsGATE Mock TestsDBMS Mock TestsCompiler Design Mock TestsComputer Networks Mock TestsTheory of Computation Mock TestsAptitude Mock TestsComputer Organization and ArchitectureOther Topics in Computer ScienceEngineering MathematicsCS Interview Questions ,java
3,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.
Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.Therefore, Java is a very successful language and it is gaining popularity day by day.You can download java from here. Here you will find different versions of java. Choose and download the one compatible with your operating system.
For detailed instructions for setting up of Java, refer this article.After you have set up the Java environment correctly, try running this simple program:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to print GeeksforGeeks publicclassGFG {     publicstaticvoidmain(String args[])     {         System.out.println(""GeeksforGeeks"");     } } If the environment is set up correctly and the code is correctly written, you shall see this output on your console. That is your first Java program!GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
4,"In inheritance, subclass acquires super class properties. An important point to note is, when subclass object is created, a separate object of super class object will not be created. Only a subclass object object is created that has super class variables.This situation is different from a normal assumption that a constructor call means an object of the class is created, so we can’t blindly say that whenever a class constructor is executed, object of that class is created or not.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to demonstrate that both super class // and subclass constructors refer to same object  // super class classFruit {     publicFruit()     {         System.out.println(""Super class constructor"");         System.out.println(""Super class object hashcode :""+                            this.hashCode());         System.out.println(this.getClass().getName());     } }  // sub class classApple extendsFruit {     publicApple()     {         System.out.println(""Subclass constructor invoked"");         System.out.println(""Sub class object hashcode :""+                            this.hashCode());         System.out.println(this.hashCode() + ""   ""+                            super.hashCode());          System.out.println(this.getClass().getName() + ""  ""+                            super.getClass().getName());     } }  // driver class publicclassTest {     publicstaticvoidmain(String[] args)     {         Apple myApple = newApple();     } } Output:As we can see that both super class(Fruit) object hashcode and subclass(Apple) object hashcode are same, so only one object is created. This object is of class Apple(subclass) as when we try to print name of class which object is created, it is printing Apple which is subclass.This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
5,"The process of Java programming can be simplified in three steps:Below given  program is the simplest program of Java printing “Hello World” to the screen. Let us try to understand every bit of code step by step.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                /* This is a simple Java program.    FileName : ""HelloWorld.java"". */classHelloWorld {     // Your program begins with a call to main().     // Prints ""Hello, World"" to the terminal window.     publicstaticvoidmain(String args[])     {         System.out.println(""Hello, World"");     } } Output:The “Hello World!” program consists of three primary components: the HelloWorld class definition, the main method and source code comments. Following explanation will provide you with a basic understanding of the code:mainHelloWorld is an identifier that is the name of the class. The entire class definition, including all of its members, will be between the opening curly brace  {  and the closing curly brace  } .mainLike in C/C++, main method is the entry point for your application and will subsequently invoke all the other methods required by your program.This line outputs the string “Hello, World” followed by a new line on the screen. Output is actually accomplished by the built-in println( ) method. System is a predefined class that provides access to the system, and out is the variable of type output stream that is connected to the console.This is a multiline comment. This type of comment must begin with /* and end with */. For single line you may directly use // as in C/C++.Important Points :Compiling the program  :This will print “Hello World” to the terminal screen.In WindowsIn LinuxThis article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
6,"Campus placements season is beginning at almost all the colleges and each one of us wants to prepare to do the best. A lot of students have been asking on different forums “How to use GeeksforGeeks for placement preparation”? In this article, a step by step guide for placement preparation is discussed.        Set 2 – To guide you going beyond the basics and getting placed in your dream companies 🙂 C++JavaPythonDSAlgorithmsDBMSComputer NetworksOperating System 
Company wise preparation articles, coding practice and subjective questions.If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above",java
7,"Overloading allows different methods to have the same name, but different signatures where the signature can differ by the number of input parameters or type of input parameters or both. Overloading is related to compile-time (or static) polymorphism.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of method // overloading in Java.  publicclassSum {      // Overloaded sum(). This sum takes two int parameters     publicintsum(intx, inty)     {         return(x + y);     }      // Overloaded sum(). This sum takes three int parameters     publicintsum(intx, inty, intz)     {         return(x + y + z);     }      // Overloaded sum(). This sum takes two double parameters     publicdoublesum(doublex, doubley)     {         return(x + y);     }      // Driver code     publicstaticvoidmain(String args[])     {         Sum s = newSum();         System.out.println(s.sum(10, 20));         System.out.println(s.sum(10, 20, 30));         System.out.println(s.sum(10.5, 20.5));     } } Output :Question Arises:
Q. What if the exact prototype does not match with arguments.
Ans.
Priority wise, compiler take these steps:Let’s take an example to clear the concept:-                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                classDemo {     publicvoidshow(intx)     {         System.out.println(""In int""+ x);     }     publicvoidshow(String s)     {         System.out.println(""In String""+ s);     }     publicvoidshow(byteb)     {         System.out.println(""In byte""+ b);     } } classUseDemo {     publicstaticvoidmain(String[] args)     {         bytea = 25;         Demo obj = newDemo();         obj.show(a); // it will go to         // byte argument         obj.show(""hello""); // String         obj.show(250); // Int         obj.show('A'); // Since char is         // not available, so the datatype         // higher than char in terms of         // range is int.         obj.show(""A""); // String         obj.show(7.5); // since float datatype // is not available and so it's higher // datatype, so at this step their // will be an error. } } What is the advantage?
We don’t have to create and remember different names for functions doing the same thing. For example, in our code, if overloading was not supported by Java, we would have to create method names like sum1, sum2, … or sum2Int, sum3Int, … etc.Can we overload methods on return type?
We cannot overload by return type. This behavior is same in C++. Refer this for details                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                publicclassMain {     publicintfoo() { return10; }      // compiler error: foo() is already defined     publiccharfoo() { return'a'; }      publicstaticvoidmain(String args[])     {     } } However, Overloading methods on return type are possible in cases where the data type of the function being called is explicitly specified. Look at the examples below :                                      edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate the working of method // overloading in static methods publicclassMain {      publicstaticintfoo(inta) { return10; }     publicstaticcharfoo(inta, intb) { return'a'; }      publicstaticvoidmain(String args[])     {         System.out.println(foo(1));         System.out.println(foo(1, 2));     } } Output:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of method // overloading in  methods classA {     publicintfoo(inta) { return10; }      publiccharfoo(inta, intb) { return'a'; } }  publicclassMain {      publicstaticvoidmain(String args[])     {         A a = newA();         System.out.println(a.foo(1));         System.out.println(a.foo(1, 2));     } } Output:Can we overload static methods?
The answer is ‘Yes’. We can have two ore more static methods with same name, but differences in input parameters. For example, consider the following Java program. Refer this for details.Can we overload methods that differ only by static keyword?
We cannot overload two methods in Java if they differ only by static keyword (number of parameters and types of parameters is same). See following Java program for example. Refer this for details.Can we overload main() in Java?
Like other static methods, we can overload main() in Java. Refer overloading main() in Java for more details.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program with overloaded main() importjava.io.*;  publicclassTest {      // Normal main()     publicstaticvoidmain(String[] args)     {         System.out.println(""Hi Geek (from main)"");         Test.main(""Geek"");     }      // Overloaded main methods     publicstaticvoidmain(String arg1)     {         System.out.println(""Hi, ""+ arg1);         Test.main(""Dear Geek"", ""My Geek"");     }     publicstaticvoidmain(String arg1, String arg2)     {         System.out.println(""Hi, ""+ arg1 + "", ""+ arg2);     } } Output :Does Java support Operator Overloading?
Unlike C++, Java doesn’t allow user-defined overloaded operators. Internally Java overloads operators, for example, + is overloaded for concatenation.What is the difference between Overloading and Overriding?Related Articles:This article is contributed by Shubham Agrawal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
8,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.Java is easy to learn and its syntax is simple and easy to understand. It is based on C++ (so easier for programmers who know C++). Java has removed many confusing and rarely-used features e.g. explicit pointers, operator overloading etc. Java also takes care of memory management and for that, it provides an automatic garbage collector. This collects the unused objects automatically.Below is the complete guide as to how to get started with Java and make yourself proficient in it.Learn about Java here: How to start learning Java
Learn about JVM here: JVM
By reading this article, you will get the to topics from how to set up the Java Environment to the details about its coding.Learn about Java Programming Basics here: Java Programming Basics
Learn about OOPs concepts in Java here: Object Oriented Programming (OOPs) Concept in Java
Learn about Classes and Objects in Java here: Classes and Objects in Java
Learn about Constructors in Java here: Constructors in Java
Learn about Methods in Java here: Methods in Java
Learn about Strings in Java here: Strings in Java
Learn about Arrays in Java here: Arrays in Java
Learn about Collections in Java here: Collections in Java
Learn about Generics in Java here: Generics in Java
Learn about Stream In Java here: Stream In Java
Learn about Exceptions and Exception Handling in Java here: Exceptions and Exception Handling in Java
Learn about Regular Expressions here: Regular Expressions (ReGex) in JavaLearn about Multithreading in Java here: Multithreading in Java
Learn about File Handling in Java here: File Handling in Java
Learn about Packages in Java here: Packages in Java
GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
9,"Classes and Objects are basic concepts of Object Oriented Programming which revolve around the real life entities.ClassA class is a user defined blueprint or prototype from which objects are created.  It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order:Constructors are used for initializing new objects. Fields are variables that provides the state of the class and its objects, and methods are used to implement the behavior of the class and its objects.There are various types of classes that are used in real time applications such as nested classes, anonymous classes, lambda expressions.ObjectIt is a basic unit of Object Oriented Programming and represents the real life entities.  A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of :Example of an object : dogObjects correspond to things found in the real world. For example, a graphics program may have objects such as “circle”, “square”, “menu”. An online shopping system might have objects such as “shopping cart”, “customer”, and “product”.Declaring Objects (Also called instantiating a class)When an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.Example :As we declare variables like (type name;). This notifies the compiler that we will use name to refer to data whose type is type. With a primitive variable, this declaration also reserves the proper amount of memory for the variable. So for reference variable, type must be strictly a concrete class name. In general,we can’t create objects of an abstract class or an interface.If we declare reference variable(tuffy) like this, its value will be undetermined(null) until an object is actually created and assigned to it. Simply declaring a reference variable does not create an object. Initializing an objectThe new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the class constructor.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Class Declaration  publicclassDog {     // Instance Variables     String name;     String breed;     intage;     String color;      // Constructor Declaration of Class     publicDog(String name, String breed,                    intage, String color)     {         this.name = name;         this.breed = breed;         this.age = age;         this.color = color;     }      // method 1     publicString getName()     {         returnname;     }      // method 2     publicString getBreed()     {         returnbreed;     }      // method 3     publicintgetAge()     {         returnage;     }      // method 4     publicString getColor()     {         returncolor;     }      @Override    publicString toString()     {         return(""Hi my name is ""+ this.getName()+                "".\nMy breed,age and color are ""+                this.getBreed()+"",""+ this.getAge()+                "",""+ this.getColor());     }      publicstaticvoidmain(String[] args)     {         Dog tuffy = newDog(""tuffy"",""papillon"", 5, ""white"");         System.out.println(tuffy.toString());     } } Output:The result of executing this statement can be illustrated as :
Note : All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, also called the default constructor. This default constructor calls the class parent’s no-argument constructor (as it contain only one statement i.e super();), or the Object class constructor if the class has no other parent (as Object class is parent of all classes either directly or indirectly).Ways to create object of a classThere are four ways to create objects in java.Strictly speaking there is only one way(by using new keyword),and the rest internally use new keyword. Creating multiple objects by one type only (A good practice)Anonymous objects  Anonymous objects are the objects that are instantiated but are not stored in a reference variable.This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
10,"Java is one of the most popular and widely used programming language.
Simple Hello World Program : Output : Overview, Basics,   OOP concepts, Inheritance   Operators,   Strings,   Input and Output, Arrays , Arrays Class,  Important Keywords in Java ,Java vs C++,   Methods in Java,   Constructors,   Exception Handling,  Interfaces and Abstract Classes, Java Packages, Multithreading,   Garbage Collection, Wrapper Classes, Reflection in Java,   File Handling,   Collection in Java, Collection Interview FAQ’s  ,Collections Class (Contains utility functions on Collections),   Useful and/or Advanced Features,   Image Processing,  Networking in Java, Interview Questions, Misc, Multiple Choice Questions, Java 8 Stream MethodsApache in JavaJava Recent Articles!
Java Output & Multiple Choice Questions",java
11,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.
Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.However to become proficient in any programming language, one Firstly needs to understand the basics of that language.Therefore, below are the basics of Java in the format in which it will help you the most to get the headstart:Learn about setting up the Java environment here: Setting up the environment in JavaLearn about printing “Hello World” in Java here: Beginning Java programming with Hello World Example
Learn about Comments in Java here: Comments in Java Learn about different data types in Java here: Data types in Java Learn about Variables in Java here: Variables in Java
Learn about Keywords in Java here: Keywords in Java
Learn about Operators in Java here: Operators in Java
Learn about Decision Making in Java here: Decision Making in Java
Learn about Loops in Java here: Loops in Java GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
12,C Programming Mock TestsData Structures Mock TestsAlgorithms Mock TestsOperating Systems Mock TestsC++ Programming Mock TestsJava Programming Mock TestsPython Programming Mock TestsGATE Mock TestsDBMS Mock TestsCompiler Design Mock TestsComputer Networks Mock TestsTheory of Computation Mock TestsAptitude Mock TestsComputer Organization and ArchitectureOther Topics in Computer ScienceEngineering MathematicsCS Interview Questions ,java
13,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.
Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.Therefore, Java is a very successful language and it is gaining popularity day by day.You can download java from here. Here you will find different versions of java. Choose and download the one compatible with your operating system.
For detailed instructions for setting up of Java, refer this article.After you have set up the Java environment correctly, try running this simple program:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to print GeeksforGeeks publicclassGFG {     publicstaticvoidmain(String args[])     {         System.out.println(""GeeksforGeeks"");     } } If the environment is set up correctly and the code is correctly written, you shall see this output on your console. That is your first Java program!GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
14,"In inheritance, subclass acquires super class properties. An important point to note is, when subclass object is created, a separate object of super class object will not be created. Only a subclass object object is created that has super class variables.This situation is different from a normal assumption that a constructor call means an object of the class is created, so we can’t blindly say that whenever a class constructor is executed, object of that class is created or not.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to demonstrate that both super class // and subclass constructors refer to same object  // super class classFruit {     publicFruit()     {         System.out.println(""Super class constructor"");         System.out.println(""Super class object hashcode :""+                            this.hashCode());         System.out.println(this.getClass().getName());     } }  // sub class classApple extendsFruit {     publicApple()     {         System.out.println(""Subclass constructor invoked"");         System.out.println(""Sub class object hashcode :""+                            this.hashCode());         System.out.println(this.hashCode() + ""   ""+                            super.hashCode());          System.out.println(this.getClass().getName() + ""  ""+                            super.getClass().getName());     } }  // driver class publicclassTest {     publicstaticvoidmain(String[] args)     {         Apple myApple = newApple();     } } Output:As we can see that both super class(Fruit) object hashcode and subclass(Apple) object hashcode are same, so only one object is created. This object is of class Apple(subclass) as when we try to print name of class which object is created, it is printing Apple which is subclass.This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
15,"The process of Java programming can be simplified in three steps:Below given  program is the simplest program of Java printing “Hello World” to the screen. Let us try to understand every bit of code step by step.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                /* This is a simple Java program.    FileName : ""HelloWorld.java"". */classHelloWorld {     // Your program begins with a call to main().     // Prints ""Hello, World"" to the terminal window.     publicstaticvoidmain(String args[])     {         System.out.println(""Hello, World"");     } } Output:The “Hello World!” program consists of three primary components: the HelloWorld class definition, the main method and source code comments. Following explanation will provide you with a basic understanding of the code:mainHelloWorld is an identifier that is the name of the class. The entire class definition, including all of its members, will be between the opening curly brace  {  and the closing curly brace  } .mainLike in C/C++, main method is the entry point for your application and will subsequently invoke all the other methods required by your program.This line outputs the string “Hello, World” followed by a new line on the screen. Output is actually accomplished by the built-in println( ) method. System is a predefined class that provides access to the system, and out is the variable of type output stream that is connected to the console.This is a multiline comment. This type of comment must begin with /* and end with */. For single line you may directly use // as in C/C++.Important Points :Compiling the program  :This will print “Hello World” to the terminal screen.In WindowsIn LinuxThis article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
16,"Campus placements season is beginning at almost all the colleges and each one of us wants to prepare to do the best. A lot of students have been asking on different forums “How to use GeeksforGeeks for placement preparation”? In this article, a step by step guide for placement preparation is discussed.        Set 2 – To guide you going beyond the basics and getting placed in your dream companies 🙂 C++JavaPythonDSAlgorithmsDBMSComputer NetworksOperating System 
Company wise preparation articles, coding practice and subjective questions.If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above",java
17,"Overloading allows different methods to have the same name, but different signatures where the signature can differ by the number of input parameters or type of input parameters or both. Overloading is related to compile-time (or static) polymorphism.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of method // overloading in Java.  publicclassSum {      // Overloaded sum(). This sum takes two int parameters     publicintsum(intx, inty)     {         return(x + y);     }      // Overloaded sum(). This sum takes three int parameters     publicintsum(intx, inty, intz)     {         return(x + y + z);     }      // Overloaded sum(). This sum takes two double parameters     publicdoublesum(doublex, doubley)     {         return(x + y);     }      // Driver code     publicstaticvoidmain(String args[])     {         Sum s = newSum();         System.out.println(s.sum(10, 20));         System.out.println(s.sum(10, 20, 30));         System.out.println(s.sum(10.5, 20.5));     } } Output :Question Arises:
Q. What if the exact prototype does not match with arguments.
Ans.
Priority wise, compiler take these steps:Let’s take an example to clear the concept:-                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                classDemo {     publicvoidshow(intx)     {         System.out.println(""In int""+ x);     }     publicvoidshow(String s)     {         System.out.println(""In String""+ s);     }     publicvoidshow(byteb)     {         System.out.println(""In byte""+ b);     } } classUseDemo {     publicstaticvoidmain(String[] args)     {         bytea = 25;         Demo obj = newDemo();         obj.show(a); // it will go to         // byte argument         obj.show(""hello""); // String         obj.show(250); // Int         obj.show('A'); // Since char is         // not available, so the datatype         // higher than char in terms of         // range is int.         obj.show(""A""); // String         obj.show(7.5); // since float datatype // is not available and so it's higher // datatype, so at this step their // will be an error. } } What is the advantage?
We don’t have to create and remember different names for functions doing the same thing. For example, in our code, if overloading was not supported by Java, we would have to create method names like sum1, sum2, … or sum2Int, sum3Int, … etc.Can we overload methods on return type?
We cannot overload by return type. This behavior is same in C++. Refer this for details                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                publicclassMain {     publicintfoo() { return10; }      // compiler error: foo() is already defined     publiccharfoo() { return'a'; }      publicstaticvoidmain(String args[])     {     } } However, Overloading methods on return type are possible in cases where the data type of the function being called is explicitly specified. Look at the examples below :                                      edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate the working of method // overloading in static methods publicclassMain {      publicstaticintfoo(inta) { return10; }     publicstaticcharfoo(inta, intb) { return'a'; }      publicstaticvoidmain(String args[])     {         System.out.println(foo(1));         System.out.println(foo(1, 2));     } } Output:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of method // overloading in  methods classA {     publicintfoo(inta) { return10; }      publiccharfoo(inta, intb) { return'a'; } }  publicclassMain {      publicstaticvoidmain(String args[])     {         A a = newA();         System.out.println(a.foo(1));         System.out.println(a.foo(1, 2));     } } Output:Can we overload static methods?
The answer is ‘Yes’. We can have two ore more static methods with same name, but differences in input parameters. For example, consider the following Java program. Refer this for details.Can we overload methods that differ only by static keyword?
We cannot overload two methods in Java if they differ only by static keyword (number of parameters and types of parameters is same). See following Java program for example. Refer this for details.Can we overload main() in Java?
Like other static methods, we can overload main() in Java. Refer overloading main() in Java for more details.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program with overloaded main() importjava.io.*;  publicclassTest {      // Normal main()     publicstaticvoidmain(String[] args)     {         System.out.println(""Hi Geek (from main)"");         Test.main(""Geek"");     }      // Overloaded main methods     publicstaticvoidmain(String arg1)     {         System.out.println(""Hi, ""+ arg1);         Test.main(""Dear Geek"", ""My Geek"");     }     publicstaticvoidmain(String arg1, String arg2)     {         System.out.println(""Hi, ""+ arg1 + "", ""+ arg2);     } } Output :Does Java support Operator Overloading?
Unlike C++, Java doesn’t allow user-defined overloaded operators. Internally Java overloads operators, for example, + is overloaded for concatenation.What is the difference between Overloading and Overriding?Related Articles:This article is contributed by Shubham Agrawal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
18,"Java is one of the most popular and widely used programming language and platform. A platform is an environment that helps to develop and run programs written in any programming language.Java is fast, reliable and secure. From desktop to web applications, scientific supercomputers to gaming consoles, cell phones to the Internet, Java is used in every nook and corner.Java is easy to learn and its syntax is simple and easy to understand. It is based on C++ (so easier for programmers who know C++). Java has removed many confusing and rarely-used features e.g. explicit pointers, operator overloading etc. Java also takes care of memory management and for that, it provides an automatic garbage collector. This collects the unused objects automatically.Below is the complete guide as to how to get started with Java and make yourself proficient in it.Learn about Java here: How to start learning Java
Learn about JVM here: JVM
By reading this article, you will get the to topics from how to set up the Java Environment to the details about its coding.Learn about Java Programming Basics here: Java Programming Basics
Learn about OOPs concepts in Java here: Object Oriented Programming (OOPs) Concept in Java
Learn about Classes and Objects in Java here: Classes and Objects in Java
Learn about Constructors in Java here: Constructors in Java
Learn about Methods in Java here: Methods in Java
Learn about Strings in Java here: Strings in Java
Learn about Arrays in Java here: Arrays in Java
Learn about Collections in Java here: Collections in Java
Learn about Generics in Java here: Generics in Java
Learn about Stream In Java here: Stream In Java
Learn about Exceptions and Exception Handling in Java here: Exceptions and Exception Handling in Java
Learn about Regular Expressions here: Regular Expressions (ReGex) in JavaLearn about Multithreading in Java here: Multithreading in Java
Learn about File Handling in Java here: File Handling in Java
Learn about Packages in Java here: Packages in Java
GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
19,"Classes and Objects are basic concepts of Object Oriented Programming which revolve around the real life entities.ClassA class is a user defined blueprint or prototype from which objects are created.  It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order:Constructors are used for initializing new objects. Fields are variables that provides the state of the class and its objects, and methods are used to implement the behavior of the class and its objects.There are various types of classes that are used in real time applications such as nested classes, anonymous classes, lambda expressions.ObjectIt is a basic unit of Object Oriented Programming and represents the real life entities.  A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of :Example of an object : dogObjects correspond to things found in the real world. For example, a graphics program may have objects such as “circle”, “square”, “menu”. An online shopping system might have objects such as “shopping cart”, “customer”, and “product”.Declaring Objects (Also called instantiating a class)When an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.Example :As we declare variables like (type name;). This notifies the compiler that we will use name to refer to data whose type is type. With a primitive variable, this declaration also reserves the proper amount of memory for the variable. So for reference variable, type must be strictly a concrete class name. In general,we can’t create objects of an abstract class or an interface.If we declare reference variable(tuffy) like this, its value will be undetermined(null) until an object is actually created and assigned to it. Simply declaring a reference variable does not create an object. Initializing an objectThe new operator instantiates a class by allocating memory for a new object and returning a reference to that memory. The new operator also invokes the class constructor.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Class Declaration  publicclassDog {     // Instance Variables     String name;     String breed;     intage;     String color;      // Constructor Declaration of Class     publicDog(String name, String breed,                    intage, String color)     {         this.name = name;         this.breed = breed;         this.age = age;         this.color = color;     }      // method 1     publicString getName()     {         returnname;     }      // method 2     publicString getBreed()     {         returnbreed;     }      // method 3     publicintgetAge()     {         returnage;     }      // method 4     publicString getColor()     {         returncolor;     }      @Override    publicString toString()     {         return(""Hi my name is ""+ this.getName()+                "".\nMy breed,age and color are ""+                this.getBreed()+"",""+ this.getAge()+                "",""+ this.getColor());     }      publicstaticvoidmain(String[] args)     {         Dog tuffy = newDog(""tuffy"",""papillon"", 5, ""white"");         System.out.println(tuffy.toString());     } } Output:The result of executing this statement can be illustrated as :
Note : All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, also called the default constructor. This default constructor calls the class parent’s no-argument constructor (as it contain only one statement i.e super();), or the Object class constructor if the class has no other parent (as Object class is parent of all classes either directly or indirectly).Ways to create object of a classThere are four ways to create objects in java.Strictly speaking there is only one way(by using new keyword),and the rest internally use new keyword. Creating multiple objects by one type only (A good practice)Anonymous objects  Anonymous objects are the objects that are instantiated but are not stored in a reference variable.This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
20,"Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.

Threads can be created by using two mechanisms :
1. Extending the Thread class
2. Implementing the Runnable Interface
 
Thread creation by extending the Thread class

We create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class. A thread begins its life inside run() method. We create an object of our new class and call start() method to start the execution of a thread. Start()  invokes the run() method on the Thread object.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code for thread creation by extending // the Thread class classMultithreadingDemo extendsThread {     publicvoidrun()     {         try        {             // Displaying the thread that is running             System.out.println (""Thread ""+                   Thread.currentThread().getId() +                   "" is running"");          }         catch(Exception e)         {             // Throwing an exception             System.out.println (""Exception is caught"");         }     } }  // Main Class publicclassMultithread {     publicstaticvoidmain(String[] args)     {         intn = 8; // Number of threads         for(inti=0; i<n; i++)         {             MultithreadingDemo object = newMultithreadingDemo();             object.start();         }     } } Output : 
Thread creation by implementing the Runnable Interface

We create a new class which implements java.lang.Runnable interface and override run() method. Then we instantiate a Thread object and call start() method on this object.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code for thread creation by implementing // the Runnable Interface classMultithreadingDemo implementsRunnable {     publicvoidrun()     {         try        {             // Displaying the thread that is running             System.out.println (""Thread ""+                                 Thread.currentThread().getId() +                                 "" is running"");          }         catch(Exception e)         {             // Throwing an exception             System.out.println (""Exception is caught"");         }     } }  // Main Class classMultithread {     publicstaticvoidmain(String[] args)     {         intn = 8; // Number of threads         for(inti=0; i<n; i++)         {             Thread object = newThread(newMultithreadingDemo());             object.start();         }     } } Output : Thread Class vs Runnable Interface
1. If we extend the Thread class, our class cannot extend any other class because Java doesn’t support multiple inheritance. But, if we implement the Runnable interface, our class can still extend other base classes.

2. We can achieve basic functionality of a thread by extending Thread class because it provides some inbuilt methods like yield(), interrupt()  etc. that are not available in Runnable interface.
 
This article is contributed by Mehak Narang. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
21,"Provides classes that are fundamental to the design of the Java programming language. The most important classes are Object, which is the root of the class hierarchy, and Class, instances of which represent classes at run time.Following are the Important Classes in Java.lang package :More articles:",java
22,"Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented etc.
Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of computer architecture.The latest version is Java 11.Below are the environment settings for both Linux and Windows. JVM, JRE and JDK  all three are platform dependent because configuration of each Operating System is different. But, Java is platform independent.There are few things which must be clear before setting up the environmentSteps for Setting up Java Environment for Windows
Steps for LinuxIn linux, there are several ways to install java. But we will refer to simplest and easy way to install java using terminal. For linux we will install OpenJDK. OpenJDK is a free and open source implementation of the Java programming language.Popular Java Editors/IDE :Related Article: How to run java class file which is in different directory?This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
23,"In programming languages, identifiers are used for identification purpose. In Java, an identifier can be a class name, method name, variable name or a label. For example :In the above java code, we have 5 identifiers namely :Rules for defining Java IdentifiersThere are certain rules for defining a valid java identifier. These rules must be followed, otherwise we get compile-time error. These rules are also valid for other languages like C,C++.Examples of valid identifiers : Examples of invalid identifiers : Reserved WordsAny programming language reserves some words to represent functionalities defined by that language. These words are called reserved words.They can be briefly categorised into two parts : keywords(50) and literals(3).keywords define functionalities and literals defines a value.Identifiers are used by symbol tables in various analyzing phases(like lexical,syntax,semantic) of a compiler architecture.Note : The keywords const and goto are reserved, even though they are not currently used. In place of const, final keyword is used. Some keywords like strictfp are included in later versions of Java.This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
24,"The AbstractCollection class in Java is a part of the Java Collection Framework and implements the Collection interface. It is used to implement an unmodifiable collection, for which one needs to only extend this AbstractCollection Class and implement only the iterator and the size methods.Class Hierarchy:Syntax:Constructors in Java AbstractCollection:Below is the sample program to illustrate AbstractCollection in Java:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate AbstractCollection  importjava.util.*; importjava.util.AbstractCollection;  publicclassGFG {     publicstaticvoidmain(String[] args)     {         // Create an empty collection         AbstractCollection<Object>             abs = newArrayList<Object>();          // Use add() method to add         // elements in the collection         abs.add(""Welcome"");         abs.add(""To"");         abs.add(""Geeks"");         abs.add(""4"");         abs.add(""Geeks"");          // Displaying the Collection         System.out.println(""AbstractCollection: ""                           + abs);     } } Methods in Java Abstract Collection:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate // methods of AbstractCollection  importjava.util.*; importjava.util.AbstractCollection;  publicclassAbstractCollectionDemo {     publicstaticvoidmain(String args[])     {          // Creating an empty collection         AbstractCollection<String>             abs1 = newTreeSet<String>();          // Use add() method to add         // elements into the Collection         abs1.add(""Welcome"");         abs1.add(""To"");         abs1.add(""Geeks"");         abs1.add(""4"");         abs1.add(""Geeks"");         abs1.add(""TreeSet"");          // Displaying the Collection         System.out.println(""AbstractCollection 1: ""                           + abs1);          // Creating anothe Collection         AbstractCollection<String>             abs2 = newTreeSet<String>();          // Displaying the Collection         System.out.println(""AbstractCollection 2: ""                           + abs2);          // Using addAll() method to Append         abs2.addAll(abs1);          // Displaying the Collection         System.out.println(""AbstractCollection 2: ""                           + abs2);          // Clearing the collection         // using clear() method         abs1.clear();          // Check for the empty collection         System.out.println(""Is the collection empty? ""                           + abs1.isEmpty());     } } Reference: https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.htmlGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
25,"In java, object destruction is taken care by the Garbage Collector module and the objects which do not have any references to them are eligible for garbage collection. Garbage Collector is capable to identify this type of objects.
Island of Isolation:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                publicclassTest {     Test i;     publicstaticvoidmain(String[] args)       {         Test t1 = newTest();         Test t2 = newTest();                   // Object of t1 gets a copy of t2         t1.i = t2;               // Object of t2 gets a copy of t1         t2.i = t1;                   // Till now no object eligible         // for garbage collection          t1 = null;                  //now two objects are eligible for         // garbage collection          t2 = null;                  // calling garbage collector         System.gc();             }      @Override    protectedvoidfinalize() throwsThrowable      {          System.out.println(""Finalize method called"");      } } Output:Explanation :
Before destructing an object, Garbage Collector calls finalize method at most one time on that object.
The reason finalize method called two times in above example because two objects are eligible for garbage collection.This is because we don’t have any external references to t1 and t2 objects after executing  t2=null.
All we have is only internal references(which is in instance variable i of class Test) to them of each other. There is no way we can call instance variable of both objects. So, none of the objects can be called again. t2=nullTill t2.i = t1 : Both the objects have external references t1 and t2.
t1 = null : Both the objects can be reached via t2.i and t2 respectively.
t2 = null:  No way to reach any of the objects.
Now, both the objects are eligible for garbage collection as there is no way we can call them. This is popularly known as Island of Isolation.Reference:This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
26,"Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold, but remembering such a large and precise number comes out to be a difficult job. Therefore, Java has constants to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.Example 1:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to show // the value of Integer.MAX_VALUE  classGFG {      // Driver code     publicstaticvoidmain(String[] arg)     {          // Print the value of Integer.MAX_VALUE         System.out.println(""Integer.MAX_VALUE = ""                           + Integer.MAX_VALUE);     } } Any integer variable cannot store any value beyond this limit. Upon doing so, the memory will overflow and the value will get negative.Example 2: Trying to initialize a variable value Integer.MAX_VALUE + 1                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to show what happens when // a value greater than Integer.MAX_VALUE // is stored in an int variable  classGFG {      // Driver code     publicstaticvoidmain(String[] arg)     {          try{              System.out.println(                 ""Trying to initialize""                + "" a N with value""                + "" Integer.MAX_VALUE + 1"");              // Try to store value Integer.MAX_VALUE + 1             intN = Integer.MAX_VALUE + 1;              // Print the value of N             System.out.println(""N = ""+ N);         }         catch(Exception e) {             System.out.println(e);         }     } } Example 3:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to show // the value of Integer.MIN_VALUE  classGFG {      // Driver code     publicstaticvoidmain(String[] arg)     {          // Print the value of Integer.MIN_VALUE         System.out.println(""Integer.MIN_VALUE = ""                           + Integer.MIN_VALUE);     } } Any integer variable cannot store any value below this limit. Upon doing so, the memory will overflow and the value will get positive.Example 2: Trying to initialize a variable value Integer.MIN_VALUE – 1                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to show what happens when // a value less than Integer.MIN_VALUE // is stored in an int variable  classGFG {      // Driver code     publicstaticvoidmain(String[] arg)     {          try{              System.out.println(                 ""Trying to initialize""                + "" a N with value""                + "" Integer.MIN_VALUE - 1"");              // Try to store value Integer.MIN_VALUE - 1             intN = Integer.MIN_VALUE - 1;              // Print the value of N             System.out.println(""N = ""+ N);         }         catch(Exception e) {             System.out.println(e);         }     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
27,"Directly accessing Grandparent’s member in Java:Predict the output of following Java program.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // filename Main.java classGrandparent {     publicvoidPrint() {         System.out.println(""Grandparent's Print()"");     } }   classParent extendsGrandparent {     publicvoidPrint() {                System.out.println(""Parent's Print()"");     } }   classChild extendsParent {     publicvoidPrint() {         super.super.Print();  // Trying to access Grandparent's Print()         System.out.println(""Child's Print()"");     } }   publicclassMain {     publicstaticvoidmain(String[] args) {         Child c = newChild();         c.Print();     } } Output:  Compiler Error
There is error in line “super.super.print();”.  In Java, a class cannot directly access the grandparent’s members.   It is allowed in C++ though.  In C++, we can use scope resolution operator (::) to access any ancestor’s member in inheritance hierarchy.  In Java, we can access grandparent’s members only through the parent class.  For example, the following program compiles and runs fine.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // filename Main.java classGrandparent {     publicvoidPrint() {         System.out.println(""Grandparent's Print()"");     } }   classParent extendsGrandparent {     publicvoidPrint() {         super.Print();         System.out.println(""Parent's Print()"");     } }   classChild extendsParent {     publicvoidPrint() {         super.Print();         System.out.println(""Child's Print()"");     } }   publicclassMain {     publicstaticvoidmain(String[] args) {         Child c = newChild();         c.Print();     } } Output:Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
28,"For every thread, JVM creates a separate stack at the time of thread creation. The memory for a Java Virtual Machine stack does not need to be contiguous. The Java virtual machine only performs two operations directly on Java Stacks: it pushes and pops frames. And stack for a particular thread may be termed as Run – Time Stack. Each and every method call performed by that thread is stored in the corresponding run time stack including parameters, local variables, intermediate computations, and other data. After completing a method, corresponding entry from the stack is removed. After completing all method calls the stack becomes empty and that empty stack is destroyed by the JVM just before terminating the thread. The data stored in the stack is available for the corresponding thread and not available to the remaining threads. Hence we can say local data is thread safe. Each entry in the stack is called Stack Frame or Activation Record. Stack Frame Structure
The stack frame basically consists of three parts: Local Variable Array, Operand Stack & Frame Data. When JVM invokes a Java method, first it checks the class data to determine the number of words (size of the local variable array and operand stack, which are measured in words for each individual method) required by the method in the local variables array and operand stack. It creates a stack frame of the proper size for invoked method and pushes it onto the Java stack.1. Local Variable Array (LVA):2. Operand Stack (OS):3. Frame Data (FD):GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
29,"Unlike C++, Java supports a special block, called static block (also called static clause) which can be used for static initializations of a class. This code inside static block is executed only once: the first time the class is loaded into memory. For example, check output of following Java program.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // filename: Main.java classTest {     staticinti;     intj;          // start of static block      static{         i = 10;         System.out.println(""static block called "");     }     // end of static block  }  classMain {     publicstaticvoidmain(String args[]) {          // Although we don't have an object of Test, static block is          // called because i is being accessed in following statement.         System.out.println(Test.i);      } } Output:
static block called
10
Also, static blocks are executed before constructors. For example, check output of following Java program.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // filename: Main.java classTest {     staticinti;     intj;     static{         i = 10;         System.out.println(""static block called "");     }     Test(){         System.out.println(""Constructor called"");     } }  classMain {     publicstaticvoidmain(String args[]) {         // Although we have two objects, static block is executed only once.        Test t1 = newTest();        Test t2 = newTest();     } } Output:
static block called
Constructor called
Constructor called
What if we want to execute some code for every object?
We use Initializer Block in JavaReferences:
Thinking in Java BookPlease write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
30,"In object-oriented programming, a singleton class is a class that can have only one object (an instance of the class) at a time.
After first time, if we try to instantiate the Singleton class, the new variable also points to the first instance created. So whatever modifications we do to any variable inside the class through any instance, it affects the variable of the single instance created and is visible if we access that variable through any variable of that class type defined.
To design a singleton class:Normal class vs Singleton class: Difference in normal and singleton class in terms of instantiation is that, For normal class we use constructor, whereas for singleton class we use getInstance() method (Example code:I). In general, to avoid confusion we may also use the class name as method name while defining this method (Example code:II).Implementing Singleton class with getInstance() method                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program implementing Singleton class // with getInstance() method classSingleton {     // static variable single_instance of type Singleton     privatestaticSingleton single_instance = null;      // variable of type String     publicString s;      // private constructor restricted to this class itself     privateSingleton()     {         s = ""Hello I am a string part of Singleton class"";     }      // static method to create instance of Singleton class     publicstaticSingleton getInstance()     {         if(single_instance == null)             single_instance = newSingleton();          returnsingle_instance;     } }  // Driver Class classMain {     publicstaticvoidmain(String args[])     {         // instantiating Singleton class with variable x         Singleton x = Singleton.getInstance();          // instantiating Singleton class with variable y         Singleton y = Singleton.getInstance();          // instantiating Singleton class with variable z         Singleton z = Singleton.getInstance();          // changing variable of instance x         x.s = (x.s).toUpperCase();          System.out.println(""String from x is ""+ x.s);         System.out.println(""String from y is ""+ y.s);         System.out.println(""String from z is ""+ z.s);         System.out.println(""\n"");          // changing variable of instance z         z.s = (z.s).toLowerCase();          System.out.println(""String from x is ""+ x.s);         System.out.println(""String from y is ""+ y.s);         System.out.println(""String from z is ""+ z.s);     } } Output:
Explanation: In the Singleton class, when we first time call getInstance() method, it creates an object of the class with name single_instance and return it to the variable. Since single_instance is static, it is changed from null to some object. Next time, if we try to call getInstance() method, since single_instance is not null, it is returned to the variable, instead of instantiating the Singleton class again. This part is done by if condition. In the main class, we instantiate the singleton class with 3 objects x, y, z by calling static method getInstance(). But actually after creation of object x, variables y and z are pointed to object x as shown in the diagram. Hence, if we change the variables of object x, that is reflected when we access the variables of objects y and z. Also if we change the variables of object z, that is reflected when we access the variables of objects x and y. Implementing Singleton class with method name as that of class name                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program implementing Singleton class // with method name as that of class classSingleton {     // static variable single_instance of type Singleton     privatestaticSingleton single_instance=null;      // variable of type String     publicString s;      // private constructor restricted to this class itself     privateSingleton()     {         s = ""Hello I am a string part of Singleton class"";     }      // static method to create instance of Singleton class     publicstaticSingleton Singleton()     {         // To ensure only one instance is created         if(single_instance == null)         {             single_instance = newSingleton();         }         returnsingle_instance;     } }  // Driver Code classMain {     publicstaticvoidmain(String args[])     {         // instantiating Singleton class with variable x         Singleton x = Singleton.Singleton();          // instantiating Singleton class with variable y         Singleton y = Singleton.Singleton();          // instantiating Singleton class with variable z         Singleton z = Singleton.Singleton();          // changing variable of instance x         x.s = (x.s).toUpperCase();          System.out.println(""String from x is ""+ x.s);         System.out.println(""String from y is ""+ y.s);         System.out.println(""String from z is ""+ z.s);         System.out.println(""\n"");          // changing variable of instance x         z.s = (z.s).toLowerCase();          System.out.println(""String from x is ""+ x.s);         System.out.println(""String from y is ""+ y.s);         System.out.println(""String from z is ""+ z.s);     } } Output:Explanation: In the Singleton class, when we first time call Singleton() method, it creates an object of class Singleton with name single_instance and return it to the variable. Since single_instance is static, it is changed from null to some object. Next time if we try to call Singleton() method, since single_instance is not null, it is returned to the variable, instead of instantiating the Singleton class again.This article is contributed by Pavan Gopal Rayapati. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.",java
31,"Generics in Java is similar to templates in C++. The idea is to allow type (Integer, String, … etc and user defined types) to be a parameter to methods, classes and interfaces. For example, classes like HashSet, ArrayList, HashMap, etc use generics very well. We can use them for any type.                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Simple Java program to show working of user defined // Generic classes   // We use < > to specify Parameter type classTest<T> {     // An object of type T is declared     T obj;     Test(T obj) {  this.obj = obj;  }  // constructor     publicT getObject()  { returnthis.obj; } }   // Driver class to test above classMain {     publicstaticvoidmain (String[] args)     {         // instance of Integer type         Test <Integer> iObj = newTest<Integer>(15);         System.out.println(iObj.getObject());           // instance of String type         Test <String> sObj =                           newTest<String>(""GeeksForGeeks"");         System.out.println(sObj.getObject());     } }Output: We can also pass multiple Type parameters in Generic classes.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Simple Java program to show multiple // type parameters in Java Generics  // We use < > to specify Parameter type classTest<T, U> {     T obj1;  // An object of type T     U obj2;  // An object of type U      // constructor     Test(T obj1, U obj2)     {         this.obj1 = obj1;         this.obj2 = obj2;     }      // To print objects of T and U     publicvoidprint()     {         System.out.println(obj1);         System.out.println(obj2);     } }  // Driver class to test above classMain {     publicstaticvoidmain (String[] args)     {         Test <String, Integer> obj =             newTest<String, Integer>(""GfG"", 15);          obj.print();     } }Output:                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Simple Java program to show working of user defined // Generic functions   classTest {     // A Generic method example     static<T> voidgenericDisplay (T element)     {         System.out.println(element.getClass().getName() +                            "" = ""+ element);     }       // Driver method     publicstaticvoidmain(String[] args)     {          // Calling generic method with Integer argument         genericDisplay(11);           // Calling generic method with String argument         genericDisplay(""GeeksForGeeks"");           // Calling generic method with double argument         genericDisplay(1.0);     } }Output : .                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Simple Java program to demonstrate that NOT using // generics can cause run time exceptions importjava.util.*;  classTest {     publicstaticvoidmain(String[] args)     {         // Creatinga an ArrayList without any type specified         ArrayList al = newArrayList();          al.add(""Sachin"");         al.add(""Rahul"");         al.add(10); // Compiler allows this          String s1 = (String)al.get(0);         String s2 = (String)al.get(1);          // Causes Runtime Exception         String s3 = (String)al.get(2);     } } Output : How generics solve this problem?
At the time of defining ArrayList, we can specify that this list can take only String objects.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Using generics converts run time exceptions into  // compile time exception. importjava.util.*;  classTest {     publicstaticvoidmain(String[] args)     {         // Creating a an ArrayList with String specified         ArrayList <String> al = newArrayList<String> ();          al.add(""Sachin"");         al.add(""Rahul"");          // Now Compiler doesn't allow this         al.add(10);           String s1 = (String)al.get(0);         String s2 = (String)al.get(1);         String s3 = (String)al.get(2);     } } Output:.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // We don't need to typecast individual members of ArrayList importjava.util.*;  classTest {     publicstaticvoidmain(String[] args)     {         // Creating a an ArrayList with String specified         ArrayList <String> al = newArrayList<String> ();          al.add(""Sachin"");         al.add(""Rahul"");          // Typecasting is not needed          String s1 = al.get(0);         String s2 = al.get(1);     } } .References:
https://docs.oracle.com/javase/tutorial/java/generics/why.htmlThis article is contributed by Dharmesh Singh. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
32,"Looping in programming languages is a feature which facilitates the execution of a set of instructions/functions repeatedly while some condition evaluates to true.
Java provides three ways for executing the loops. While all the ways provide similar basic functionality, they differ in their syntax and condition checking time. Flowchart:
                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to illustrate while loop classwhileLoopDemo {     publicstaticvoidmain(String args[])     {         intx = 1;          // Exit when x becomes greater than 4         while(x <= 4)         {             System.out.println(""Value of x:""+ x);              // Increment the value of x for             // next iteration             x++;         }     } } Output:Flowchart:
                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to illustrate for loop. classforLoopDemo {     publicstaticvoidmain(String args[])     {         // for loop begins when x=2         // and runs till x <=4         for(intx = 2; x <= 4; x++)             System.out.println(""Value of x:""+ x);     } } Output:Enhanced For loopJava also includes another version of for loop introduced in Java 5. Enhanced for loop provides a simpler way to iterate through the elements of a collection or array. It is inflexible and should be used only when there is a need to iterate through the elements in sequential manner without knowing the index of currently processed element.
Also note that the object/variable is immutable when enhanced for loop is used i.e it ensures that the values in the array can not be modified, so it can be said as read only loop where you can’t update the values as opposite to other loops where values can be modified.
We recommend using this form of the for statement instead of the general form whenever possible.(as per JAVA doc.)
Syntax:Lets take an example to demonstrate how enhanced for loop can be used to simpify the work. Suppose there is an array of names and we want to print all the names in that array. Let’s see the difference with these two examples
Enhanced for loop simplifies the work as follows-                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to illustrate enhanced for loop publicclassenhancedforloop {     publicstaticvoidmain(String args[])     {         String array[] = {""Ron"", ""Harry"", ""Hermoine""};          //enhanced for loop         for(String x:array)         {             System.out.println(x);         }          /* for loop for same function         for (int i = 0; i < array.length; i++)         {             System.out.println(array[i]);         }         */    } } Output:Flowchart:
                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to illustrate do-while loop classdowhileloopDemo {     publicstaticvoidmain(String args[])     {         intx = 21;         do        {             // The line will be printed even             // if the condition is false             System.out.println(""Value of x:""+ x);             x++;         }         while(x < 20);     } } Output:Pitfalls of Loops                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                //Java program to illustrate various pitfalls. publicclassLooppitfallsDemo {     publicstaticvoidmain(String[] args)     {          // infinite loop because condition is not apt         // condition should have been i>0.         for(inti = 5; i != 0; i -= 2)         {             System.out.println(i);         }         intx = 5;          // infinite loop because update statement         // is not provided.         while(x == 5)         {             System.out.println(""In the loop"");         }     } }                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                //Java program for out of memory exception. importjava.util.ArrayList; publicclassInteger1 {     publicstaticvoidmain(String[] args)     {         ArrayList<Integer> ar = newArrayList<>();         for(inti = 0; i < Integer.MAX_VALUE; i++)         {             ar.add(i);         }     } } Output:This article is contributed by Rishabh Mahrsee. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
33,"Generating random numbers themselves have a good utility value and having them achieved by the usage of function can prove to be very useful. Java in its language has dedicated an entire library to Random numbers  seeing its importance in day-day programming. nextInt() is discussed in this article.The following example shows the usage of java.util.Random.nextInt()                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to demonstrate the working // of nextInt() importjava.util.*; publicclassNextInt1 {     publicstaticvoidmain(String[] args)     {          // create random object         Random ran = newRandom();          // generating integer         intnxt = ran.nextInt();          // Printing the random Number         System.out.println         (""The Randomly generated integer is : ""+ nxt);     } } Output:
The following example shows the usage of java.util.Random.nextInt(int n)                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to demonstrate the working // of nextInt(n) importjava.util.*; publicclassNextInt2 {     publicstaticvoidmain(String args[])     {          // create random object         Random ran = newRandom();          // Print next int value         // Returns number between 0-9         intnxt = ran.nextInt(10);          // Printing the random number          // between 0 and 9         System.out.println         (""Random number between 0 and 10 is : ""+ nxt);     } } Output:IllegalArgumentException :  This occurs when the argument passed is not positive.
An example to illustrate the Exception generated when n is not a positive number:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to demonstrate the Exception // of nextInt(n) importjava.util.*; publicclassNextInt2 {     publicstaticvoidmain(String[] args)     {          // create random object         Random ran = newRandom();          // generating number between 0 and -12345         // Raises Runtime error, as n is negative.         intnxt = ran.nextInt(-12345);          System.out.println         (""Generated Random number is : ""+ nxt);     } } 
Runtime Errors:Practical Applications Generating Random numbers have numerous applications, be it lottery, gambling or small scale gaming. A small Dice game have been demonstrated below in which a 6-mark Dice is thrown by 2 players, person securing 30 points 1st, wins.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to demonstrate the Application // of nextInt(n) importjava.util.*; publicclassNextIntAppli {     publicstaticvoidmain(String[] args)     {          intsum = 0, sum1 = 0, count = 0, count1 = 0;         intturn = 0;          // creating random object         Random ran = newRandom();         intflag = 0;          while(true) {             if(turn % 2== 0) {                  intp1 = ran.nextInt(6);                 sum += p1;                 System.out.printf                 (""Player 1 after turn %d is : %d\n"", turn, sum);             }             else{                  intp2 = ran.nextInt(6);                 sum1 += p2;                 System.out.printf                 (""Player 2 after turn %d is : %d\n"", turn, sum1);             }             if(sum >= 30) {                 flag = 1;                 break;             }             if(sum1 >= 30) {                 flag = 2;                 break;             }             turn++;         }         if(flag == 1)             System.out.println(""\nPlayer 1 WON!!"");         else            System.out.println(""\nPlayer 2 WON!!"");     } } Output:
This article is contributed by Suman Singh Rajput. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
34,"Initializer block contains the code that is always executed whenever an instance is created. It is used to declare/initialize the common part of various constructors of a class. For example,                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                importjava.io.*; publicclassGFG {     // Initializer block starts..     {         // This code is executed before every constructor.         System.out.println(""Common part of constructors invoked !!"");     }     // Initializer block ends      publicGFG()     {         System.out.println(""Default Constructor invoked"");     }     publicGFG(intx)     {         System.out.println(""Parametrized constructor invoked"");     }     publicstaticvoidmain(String arr[])     {         GFG obj1, obj2;         obj1 = newGFG();         obj2 = newGFG(0);     } } Output: We can note that the contents of initializer block are executed whenever any constructor is invoked (before the constructor’s contents)The order of initialization constructors and initializer block doesn’t matter, initializer block is always executed before constructor.  See this for example.Refer below article for more details in instance initialization: 
Instance Initialization Block (IIB) in JavaWhat if we want to execute some code once for all objects of a class?
We use Static Block in JavaThis article is contributed by Ashutosh Singh. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
35,"Given an ArrayList collection in Java, the task is to remove the first element from the ArrayList.Example:We can use the remove() method of ArrayList container in Java to remove the first element.ArrayList provides two overloaded remove() method:Note: Incase the ArrayList contains duplicates, it will delete the first occurrence of the object passed as a parameter to the remove() method.
Below is the implementation to delete the first element using the two approaches:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to delete the first element of ArrayList importjava.util.List; importjava.util.ArrayList;  publicclassGFG {     publicstaticvoidmain(String[] args)     {         List<Integer> al = newArrayList<>();         al.add(10);         al.add(20);         al.add(30);         al.add(1);         al.add(2);          // First element's index is always 0         intindex = 0;          // Delete first element by passing index         al.remove(index);          System.out.println(""Modified ArrayList : ""+ al);     } }                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to delete first element of ArrayList importjava.util.List; importjava.util.ArrayList;  publicclassGFG {     publicstaticvoidmain(String[] args)     {         List<Integer> al = newArrayList<>();         al.add(10);         al.add(20);         al.add(30);         al.add(1);         al.add(2);          // Since all elements are unique, pass the first         // elements value to delete it         // Note: values are integer object         al.remove(newInteger(10));          System.out.println(""Modified ArrayList : ""+ al);     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
36,"Linked List are linear data structures where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses. Each element is known as a node. Due to the dynamicity and ease of insertions and deletions, they are preferred over the arrays. It also has few disadvantages like the nodes cannot be accessed directly instead we need to start from the head and follow through the link to reach to a node we wish to access.
To store the elements in a linked list we use a doubly linked list which provides a linear data structure and also used to inherit an abstract class and implement list and deque interfaces.In Java, LinkedList class implements the list interface. The LinkedList class also consists of various constructors and methods like other java collections.Constructors for Java LinkedList:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code for Linked List implementation  importjava.util.*;  publicclassTest {     publicstaticvoidmain(String args[])     {         // Creating object of class linked list         LinkedList<String> object = newLinkedList<String>();          // Adding elements to the linked list         object.add(""A"");         object.add(""B"");         object.addLast(""C"");         object.addFirst(""D"");         object.add(2, ""E"");         object.add(""F"");         object.add(""G"");         System.out.println(""Linked list : ""+ object);          // Removing elements from the linked list         object.remove(""B"");         object.remove(3);         object.removeFirst();         object.removeLast();         System.out.println(""Linked list after deletion: ""+ object);          // Finding elements in the linked list         booleanstatus = object.contains(""E"");          if(status)             System.out.println(""List contains the element 'E' "");         else            System.out.println(""List doesn't contain the element 'E'"");          // Number of elements in the linked list         intsize = object.size();         System.out.println(""Size of linked list = ""+ size);          // Get and set elements from linked list         Object element = object.get(2);         System.out.println(""Element returned by get() : ""+ element);         object.set(2, ""Y"");         System.out.println(""Linked list after change : ""+ object);     } } Methods for Java LinkedList: 
This article is contributed by Mehak Narang.
 
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
37,"Reflection is an API which is used to examine or modify the behavior of methods, classes, interfaces at runtime.
Reflection can be used to get information about –                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A simple Java program to demonstrate the use of reflection importjava.lang.reflect.Method; importjava.lang.reflect.Field; importjava.lang.reflect.Constructor;  // class whose object is to be created classTest {     // creating a private field     privateString s;      // creating a public constructor     publicTest()  {  s = ""GeeksforGeeks""; }      // Creating a public method with no arguments     publicvoidmethod1()  {         System.out.println(""The string is ""+ s);     }      // Creating a public method with int as argument     publicvoidmethod2(intn)  {         System.out.println(""The number is ""+ n);     }      // creating a private method     privatevoidmethod3() {         System.out.println(""Private method invoked"");     } }  classDemo {     publicstaticvoidmain(String args[]) throwsException     {         // Creating object whose property is to be checked         Test obj = newTest();          // Creating class object from the object using         // getclass method         Class cls = obj.getClass();         System.out.println(""The name of class is ""+                             cls.getName());          // Getting the constructor of the class through the         // object of the class         Constructor constructor = cls.getConstructor();         System.out.println(""The name of constructor is ""+                             constructor.getName());          System.out.println(""The public methods of class are : "");          // Getting methods of the class through the object         // of the class by using getMethods         Method[] methods = cls.getMethods();          // Printing method names         for(Method method:methods)             System.out.println(method.getName());          // creates object of desired method by providing the         // method name and parameter class as arguments to         // the getDeclaredMethod         Method methodcall1 = cls.getDeclaredMethod(""method2"",                                                  int.class);          // invokes the method at runtime         methodcall1.invoke(obj, 19);          // creates object of the desired field by providing         // the name of field as argument to the          // getDeclaredField method         Field field = cls.getDeclaredField(""s"");          // allows the object to access the field irrespective         // of the access specifier used with the field         field.setAccessible(true);          // takes object and the new value to be assigned         // to the field as arguments         field.set(obj, ""JAVA"");          // Creates object of desired method by providing the         // method name as argument to the getDeclaredMethod         Method methodcall2 = cls.getDeclaredMethod(""method1"");          // invokes the method at runtime         methodcall2.invoke(obj);          // Creates object of the desired method by providing         // the name of method as argument to the          // getDeclaredMethod method         Method methodcall3 = cls.getDeclaredMethod(""method3"");          // allows the object to access the method irrespective          // of the access specifier used with the method         methodcall3.setAccessible(true);          // invokes the method at runtime         methodcall3.invoke(obj);     } } Output :Important observations : invoke() :  To invoke a method of the class at runtime we use following method–Class.getDeclaredField(FieldName) :  Used to get the private field.  Returns an object of type Field for specified field name.
Field.setAccessible(true) :   Allows to access the field irrespective of the access modifier used with the field.  Advantages of Using Reflection: Drawbacks:
Reference:
https://docs.oracle.com/javase/tutorial/reflect/index.htmlThis article is contributed by Akash Ojha.If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
38,"Encapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates.Other way to think about encapsulation is, it is a protective shield that prevents the data from being accessed by the code outside this shield.                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate encapsulation publicclassEncapsulate {     // private variables declared      // these can only be accessed by      // public methods of class     privateString geekName;     privateintgeekRoll;     privateintgeekAge;      // get method for age to access      // private variable geekAge     publicintgetAge()      {       returngeekAge;     }       // get method for name to access      // private variable geekName     publicString getName()      {       returngeekName;     }          // get method for roll to access      // private variable geekRoll     publicintgetRoll()      {        returngeekRoll;     }       // set method for age to access      // private variable geekage     publicvoidsetAge( intnewAge)     {       geekAge = newAge;     }       // set method for name to access      // private variable geekName     publicvoidsetName(String newName)     {       geekName = newName;     }          // set method for roll to access      // private variable geekRoll     publicvoidsetRoll( intnewRoll)      {       geekRoll = newRoll;     } } In the above program the class EncapsulateDemo is encapsulated as the variables are declared as private. The get methods like getAge() , getName() , getRoll() are set as public, these methods are used to access these variables. The setter methods like setName(), setAge(), setRoll() are also declared as public and are used to set the values of the variables.The program to access variables of the class EncapsulateDemo is shown below:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                publicclassTestEncapsulation {         publicstaticvoidmain (String[] args)      {         Encapsulate obj = newEncapsulate();                  // setting values of the variables          obj.setName(""Harsh"");         obj.setAge(19);         obj.setRoll(51);                  // Displaying values of the variables         System.out.println(""Geek's name: ""+ obj.getName());         System.out.println(""Geek's age: ""+ obj.getAge());         System.out.println(""Geek's roll: ""+ obj.getRoll());                  // Direct access of geekRoll is not possible         // due to encapsulation         // System.out.println(""Geek's roll: "" + obj.geekName);             } } Output:Advantages of Encapsulation:This article is contributed by Harsh Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
39,"JSON (JavaScript Object Notation) is a lightweight, text-based, language-independent data exchange format that is easy for humans and machines to read and write. JSON can represent two structured types: objects and arrays. An object is an unordered collection of zero or more name/value pairs. An array is an ordered sequence of zero or more values. The values can be strings, numbers, booleans, null, and these two structured types.Below is a simple example from Wikipedia that shows JSON representation of an object that describes a person. The object has string values for first name and last name, a number value for age, an object value representing the person’s address, and an array value of phone number objects.JSON Processing in Java : The Java API for JSON Processing JSON.simple is a simple Java library that allow parse, generate, transform, and query JSON.Getting Started : You need to download the  json-simple-1.1 jar and put it in your CLASSPATH before compiling and running the below example codes. Json-Simple API : It provides object models for JSON object and array structures. These JSON structures are represented as object models using types JSONObject and JSONArray. JSONObject provides a Map view to access the unordered collection of zero or more name/value pairs from the model. Similarly, JSONArray provides a List view to access the ordered sequence of zero or more values from the model.Write JSON to a fileLet us see an example that writes above JSON data into a file “JSONExample.json”, with help of JSONObject and JSONArray.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program for write JSON to a file  importjava.io.FileNotFoundException; importjava.io.PrintWriter; importjava.util.LinkedHashMap; importjava.util.Map; importorg.json.simple.JSONArray; importorg.json.simple.JSONObject;  publicclassJSONWriteExample {     publicstaticvoidmain(String[] args) throwsFileNotFoundException      {         // creating JSONObject         JSONObject jo = newJSONObject();                  // putting data to JSONObject         jo.put(""firstName"", ""John"");         jo.put(""lastName"", ""Smith"");         jo.put(""age"", 25);                  // for address data, first create LinkedHashMap         Map m = newLinkedHashMap(4);         m.put(""streetAddress"", ""21 2nd Street"");         m.put(""city"", ""New York"");         m.put(""state"", ""NY"");         m.put(""postalCode"", 10021);                  // putting address to JSONObject         jo.put(""address"", m);                  // for phone numbers, first create JSONArray          JSONArray ja = newJSONArray();                  m = newLinkedHashMap(2);         m.put(""type"", ""home"");         m.put(""number"", ""212 555-1234"");                  // adding map to list         ja.add(m);                  m = newLinkedHashMap(2);         m.put(""type"", ""fax"");         m.put(""number"", ""212 555-1234"");                  // adding map to list         ja.add(m);                  // putting phoneNumbers to JSONObject         jo.put(""phoneNumbers"", ja);                  // writing JSON to file:""JSONExample.json"" in cwd         PrintWriter pw = newPrintWriter(""JSONExample.json"");         pw.write(jo.toJSONString());                  pw.flush();         pw.close();     } } Output from file “JSONExample.json” :Note : In JSON, An object is an unordered set of name/value pairs, so JSONObject doesn’t preserve the order of an object’s name/value pairs, since it is (by definition) not significant. Hence in our output file, order is not preserved.Read JSON from a file Let us see an example that read JSON data from above created file “JSONExample.json” with help of JSONParser, JSONObject and JSONArray.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to read JSON from a file  importjava.io.FileReader; importjava.util.Iterator; importjava.util.Map;  importorg.json.simple.JSONArray; importorg.json.simple.JSONObject; importorg.json.simple.parser.*;  publicclassJSONReadExample  {     publicstaticvoidmain(String[] args) throwsException      {         // parsing file ""JSONExample.json""         Object obj = newJSONParser().parse(newFileReader(""JSONExample.json""));                  // typecasting obj to JSONObject         JSONObject jo = (JSONObject) obj;                  // getting firstName and lastName         String firstName = (String) jo.get(""firstName"");         String lastName = (String) jo.get(""lastName"");                  System.out.println(firstName);         System.out.println(lastName);                  // getting age         longage = (long) jo.get(""age"");         System.out.println(age);                  // getting address         Map address = ((Map)jo.get(""address""));                  // iterating address Map         Iterator<Map.Entry> itr1 = address.entrySet().iterator();         while(itr1.hasNext()) {             Map.Entry pair = itr1.next();             System.out.println(pair.getKey() + "" : ""+ pair.getValue());         }                  // getting phoneNumbers         JSONArray ja = (JSONArray) jo.get(""phoneNumbers"");                  // iterating phoneNumbers         Iterator itr2 = ja.iterator();                  while(itr2.hasNext())          {             itr1 = ((Map) itr2.next()).entrySet().iterator();             while(itr1.hasNext()) {                 Map.Entry pair = itr1.next();                 System.out.println(pair.getKey() + "" : ""+ pair.getValue());             }         }     } } Output:This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
40,"Sometimes in Competitive programming, it is essential to print the output in a given specified format. Most users are familiar with printf function in C. Let us see discuss how we can format the output in Java:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to demonstrate working of printf() in Java classJavaFormatter1 {   publicstaticvoidmain(String args[])   {     intx = 100;     System.out.printf(""Printing simple integer: x = %d\n"", x);      // this will print it upto 2 decimal places     System.out.printf(""Formatted with precison: PI = %.2f\n"", Math.PI);      floatn = 5.2f;      // automatically appends zero to the rightmost part of decimal     System.out.printf(""Formatted to specific width: n = %.4f\n"", n);      n = 2324435.3f;      // here number is formatted from right margin and occupies a     // width of 20 characters     System.out.printf(""Formatted to right margin: n = %20.4f\n"", n);   } } System.out.format() is equivalent to printf() and can also be used. 
                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of DecimalFormat importjava.text.DecimalFormat;  classJavaFormatter2 {   publicstaticvoidmain(String args[])   {     doublenum = 123.4567;      // prints only numeric part of a floating number     DecimalFormat ft = newDecimalFormat(""####"");     System.out.println(""Without fraction part: num = ""+ ft.format(num));      // this will print it upto 2 decimal places     ft = newDecimalFormat(""#.##"");     System.out.println(""Formatted to Give precison: num = ""+ ft.format(num));      // automatically appends zero to the rightmost part of decimal     // instead of #,we use digit 0     ft = newDecimalFormat(""#.000000"");     System.out.println(""appended zeroes to right: num = ""+ ft.format(num));      // automatically appends zero to the leftmost of decimal number     // instead of #,we use digit 0     ft = newDecimalFormat(""00000.00"");     System.out.println(""formatting Numeric part : num = ""+ft.format(num));      // formatting money in dollars     doubleincome = 23456.789;     ft = newDecimalFormat(""$###,###.##"");     System.out.println(""your Formatted Dream Income : ""+ ft.format(income));   } }                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of SimpleDateFormat importjava.text.ParseException; importjava.text.SimpleDateFormat; importjava.util.Date;  classFormatter3 {   publicstaticvoidmain(String args[]) throwsParseException   {     // Formatting as per given pattern in the argument     SimpleDateFormat ft = newSimpleDateFormat(""dd-MM-yyyy"");     String str = ft.format(newDate());     System.out.println(""Formatted Date : ""+ str);      // parsing a given String     str = ""02/18/1995"";     ft = newSimpleDateFormat(""MM/dd/yyyy"");     Date date = ft.parse(str);      // this will print the date as per parsed string     System.out.println(""Parsed Date : ""+ date);   } } References:
https://docs.oracle.com/javase/tutorial/essential/io/formatting.html
        https://docs.oracle.com/javase/tutorial/java/data/numberformat.html
        http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.htmlThis article is contributed by Pankaj Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.",java
41,"The AbstractList class in Java is a part of the Java Collection Framework and implements the Collection interface and the AbstractCollection class. It is used to implement an unmodifiable list, for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.Class Hierarchy:Syntax:Constructors in Java AbstractList:Below is the sample program to illustrate AbstractList in Java:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate AbstractList  importjava.util.*;  publicclassAbstractListDemo {     publicstaticvoidmain(String args[])     {          // Creating an empty AbstractList         AbstractList<String> list = newLinkedList<String>();          // Use add() method to add elements in the list         list.add(""Geeks"");         list.add(""for"");         list.add(""Geeks"");         list.add(""10"");         list.add(""20"");          // Displaying the AbstractList         System.out.println(""AbstractList:""+ list);     } } Methods in Java AbstractList:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate // methods of AbstractCollection  importjava.util.*;  publicclassAbstractListDemo {     publicstaticvoidmain(String args[])     {          // Creating an empty AbstractList         AbstractList<String>             list = newLinkedList<String>();          // Using add() method to add elements in the list         list.add(""Geeks"");         list.add(""for"");         list.add(""Geeks"");         list.add(""10"");         list.add(""20"");          // Output the list         System.out.println(""AbstractList: ""+ list);          // Remove the head using remove()         list.remove(3);          // Print the final list         System.out.println(""Final AbstractList: ""+ list);          // getting the index of last occurence         // using lastIndexOf() method         intlastindex = list.lastIndexOf(""A"");          // printing the Index         System.out.println(""Last index of A : ""                           + lastindex);     } } Reference: https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.htmlGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
42,"Given a stream containing some elements, the task is to find the duplicate elements in this stream in Java.Examples:
Input: Stream = {5, 13, 4, 21, 13, 27, 2, 59, 59, 34}
Output: [59, 13]
Explanation:
The only duplicate elements in the given stream are 59 and 13.Input: Stream = {5, 13, 4, 21, 27, 2, 59, 34}
Output: []
Explanation:
There are no duplicate elements in the given stream, hence the output is empty.
There are many methods to find duplicate elements in a Stream:Approach:Below is the implementation of the above approach:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to find the duplicate // elements in a Stream using Set  importjava.util.*; importjava.util.stream.*;  publicclassGfG {      // Function to find the     // duplicates in a Stream     publicstatic<T> Set<T>     findDuplicateInStream(Stream<T> stream)     {          // Set to store the duplicate elements         Set<T> items = newHashSet<>();          // Return the set of duplicate elements         returnstream              // Set.add() returns false             // if the element was             // already present in the set.             // Hence filter such elements             .filter(n -> !items.add(n))              // Collect duplicate elements             // in the set             .collect(Collectors.toSet());     }      // Driver code     publicstaticvoidmain(String[] args)     {          // Initial stream         Stream<Integer> stream             = Stream.of(5, 13, 4,                         21, 13, 27,                         2, 59, 59, 34);          // Print the found duplicate elements         System.out.println(             findDuplicateInStream(stream));     } } Approach:Below is the implementation of the above approach:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to find the duplicate // elements in a Stream using Collectors.groupingBy()  importjava.util.*; importjava.util.stream.*; importjava.util.function.Function;  publicclassGfG {      // Function to find the     // duplicates in a Stream     publicstatic<T> Set<T>     findDuplicateInStream(Stream<T> stream)     {          // Return the set of duplicate elements         returnstream              // Group the elements along             // with their frequency in a map             .collect(                 Collectors.groupingBy(                     Function.identity(),                     Collectors.counting()))              // Convert this map into a stream             .entrySet()             .stream()              // Check if frequency > 1             // for duplicate elements             .filter(m -> m.getValue() > 1)              // Find such elements             .map(Map.Entry::getKey)              // And Collect them in a Set             .collect(Collectors.toSet());     }      // Driver code     publicstaticvoidmain(String[] args)     {          // Initial stream         Stream<Integer> stream             = Stream.of(5, 13, 4,                         21, 13, 27,                         2, 59, 59, 34);          // Print the found duplicate elements         System.out.println(             findDuplicateInStream(stream));     } } Approach:Below is the implementation of the above approach:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to find the duplicate // elements in a Stream // using Collections.frequency()  importjava.util.*; importjava.util.stream.*;  publicclassGfG {      // Function to find the     // duplicates in a Stream     publicstatic<T> Set<T>     findDuplicateInStream(List<T> list)     {         // Return the set of duplicate elements         return             // Get the stream from the list             list.stream()                  // Count the frequency of each element                 // and filter the elements                 // with frequency > 1                 .filter(i -> Collections.frequency(list, i) > 1)                  // And Collect them in a Set                 .collect(Collectors.toSet());     }      // Driver code     publicstaticvoidmain(String[] args)     {          // Initial stream         List<Integer> list             = Arrays.asList(5, 13, 4,                             21, 13, 27,                             2, 59, 59, 34);          // Print the found duplicate elements         System.out.println(             findDuplicateInStream(list));     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
43,"Given a TreeMap, the task is to iterate this TreeMap in Java.The TreeMap in Java is used to implement Map interface and NavigableMap along with the Abstract Class. We cannot iterate a TreeMap directly using iterators, because TreeMap is not a Collection.So we will have to use TreeMap.entrySet() method. This method returns a collection-view(Set<Map.Entry>) of the mappings contained in this treemap. So we can iterate over key-value pair using getKey() and getValue() methods of Map.Entry. This method is most common and should be used if you need both map keys and values in the loop. Below is the Java program to demonstrate it.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to iterate over a TreeMap  importjava.util.Map; importjava.util.TreeMap;  classIterationDemo {     publicstaticvoidmain(String[] arg)     {         Map<String, String> gfg             = newTreeMap<String, String>();          // enter name/url pair         gfg.put(""GFG"", ""geeksforgeeks.org"");         gfg.put(""Practice"", ""practice.geeksforgeeks.org"");         gfg.put(""Code"", ""code.geeksforgeeks.org"");         gfg.put(""Quiz"", ""quiz.geeksforgeeks.org"");          // using for-each loop for         // iteration over TreeMap.entrySet()         for(Map.Entry<String, String>                  entry : gfg.entrySet())             System.out.println(                 ""[""+ entry.getKey()                 + "", ""+ entry.getValue() + ""]"");     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
44,"The meaning of platform-independent is that the java compiled code(byte code) can run on all operating systems.
A program is written in a language that is a human-readable language. It may contain words, phrases, etc which the machine does not understand. For the source code to be understood by the machine, it needs to be in a language understood by machines, typically a machine-level language. So, here comes the role of a compiler. The compiler converts the high-level language (human language) into a format understood by the machines. Therefore, a compiler is a program that translates the source code for another program from a programming language into executable code.
This executable code may be a sequence of machine instructions that can be executed by the CPU directly, or it may be an intermediate representation that is interpreted by a virtual machine. This intermediate representation in Java is the Java Byte Code. Step by step Execution of Java Program: .
 
In case of C or C++ (language that are not platform independent), the compiler generates an .exe file which is OS dependent. When we try to run this .exe file on another OS it does not run, since it is OS dependent and hence is not compatible with the other OS.Java is platform-independent but JVM is platform dependentIn Java, the main point here is that the JVM depends on the operating system – so if you are running Mac OS X you will have a different JVM than if you are running Windows or some other operating system. This fact can be verified by trying to download the JVM for your particular machine – when trying to download it, you will be given a list of JVMs corresponding to different operating systems, and you will obviously pick whichever JVM is targeted for the operating system that you are running. So we can conclude that JVM is platform-dependent and it is the reason why Java is able to become “Platform Independent”.
Important Points: This article is contributed by Sania Parween. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
45,"Java provides a rich set of modifiers. They are used to control access mechanism and also provide information about class functionalities to JVM. They are divided into two categories : –How they work?public: When a member of a class is modified by public, then that member can be accessed by any other code.
private: When a member of a class is specified as private, then that member can only be accessed by other members of its class.
Now you can understand why main( ) has always been preceded by the public modifier. It is called by code that is outside the program—that is, by the Java run-time system. When no access modifier is used, then by default the member of a class is public within its own package, but cannot be accessed outside of its package. protected applies only when inheritance is involved.Detailed article : Access Modifiers in JavaThis article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
46,"Function Currying is a concept of breaking a function with many arguments into many functions with single argument in such a way, that the output is same. In other words, its a technique of simplifying a multi-valued argument function into single-valued argument multi-functions.Consider the example to clear the concept: Currying breaks down higher order functions into a series of smaller cascaded functions which take in one argument and return a function except for the last cascaded function which returns the desired value.For example:Let there be a function which maps as
Currying the above function will produce
Thus  maps from  to a function which in turn maps from  to 
The above mathematical expression can also be represented as:
Hence, Below are some examples in Java to demonstrate Function Currying:Example 1: Adding 2 numbers using Function Currying                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java Program to demonstrate Function Currying  importjava.util.function.Function;  publicclassGFG {     publicstaticvoidmain(String args[])     {          // Using Java 8 Functions         // to create lambda expressions for functions         // and with this, applying Function Currying          // Curried Function for Adding u & v         Function<Integer,                  Function<Integer, Integer> >             curryAdder = u -> v -> u + v;          // Calling the curried functions          // Calling Curried Function for Adding u & v         System.out.println(""Add 2, 3 :""                           + curryAdder                                  .apply(2)                                  .apply(3));          } } Example 2: Multiplying 2 numbers using Function Currying                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java Program to demonstrate Function Currying  importjava.util.function.Function;  publicclassGFG {     publicstaticvoidmain(String args[])     {          // Using Java 8 Functions         // to create lambda expressions for functions         // and with this, applying Function Currying          // Curried Function for Multiplying u & v         Function<Integer,                  Function<Integer, Integer> >             curryMulti = u -> v -> u * v;          // Calling the curried functions                 // Calling Curried Function for Multiplying u & v         System.out.println(""Multiply 2, 3 :""                           + curryMulti                                  .apply(2)                                  .apply(3));     } } Example 3: Adding 3 numbers using Function Currying                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java Program to demonstrate Function Currying  importjava.util.function.Function;  publicclassGFG {     publicstaticvoidmain(String args[])     {          // Using Java 8 Functions         // to create lambda expressions for functions         // and with this, applying Function Currying          // Curried Function for Adding u, v & w         Function<Integer,                  Function<Integer,                           Function<Integer, Integer> > >             triadder = u -> w -> v -> u + w + v;          // Calling the curried functions          // Calling Curried Function for Adding u, v & w         System.out.println(""Add 2, 3, 4 :""                           + triadder                                  .apply(2)                                  .apply(3)                                  .apply(4));     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
47,"Core Java: Core Java is the part of Java programming language that is used for creating or developing a general-purpose application.Advanced Java: Advanced Java is also a part of Java programming language that generally deals with online application like the website and mobile application.

Below is the difference between the two:GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
48,"transient is a variables modifier used in serialization. At the time of serialization, if we don’t want to save value of a particular variable in a file, then we use transient keyword. When JVM comes across transient keyword, it ignores original value of the variable and save default value of that variable data type.transient keyword plays an important role to meet security constraints. There are various real-life examples where we don’t want to save private data in file. Another use of transient keyword is not to serialize the variable whose value can be calculated/derived using other serialized objects or system such as age of a person, current date, etc.
Practically we  serialized only those fields which represent a state of instance, after all serialization is all about to save state of an object to a file. It is good habit to use transient keyword with private confidential fields of a class during serialization.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A sample class that uses transient keyword to // skip their serialization. classTest implementsSerializable {     // Making password transient for security     privatetransientString password;      // Making age transient as age is auto-     // computable from DOB and current date.     transientintage;      // serialize other fields     privateString username, email;     Date dob;      // other code } transient and static :  Since static fields are not part of state of the object, there is no use/impact of using transient keyword with static variables. However there is no compilation error.transient and final :  final variables are directly serialized by their values, so there is no use/impact of declaring final variable as transient. There is no compile-time error though.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate transient keyword // Filename Test.java importjava.io.*; classTest implementsSerializable {     // Normal variables     inti = 10, j = 20;      // Transient variables     transientintk = 30;      // Use of transient has no impact here     transientstaticintl = 40;     transientfinalintm = 50;      publicstaticvoidmain(String[] args) throwsException     {         Test input = newTest();          // serialization         FileOutputStream fos = newFileOutputStream(""abc.txt"");         ObjectOutputStream oos = newObjectOutputStream(fos);         oos.writeObject(input);          // de-serialization         FileInputStream fis = newFileInputStream(""abc.txt"");         ObjectInputStream ois = newObjectInputStream(fis);         Test output = (Test)ois.readObject();         System.out.println(""i = ""+ output.i);         System.out.println(""j = ""+ output.j);         System.out.println(""k = ""+ output.k);         System.out.println(""l = ""+ output.l);           System.out.println(""m = ""+ output.m);     } } Output : This article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
49,"Using Java in competitive programming is not something many people would suggest just because of its slow input and output, and well indeed it is slow.In this article, we have discussed some ways to get around the difficulty and change the verdict from TLE to (in most cases) AC.For all the Programs below
Input:Output:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Working program using Scanner importjava.io.BufferedReader; importjava.io.InputStreamReader; importjava.util.Scanner; publicclassMain {     publicstaticvoidmain(String[] args)     {         Scanner s = newScanner(System.in);         intn = s.nextInt();         intk = s.nextInt();         intcount = 0;         while(n-- > 0)         {             intx = s.nextInt();             if(x%k == 0)                count++;         }          System.out.println(count);     } }                                      edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Working program using BufferedReader importjava.io.BufferedReader; importjava.io.IOException; importjava.io.InputStreamReader; importjava.util.StringTokenizer;  publicclassMain {     publicstaticvoidmain(String[] args) throwsIOException     {          BufferedReader br = newBufferedReader(                               newInputStreamReader(System.in));          StringTokenizer st = newStringTokenizer(br.readLine());         intn = Integer.parseInt(st.nextToken());         intk = Integer.parseInt(st.nextToken());         intcount = 0;         while(n-- > 0)         {             intx = Integer.parseInt(br.readLine());             if(x%k == 0)                count++;         }         System.out.println(count);     } }                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Working program with FastReader importjava.io.BufferedReader; importjava.io.IOException; importjava.io.InputStreamReader; importjava.util.Scanner; importjava.util.StringTokenizer;  publicclassMain {     staticclassFastReader     {         BufferedReader br;         StringTokenizer st;          publicFastReader()         {             br = newBufferedReader(new                     InputStreamReader(System.in));         }          String next()         {             while(st == null|| !st.hasMoreElements())             {                 try                {                     st = newStringTokenizer(br.readLine());                 }                 catch(IOException  e)                 {                     e.printStackTrace();                 }             }             returnst.nextToken();         }          intnextInt()         {             returnInteger.parseInt(next());         }          longnextLong()         {             returnLong.parseLong(next());         }          doublenextDouble()         {             returnDouble.parseDouble(next());         }          String nextLine()         {             String str = """";             try            {                 str = br.readLine();             }             catch(IOException e)             {                 e.printStackTrace();             }             returnstr;         }     }      publicstaticvoidmain(String[] args)     {         FastReader s=newFastReader();         intn = s.nextInt();         intk = s.nextInt();         intcount = 0;         while(n-- > 0)         {             intx = s.nextInt();             if(x%k == 0)                count++;         }         System.out.println(count);     } }  This gets accepted with a surprising time of just 0.28 s. Although this is ultra fast, it is clearly not an easy method to remember.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Working program using Reader Class importjava.io.DataInputStream; importjava.io.FileInputStream; importjava.io.IOException; importjava.io.InputStreamReader; importjava.util.Scanner; importjava.util.StringTokenizer;  publicclassMain {     staticclassReader     {         finalprivateintBUFFER_SIZE = 1<< 16;         privateDataInputStream din;         privatebyte[] buffer;         privateintbufferPointer, bytesRead;          publicReader()         {             din = newDataInputStream(System.in);             buffer = newbyte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }          publicReader(String file_name) throwsIOException         {             din = newDataInputStream(newFileInputStream(file_name));             buffer = newbyte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }          publicString readLine() throwsIOException         {             byte[] buf = newbyte[64]; // line length             intcnt = 0, c;             while((c = read()) != -1)             {                 if(c == '\n')                     break;                 buf[cnt++] = (byte) c;             }             returnnewString(buf, 0, cnt);         }          publicintnextInt() throwsIOException         {             intret = 0;             bytec = read();             while(c <= ' ')                 c = read();             booleanneg = (c == '-');             if(neg)                 c = read();             do            {                 ret = ret * 10+ c - '0';             }  while((c = read()) >= '0'&& c <= '9');              if(neg)                 return-ret;             returnret;         }          publiclongnextLong() throwsIOException         {             longret = 0;             bytec = read();             while(c <= ' ')                 c = read();             booleanneg = (c == '-');             if(neg)                 c = read();             do{                 ret = ret * 10+ c - '0';             }             while((c = read()) >= '0'&& c <= '9');             if(neg)                 return-ret;             returnret;         }          publicdoublenextDouble() throwsIOException         {             doubleret = 0, div = 1;             bytec = read();             while(c <= ' ')                 c = read();             booleanneg = (c == '-');             if(neg)                 c = read();              do{                 ret = ret * 10+ c - '0';             }             while((c = read()) >= '0'&& c <= '9');              if(c == '.')             {                 while((c = read()) >= '0'&& c <= '9')                 {                     ret += (c - '0') / (div *= 10);                 }             }              if(neg)                 return-ret;             returnret;         }          privatevoidfillBuffer() throwsIOException         {             bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);             if(bytesRead == -1)                 buffer[0] = -1;         }          privatebyteread() throwsIOException         {             if(bufferPointer == bytesRead)                 fillBuffer();             returnbuffer[bufferPointer++];         }          publicvoidclose() throwsIOException         {             if(din == null)                 return;             din.close();         }     }      publicstaticvoidmain(String[] args) throwsIOException     {         Reader s=newReader();         intn = s.nextInt();         intk = s.nextInt();         intcount=0;         while(n-- > 0)         {             intx = s.nextInt();             if(x%k == 0)                count++;         }         System.out.println(count);     } } Suggested Read:  Enormous Input Test  designed to check the fast input handling of your language.Timings of all programs are noted from SPOJ.
This article is contributed by Rishabh Mahrsee. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above",java
50,"JAVA DEVELOPMENT KITThe Java Development Kit (JDK) is a software development environment used for developing Java applications and applets. It includes the Java Runtime Environment (JRE), an interpreter/loader (Java), a compiler (javac), an archiver (jar), a documentation generator (Javadoc) and other tools needed in Java development.JAVA RUNTIME ENVIRONMENTJRE stands for “Java Runtime Environment” and may also be written as “Java RTE.” The Java Runtime Environment provides the minimum requirements for executing a Java application; it consists of the Java Virtual Machine (JVM), core classes, and supporting files.JAVA VIRTUAL MACHINEIt is:Difference betweem JDK, JRE and JVMTo understand the difference between these three, let us consider the following diagram.
Note :  JDK is only used by Java Developers.How does JRE and JDK works?What does JRE consists of?
JRE consists of the following components:How does JRE works?
To understand how the JRE works let us consider a Java source file saved as Example.java. The file is compiled into a set of Byte Code that is stored in a “.class” file. Here it will be “Example.class“.


The following diagram depicts what is done at compile time.

The following actions occur at runtime.The Class Loader loads all necessary classes needed for the execution of a program. It provides security by separating the namespaces of the local file system from that imported through the network. These files are loaded either from a hard disk, a network or from other sources.The JVM puts the code through the Byte Code Verifier that checks the format and checks for an illegal code. Illegal code, for example, is code that violates access rights on objects or violates the implementation of pointers.The Byte Code verifier ensures that the code adheres to the JVM specification and does not violate system integrity.
At runtime the Byte Code is loaded, checked and run by the interpreter. The interpreter has the following two functions:Both operations can be shown as:

To understand the interactions between JDK and JRE consider the following diagram.

How does JVM works?JVM becomes an instance of JRE at runtime of a Java program. It is widely known as a runtime interpreter.JVM largely helps in the abstraction of inner implementation from the programmers who make use of libraries for their programmes from JDK.
For detailed working of JVM click ->Working of JVM

Image Sources:
This article is contributed by Krishna Bhatia. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
51,"Given a string str of some specific length, the task is to pad this string with the given character ch, inorder to make the string of length L.Note: Padding has to be done in all three formats: Left Padding, Right Padding and Center Padding.Example:
Input: str = “Geeksforgeeks”, ch =’-‘, L = 20
Output:
Left Padding: ————GeeksForGeeks
Center Padding: ——GeeksForGeeks——
Right Padding: GeeksForGeeks————Input: str = “GfG”, ch =’#’, L = 5
Output:
Left Padding: ##GfG
Center Padding: #GfG#
Right Padding: GfG##
There are many methods to pad a String:Note: This method can be used to do only left and right padding.Approach:Below is the implementation of the above approach:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java implementation to pad a String  importjava.lang.*; importjava.io.*;  publicclassGFG {      // Function to perform left padding     publicstaticString     leftPadding(String input, charch, intL)     {          String result             = String                    // First left pad the string                   // with space up to length L                   .format(""%""+ L + ""s"", input)                    // Then replace all the spaces                   // with the given character ch                   .replace(' ', ch);          // Return the resultant string         returnresult;     }      // Function to perform right padding     publicstaticString     rightPadding(String input, charch, intL)     {          String result             = String                    // First right pad the string                   // with space up to length L                   .format(""%""+ (-L) + ""s"", input)                    // Then replace all the spaces                   // with the given character ch                   .replace(' ', ch);          // Return the resultant string         returnresult;     }      // Driver code     publicstaticvoidmain(String[] args)     {          String str = ""GeeksForGeeks"";         charch = '-';         intL = 20;          System.out.println(             leftPadding(str, ch, L));         System.out.println(             rightPadding(str, ch, L));     } } Note: This module has to be installed before running of the code. Hence this code won’t run on Online compilers.Approach:Below is the implementation of the above approach:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java implementation to pad a String  importjava.lang.*; importjava.io.*;  publicclassGFG {      // Function to perform left padding     publicstaticString     leftPadding(String input, charch, intL)     {          // Left pad the string         String result             = StringUtils.leftPad(str, L, ch);          // Return the resultant string         returnresult;     }      // Function to perform center padding     publicstaticString     centerPadding(String input, charch, intL)     {          // Center pad the string         String result             = StringUtils.center(str, L, ch);          // Return the resultant string         returnresult;     }      // Function to perform right padding     publicstaticString     rightPadding(String input, charch, intL)     {          // Right pad the string         String result             = StringUtils.rightPad(str, L, ch);          // Return the resultant string         returnresult;     }      // Driver code     publicstaticvoidmain(String[] args)     {          String str = ""GeeksForGeeks"";         charch = '-';         intL = 20;          System.out.println(             leftPadding(str, ch, L));         System.out.println(             centerPadding(str, ch, L));         System.out.println(             rightPadding(str, ch, L));     } } GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
52,"The AbstractSet class in Java is a part of the Java Collection Framework which implements the Collection interface and extends the AbstractCollection class. It provides a skeletal implementation of the Set interface. This class does not override any of the implementations from the AbstractCollection class, but merely adds implementations for equals() and hashCode() method.Class Hierarchy:Syntax:Constructors in Java AbstractSet:Below is a sample program to illustrate the java AbstractSet:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate AbstractSet  importjava.util.*;  publicclassGFG1 {     publicstaticvoidmain(String[] args) throwsException     {          try{              // Creating object of AbstractSet<Integer>             AbstractSet<Integer>                 abs_set = newTreeSet<Integer>();              // Populating abs_set             abs_set.add(1);             abs_set.add(2);             abs_set.add(3);             abs_set.add(4);             abs_set.add(5);              // print abs_set             System.out.println(""AbstractSet: ""                               + abs_set);         }         catch(Exception e) {             System.out.println(e);         }     } } Methods in Java AbstractSet:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate // methods of AbstractSet  importjava.util.*;  publicclassGFG1 {     publicstaticvoidmain(String[] args) throwsException     {          try{              // Creating object of AbstractSet<Integer>             AbstractSet<Integer>                 abs_set = newTreeSet<Integer>();              // Populating abs_set             abs_set.add(1);             abs_set.add(2);             abs_set.add(3);             abs_set.add(4);             abs_set.add(5);              // print abs_set             System.out.println(""AbstractSet before ""                               + ""removeAll() operation : ""                               + abs_set);              // Creating another object of ArrayList<Integer>             Collection<Integer>                 arrlist2 = newArrayList<Integer>();             arrlist2.add(1);             arrlist2.add(2);             arrlist2.add(3);              // print arrlist2             System.out.println(""Collection Elements""                               + "" to be removed : ""                               + arrlist2);              // Removing elements from AbstractSet             // specified in arrlist2             // using removeAll() method             abs_set.removeAll(arrlist2);              // print arrlist1             System.out.println(""AbstractSet after ""                               + ""removeAll() operation : ""                               + abs_set);         }          catch(NullPointerException e) {             System.out.println(""Exception thrown : ""+ e);         }     } } Reference: https://docs.oracle.com/javase/7/docs/api/java/util/AbstractSet.htmlGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
53,"The first lecture note given during java class is “In java file name and class name should be the same”.  When the above law is violated a compiler error message will appear as below                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                /***** File name: Trial.java ******/publicclassGeeks {     publicstaticvoidmain(String[] args)     {         System.out.println(""Hello world"");     } }Output:But the myth can be violated in such a way to compile the above file.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                /***** File name: Trial.java ******/classGeeks {     publicstaticvoidmain(String[] args)     {         System.out.println(""Hello world"");     } } Step 1:Step 1 will create a Geeks.class (byte code) without any error message since the class is not public.Step 2:Now the output will be Hello worldThe myth about the file name and class name should be same only when the class is declared in public.The above program works as follows:
Now, this .class file can be executed. By the above features, some more miracles can be done. It is possible to have many classes in a java file. For debugging purposes, this approach can be used. Each class can be executed separately to test their functionalities(only on one condition: Inheritance concept should not be used).
But in general, it is good to follow the myth.Example 1:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                /*** File name: Trial.java ***/classForGeeks {     publicstaticvoidmain(String[] args)     {         System.out.println(""For Geeks class"");     } }  classGeeksTest {     publicstaticvoidmain(String[] args)     {         System.out.println(""Geeks Test class"");     } } When the above file is compiled as javac Trial.java  this will create 2 .class files as ForGeeks.class and GeeksTest.class .
Since each class has separate main() stub they can be tested individually. Example 2:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Program to find area of triangle classTriangle {     intx, y;     voidprintArea()     {         System.out.println(""Area of triangle is: ""+ x * y / 2);     } }  classDemo {     publicstaticvoidmain(String args[])     {         // Object creation         Triangle t = newTriangle();         t.x = 10;         t.y = 13;         t.printArea();     } } Note: There are two classes here, Triangle and Demo. Then which class name must be considered as the file name?
The class name Demo must be taken as the file name. The reason behind taking Demo as the file name is that it has the main method and execution begins from the main method.This article is contributed by Sowmya.L.R. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
54,"ArrayList is a part of collection framework and is present in java.util package. It provides us dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed.Now primarily the Java ArrayList can constitute of both Constructors and Methods. Below mentioned is a list of few constructors and methods along with there use and functions.Constructors in Java ArrayList:Let us look at the code to create generic ArrayList-                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of ArrayList in Java importjava.io.*; importjava.util.*;  classarrayli {     publicstaticvoidmain(String[] args)                        throwsIOException     {         // size of ArrayList         intn = 5;          //declaring ArrayList with initial size n         ArrayList<Integer> arrli = newArrayList<Integer>(n);          // Appending the new element at the end of the list         for(inti=1; i<=n; i++)             arrli.add(i);          // Printing elements         System.out.println(arrli);          // Remove element at index 3         arrli.remove(3);          // Displaying ArrayList after deletion         System.out.println(arrli);          // Printing elements one by one         for(inti=0; i<arrli.size(); i++)             System.out.print(arrli.get(i)+"" "");     } } Output:Methods in Java ArrayList:Also see – Array vs ArrayList in JavaThis article is contributed by Bharat Sahni. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
55,"Shutdown Hooks are a special construct that allows developers to plug in a piece of code to be executed when the JVM is shutting down. This comes in handy in cases where we need to do special clean up operations in case the VM is shutting down.Handling this using the general constructs such as making sure that we call a special procedure before the application exits (calling System.exit(0) ) will not work for situations where the VM is shutting down due to an external reason (ex. kill request from O/S), or due to a resource problem (out of memory). As we will see soon, shutdown hooks solve this problem easily, by allowing us to provide an arbitrary code block, which will be called by the JVM when it is shutting down.From the surface, using a shutdown hook is downright straight forward. All we have to do is simply write a class which extends the java.lang.Thread class, and provide the logic that we want to perform when the VM is shutting down, inside the public void run() method.  Then we register an instance of this class as a shutdown hook to the VM by calling Runtime.getRuntime().addShutdownHook(Thread) method. If you need to remove a previously registered shutdown hook, the Runtime class provides the removeShutdownHook(Thread) method as well.For Example :                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                publicclassShutDownHook {   publicstaticvoidmain(String[] args)   {      Runtime.getRuntime().addShutdownHook(newThread()     {       publicvoidrun()       {         System.out.println(""Shutdown Hook is running !"");       }     });     System.out.println(""Application Terminating ..."");   } } When we run the above code, you will see that the shutdown hook is getting called by the JVM when it finishes execution of the main method.Output:Simple right? Yes it is.While it is pretty simple to write a shutdown hook, one needs to know the internals behind the shutdown hooks to make use of those properly. Therefore, in this article, we will be exploring some of the ‘gotchas’ behind the shutdown hook design.1. Shutdown Hooks may not be executed in some cases!
The first thing to keep in mind is that it is not guaranteed that shutdown hooks will always run. If the JVM crashes due to some internal error, then it might crash down without having a chance to execute a single instruction. Also, if the O/S gives a SIGKILL (http://en.wikipedia.org/wiki/SIGKILL) signal (kill -9 in Unix/Linux) or TerminateProcess (Windows), then the application is required to terminate immediately without doing even waiting for any cleanup activities. In addition to the above, it is also possible to terminate the JVM without allowing the shutdown hooks to run by calling Runtime.halt() method.Shutdown hooks are called when the application terminates normally (when all threads finish, or when System.exit(0) is called). Also, when the JVM is shutting down due to external causes such as a user requesting a termination (Ctrl+C), a SIGTERM being issued by O/S (normal kill command, without -9), or when the operating system is shutting down.2. Once started, Shutdown Hooks can be forcibly stopped before completion.
This is actually a special case of the case explained before. Although the hook starts execution, it is possible to be terminated before it completes, in cases such as operating system shutdowns. In this type of cases, the O/S waits for a process to terminate for a specified amount of time once the SIGTERM is given. If the process does not terminate within this time limit, then the O/S terminates the process forcibly by issuing a SIGTERM (or the counterparts in Windows). So it is possible that this happens when the shutdown hook is half-way through its execution.Therefore, it is advised to make sure that the Shutdown Hooks are written cautiously, ensuring that they finish quickly, and do not cause situations such as deadlocks. Also, the JavaDoc [1] specifically mentions that one should not perform long calculations or wait for User I/O operations in a shutdown hook.3. We can have more than one Shutdown Hooks, but their execution order is not guaranteed.
As you might have correctly guessed by the method name of the addShutdownHook method (instead of setShutdownHook), you can register more than one shutdown hook. But the execution order of these multiple hooks is not guaranteed by the JVM. The JVM can execute shutdown hooks in any arbitrary order. Moreover, the JVM might execute all these hooks concurrently.4.  We cannot register/unregister Shutdown Hooks within Shutdown Hooks
Once the shutdown sequence is initiated by the JVM, it is not allowed to add more or remove any existing shutdown hooks. If this is attempted, the JVM throws IllegalStateException.5. Once shutdown sequence starts, it can be stopped by Runtime.halt() only.
Once the shutdown sequence starts, only Runtime.halt() (which forcefully terminates the JVM) can stop the execution of the shutdown sequence (except for external influences such as SIGKILL). This means that calling System.exit() within a Shutdown Hook will not work. Actually, if you call System.exit() within a Shutdown Hook, the VM may get stuck, and we may have to terminate the process forcefully.6.  Using shutdown hooks require security permissions.
If we are using Java Security Managers, then the code which performs adding/removing of shutdown hooks need to have the shutdownHooks permission at runtime. If we invoke this method without permission in a secure environment, then it will result in SecurityException.References : 
http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/Runtime.html#addShutdownHook(java.lang.Thread)This article is contributed by Saket Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
56,"Enumerations serve the purpose of representing a group of named constants in a programming language. For example the 4 suits in a deck of playing cards may be 4 enumerators named Club, Diamond, Heart, and Spade, belonging to an enumerated type named Suit. Other examples  include natural enumerated types (like the planets, days of the week, colors, directions, etc.).
Enums are used when we know all possible values at compile time, such as choices on a menu, rounding modes, command line flags, etc. It is not necessary that the set of constants in an enum type stay fixed for all time.In Java (from 1.5), enums are represented using enum data type. Java enums are more powerful than C/C++ enums . In Java, we can also add variables, methods and constructors to it. The main objective of enum is to define our own data types(Enumerated Data Types).Declaration of enum in java :                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A simple enum example where enum is declared // outside any class (Note enum keyword instead of // class keyword) enumColor {     RED, GREEN, BLUE; }  publicclassTest {     // Driver method     publicstaticvoidmain(String[] args)     {         Color c1 = Color.RED;         System.out.println(c1);     } }Output :                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // enum declaration inside a class. publicclassTest {     enumColor     {         RED, GREEN, BLUE;     }      // Driver method     publicstaticvoidmain(String[] args)     {         Color c1 = Color.RED;         System.out.println(c1);     } }Output : Important points of enum :                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to demonstrate working on enum // in switch case (Filename Test. Java) importjava.util.Scanner;  // An Enum class enumDay {     SUNDAY, MONDAY, TUESDAY, WEDNESDAY,     THURSDAY, FRIDAY, SATURDAY; }  // Driver class that contains an object of ""day"" and // main(). publicclassTest {     Day day;      // Constructor     publicTest(Day day)     {         this.day = day;     }      // Prints a line about Day using switch     publicvoiddayIsLike()     {         switch(day)         {         caseMONDAY:             System.out.println(""Mondays are bad."");             break;         caseFRIDAY:             System.out.println(""Fridays are better."");             break;         caseSATURDAY:         caseSUNDAY:             System.out.println(""Weekends are best."");             break;         default:             System.out.println(""Midweek days are so-so."");             break;         }     }      // Driver method     publicstaticvoidmain(String[] args)     {         String str = ""MONDAY"";         Test t1 = newTest(Day.valueOf(str));         t1.dayIsLike();     } } Output:                                     edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // A Java program to demonstrate that we can have // main() inside enum class. enumColor {     RED, GREEN, BLUE;      // Driver method     publicstaticvoidmain(String[] args)     {         Color c1 = Color.RED;         System.out.println(c1);     } } Output : Enum and Inheritance :values(), ordinal() and valueOf() methods :                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate working of values(), // ordinal() and valueOf() enumColor {     RED, GREEN, BLUE; }  publicclassTest {     publicstaticvoidmain(String[] args)     {         // Calling values()         Color arr[] = Color.values();          // enum with loop         for(Color col : arr)         {             // Calling ordinal() to find index             // of color.             System.out.println(col + "" at index ""                             + col.ordinal());         }          // Using valueOf(). Returns an object of         // Color with given constant.         // Uncommenting second line causes exception         // IllegalArgumentException         System.out.println(Color.valueOf(""RED""));         // System.out.println(Color.valueOf(""WHITE""));     } } Output : enum and constructor :enum and methods :                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to demonstrate that enums can have constructor // and concrete methods.  // An enum (Note enum keyword inplace of class keyword) enumColor {     RED, GREEN, BLUE;      // enum constructor called separately for each     // constant     privateColor()     {         System.out.println(""Constructor called for : ""+         this.toString());     }      publicvoidcolorInfo()     {         System.out.println(""Universal Color"");     } }  publicclassTest {         // Driver method     publicstaticvoidmain(String[] args)     {         Color c1 = Color.RED;         System.out.println(c1);         c1.colorInfo();     } } Output:Next Article on enum:
Enum with Customized Value in JavaThis article is contributed by Gaurav Miglani. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
57,"Data Abstraction is the property by virtue of which only the essential details are displayed to the user.The trivial or the non-essentials units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.Data Abstraction may also be defined as the process of identifying only the required characteristics of an object ignoring the irrelevant details.The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the objects.Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of car or applying brakes will stop the car but he does not know about how on pressing the accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is. In java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.Abstract classes and Abstract methods : When to use abstract classes and abstract methods with an exampleThere are situations in which we will want to define a superclass that declares the structure of a given abstraction without providing a complete implementation of every method. That is, sometimes we will want to create a superclass that only defines a generalization form that will be shared by all of its subclasses, leaving it to each subclass to fill in the details.Consider a classic “shape” example, perhaps used in a computer-aided design system or game simulation. The base type is “shape” and each shape has a color, size and so on. From this, specific types of shapes are derived(inherited)-circle, square, triangle and so on – each of which may have additional characteristics and behaviors. For example, certain shapes can be flipped. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java program to illustrate the // concept of Abstraction abstractclassShape  {     String color;          // these are abstract methods     abstractdoublearea();     publicabstractString toString();          // abstract class can have constructor     publicShape(String color) {         System.out.println(""Shape constructor called"");         this.color = color;     }          // this is a concrete method     publicString getColor() {         returncolor;     } } classCircle extendsShape {     doubleradius;          publicCircle(String color,doubleradius) {          // calling Shape constructor         super(color);         System.out.println(""Circle constructor called"");         this.radius = radius;     }      @Override    doublearea() {         returnMath.PI * Math.pow(radius, 2);     }      @Override    publicString toString() {         return""Circle color is ""+ super.color +                         ""and area is : ""+ area();     }      } classRectangle extendsShape{      doublelength;     doublewidth;          publicRectangle(String color,doublelength,doublewidth) {         // calling Shape constructor         super(color);         System.out.println(""Rectangle constructor called"");         this.length = length;         this.width = width;     }          @Override    doublearea() {         returnlength*width;     }      @Override    publicString toString() {         return""Rectangle color is ""+ super.color +                             ""and area is : ""+ area();     }  } publicclassTest  {     publicstaticvoidmain(String[] args)     {         Shape s1 = newCircle(""Red"", 2.2);         Shape s2 = newRectangle(""Yellow"", 2, 4);                  System.out.println(s1.toString());         System.out.println(s2.toString());     } } Output:Encapsulation vs Data Abstraction Advantages of AbstractionRelated articles :GeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
58,"The AbstractSequentialList class in Java is a part of the Java Collection Framework and implements the Collection interface and the AbstractCollection class. It is used to implement an unmodifiable list, for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.Class Hierarchy:Syntax:Constructors in Java AbstractSequentialList:Below is a sample program to illustrate AbstractSequentialList in Java:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate AbstractSequentialList  importjava.util.*;  publicclassGfG {      publicstaticvoidmain(String[] args)     {         // Creating an instance of the AbstractSequentialList         AbstractSequentialList<Integer>             absl = newLinkedList<>();          // adding elements to absl         absl.add(5);         absl.add(6);         absl.add(7);          // Printing the list         System.out.println(absl);     } } Methods in Java AbstractList:Example:                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                // Java code to illustrate // methods of AbstractSequentialList  importjava.util.*; importjava.util.AbstractSequentialList;  publicclassAbstractSequentialListDemo {     publicstaticvoidmain(String args[])     {          // Creating an empty AbstractSequentialList         AbstractSequentialList<String>             absqlist = newLinkedList<String>();          // Using add() method to add elements in the list         absqlist.add(""Geeks"");         absqlist.add(""for"");         absqlist.add(""Geeks"");         absqlist.add(""10"");         absqlist.add(""20"");          // Output the list         System.out.println(""AbstractSequentialList: ""                           + absqlist);          // Remove the head using remove()         absqlist.remove(3);          // Print the final list         System.out.println(""Final List: ""                           + absqlist);          // Fetching the specific element from the list         // using get() method         System.out.println(""The element is: ""                           + absqlist.get(2));     } } Reference: https://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.htmlGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please Improve this article if you find anything incorrect by clicking on  the ""Improve Article"" button below.",java
59,"In Java, if there is a local variable in a method with same name as instance variable, then the local variable hides the instance variable. If we want to reflect the change made over to the instance variable, this can be achieved with the help of this reference.                                    edit
                                    close                                    play_arrow                                    link
                                    brightness_4
                                    code
                                classTest {     // Instance variable or member variable     privateintvalue = 10;       voidmethod()     {         // This local variable hides instance variable         intvalue = 40;          System.out.println(""Value of Instance variable :""                            + this.value);         System.out.println(""Value of Local variable :""                            + value);     } }  classUseTest {     publicstaticvoidmain(String args[])     {         Test obj1 = newTest();         obj1.method();     } } Output:This article is contributed by Twinkle Tyagi. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed aboveGeeksforGeeks has prepared a complete interview preparation course with premium videos, theory, practice problems, TA support and many more features. Please refer Placement 100 for details ",java
