,Blogs,Target
0,"In articles about lambda expression (like this one from last week on my page), it’s easy to show examples where the lambda runs on the same thread as the caller. But how about asynchronous cases? What if your lambda is called on a separate thread? What problems you might encounter there.Read on and let’s explore this topic.Let’s start with std::thread. As you might already know std::thread accepts a callable object in its constructor. It might be a regular function pointer, a functor or a lambda expression. A simple example:std::vector<int> numbers(100);

std::thread iotaThread([&numbers](int startArg) {
    std::iota(numbers.begin(), numbers.end(), startArg);
    std::cout << ""from: "" << std::this_thread::get_id() << "" thread id\n"";
    }, 10
);

iotaThread.join();
std::cout << ""numbers in main (id "" << std::this_thread::get_id() << ""):\n"";
for (auto& num : numbers)
    std::cout << num << "", "";In the above sample, we create a single thread with a lambda expression. The std::thread class has a flexible constructor, thus we can even pass a value for the argument. In our code 10 is passed into the lambda as startArg.The code is simple because we can control the thread execution, and by joining it, we know that the results of the iota will be ready before we print them.The important thing is to remember that while lambdas make it easy and convenient to create a thread, we still have the asynchronous execution. All the issues that you might get with passing a regular function are the same here.This is visible in the following example:int counter = 0;

std::vector<std::thread> threads;
for (int i = 0; i < 5; ++i) {
    threads.push_back(std::thread([&counter]() {
        for (int i = 0; i < 100; ++i) {
            ++counter;
            --counter;
            ++counter;
        }
        }));
}

for (auto& thread : threads) {
    thread.join();
}

std::cout << counter << std::endl;We’re creating five threads, and each thread performs super-advanced computations on the counter variable which is shared among all the threads.While you might expect to see 500 as the final value of counter the result is undefined. During my testing on Visual Studio 2019, I got the following output (running it several times):500
400
403
447To fix the issue, as with regular threading scenarios, we should use some sort of a synchronisation mechanism. For this example, we can use atomics as they seem to be easiest to use and fastest.std::atomic<int> counter = 0;

std::vector<std::thread> threads;
for (int i = 0; i < 5; ++i) {
    threads.push_back(std::thread([&counter]() {
        for (int i = 0; i < 100; ++i) {
            counter.fetch_add(1);
        }
    }));
}

for (auto& thread : threads) {
    thread.join();
}

std::cout << counter.load() << std::endl;The code above works as expected because the increment operation is now atomic. It means that counter will be incremented and other threads won’t interrupt this action. Without any form of synchronisation threads might read the current value of counter at the same time and then increment it, causing the final value to be undefined. The synchronisation makes code safer but at a price of the performance. But it’s another topic for a much longer discussion.As we can see, it’s quite handy to create a thread with a lambda expression. It’s local to your executing thread, and you can do everything like with a regular function or functor object. And now the question to you: Do you use lambdas for threads?It’s quite often that threading code is much complicated than a three or fives lines of lambda code. In that context maybe it’s better to write a separate thread function outside? What do you think? Do you have any rules on that?Let’s now try another technique that is available in C++.A second way that you can leverage multithreading is through std::async.  We got that functionality together with threads in C++11. This is a high-level API that allows you to set up and call computations lazily or fully asynchronously.Let’s convert our example with iota into the async call:std::vector<int> numbers(100);

std::future<void> iotaFuture = std::async(std::launch::async, 
    [&numbers, startArg = 10]() {
        std::iota(numbers.begin(), numbers.end(), startArg);
        std::cout << ""calling from: "" << std::this_thread::get_id() 
                  << "" thread id\n"";
    }
);

iotaFuture.get(); // make sure we get the results...
std::cout << ""numbers in main (id "" << std::this_thread::get_id() << ""):\n"";
for (auto& num : numbers)
    std::cout << num << "", "";This time rather than threads, we rely on the mechanism of std::future. This is an object which handles the synchronisation and guarantees that the results of the invocation are ready.In our case we schedule the execution of the lambda through std::async, and then we need to call .get() to finish the computations. The .get() member function is blocking.However the code above is a bit cheating  as we’re using future<void> and the vector is still passed as the reference captured by lambda. As an alternative you might want to create std::future<std::vector<int>>:std::future<std::vector<int>> iotaFuture = std::async(std::launch::async,         [startArg = 10]() {
        std::vector<int> numbers(100);
        std::iota(numbers.begin(), numbers.end(), startArg);
        std::cout << ""calling from: "" 
                  << std::this_thread::get_id() << "" thread id\n"";
        return numbers;
    }
);

auto vec = iotaFuture.get(); // make sure we get the results...
// ...Let’s make a stop here.While the above code should work, it seems that over the years std::async/std::future got mixed reputation. It looks like the functionality was a bit too rushed. It works for relatively simple cases but fails with advanced scenarios like:I’m not using this framework in production, so I won’t pretend I’m an expert here. If you want to know more, you should read or watch the following resources:You can also have a look at my recent question that I asked on Twitter:Do you use std::async, std::future in your production code? Reading the articles and tutorials I got the impression that over the years it got somehow bad reputation. Or maybe I'm wrong here?#programming #cpp #cpp11After discussing the threading support in C++11, we can move to further standards: C++17. This time you have a super easy-to-use technique that allows you to parallelise most of the algorithms from the Standard Library. All you have to do is to specify the first argument into the algorithm, for example:auto myVec = GenerateVector();
std::sort(std::execution::par, myVec.begin(), myVec.end());We have the following options:For example, we can quickly came up with the following (bad/suspicious) code that performs a copy with a filter:std::vector<int> vec(1000);
std::iota(vec.begin(), vec.end(), 0);
std::vector<int> output;
std::for_each(std::execution::par, vec.begin(), vec.end(),
    [&output](int& elem) {
        if (elem % 2 == 0) {
            output.push_back(elem);
        }
});Do you see all the issues here?We can fix the synchronisation problem by having a mutex and locking it before each push_back. But is that code still efficient? If the filter condition is straightforward and fast to execute, then you might even get slower performance than the serial version.Not to mention is the fact that by running it in parallel, you don’t know the order of the copied elements in the output vector.So while parallel algorithms are relatively easy to use - just pass the first argument, and you get the speed… it’s easy to forget that you’re still working with parallel code and all the safety rules have to be obeyed.Before we finish, it’s also important to mention one more topic: how to capture this pointer.Have a look at the following code:struct User {
    std::string _name;

    auto getNameCallback() {
        return [this](const std::string& b) { 
            return _name + b; 
        };
    }
};

void callbackTest() {
    auto pJohn = std::make_unique<User>(User{ ""John"" });
    auto nameCallback = pJohn->getNameCallback();
    pJohn.reset();

    const auto newName = nameCallback("" is Super!"");
    std::cout << newName << '\n';
}Do you know what happens when we try to call nameCallback() ?...It’s Undefined Behaviour! For example, in my debugging session in Visual Studio, I got an exception.Exception thrown at 0x00007FFC0323A799 in cpptests.exe: Microsoft C++ exception: std::bad_alloc at memory location 0x000000F77DEFEF20.This is because in nameCallback we try to access a member of the User structure. However, since the object of this type was deleted (via pJohn.reset()) then we’re trying to access a deleted memory region.In this case, we can fix our code by using C++17 feature that allows capturing *this as a copy of the instance. That way, even if the original object is destroyed, the lambda will contain a safe copy.One note: the copy is made when you create a lambda object, not at the place where you invoke it! (thanks to the JFT comment below).struct User {
    std::string _name;

    auto getSafeNameCallback() {
        return [*this](const std::string& b) { // *this!
            return _name + b; 
        };
    }
};

void callbackTest() {
    auto pJohn = std::make_unique<User>(User{ ""John"" });
    auto nameCallback = pJohn->getSafeNameCallback();
    pJohn.reset();

    const auto newName = nameCallback("" is Super!"");
    std::cout << newName << '\n';
}Now, after the changes, the code works as expected.Of course, it’s not always possible to change code like that. In many cases, you don’t want a copy. One place where I can see this might be callbacks for UI events. For QT I’ve seen code like this:QPushButton* button = new QPushButton(text);        
connect(button, &QPushButton::clicked, [this]() {
                // do something on ""this""
            }
        );You need to pay attention and make sure the instance of the object is present and still alive.Throughout this blog post, I wanted to make you aware of the potentially harmful situation with captured variables: use after delete and also synchronisation issues.Lambdas make it easy to capture objects from the outside scope and thus you can easily forget to apply a proper synchronisation mechanism on those captured objects, or simply check if the references object is still present. However, if you happen to write a thread code as a separate function, then it’s harder to “capture” variables, and that can make you more aware of the synchronisation issues.One thing to ask is also the readability of the code. If your thread is just several lines of code it’s probably fine, but do you use it for more complex logic? Or you prefer regular functions or functors?You can play with my sample code at @Coliru - as it supports 4 cores for threading (std::thread::hardware_concurrency()).",cpp
1,"[](){}The mixture of brackets in the preceding line become one of the most noticeable indications of Modern C++.  
Yep. 
Lambda Expressions! 
It might sound like I’m trying to create a new blog post about something that everyone knows. Is that true? Do you know all the details of this modern C++ technique?In this article, you’ll learn five advantages of Lambdas. Let’s start.The first point might sound quite obvious, but it’s always good to appreciate the fact that since C++11, we can write more compact code.For example, recently, I stumbled upon some cases of C++03/C++0x with bind expressions and predefined helper functors from the Standard Library.Have a look at the code:#include <algorithm>
#include <functional>
#include <vector>

int main() {
    using std::placeholders::_1;

    const std::vector<int> v { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    const auto val = std::count_if(v.begin(), v.end(),
                               std::bind(std::logical_and<bool>(),
                               std::bind(std::greater<int>(),_1, 2),
                               std::bind(std::less_equal<int>(),_1,6)));

    return val;                                        
}Play with the code @Compiler ExplorerCan you immediately tell what the final value of val is?Let’s now rewrite this into lambda expression:#include <algorithm>
#include <vector>

int main() {
    std::vector<int> v { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    const auto val = std::count_if(v.begin(), v.end(), 
                        [](int v) { return v > 2 && v <= 6;});

    return val;                                        
}Isn’t that better?Play with the code @Compiler ExplorerNot only we have shorter syntax for the anonymous function object, but we could even reduce one include statement (as there’s no need for <functional>any more).In C++03, it was convenient to use predefined helpers to build those callable objects on the fly. They were handy and allowed you even to compose functionalities to get some complex conditions or operations. However, the main issue is the hard-to-learn syntax. You can of course still use them, even with C++17 or C++20 code (and for places where the use of lambdas is not possible), but I guess that their application for complex scenarios is a bit limited now. In most cases, it’s far easier to use lambdas.I bet you can list a lot of examples from your projects where applying lambda expressions made code much cleaner and easier to read.Regarding the readability, we also have another part: locality.In C++03, you had to create functions or functors that could be far away from the place where you passed them as callable objects.This is hard to show on simple artificial examples, but you can imagine a large source file, with more than a thousand lines of code. The code organisation might cause that functors could be located in one place of a file (for example on top). Then the use of a functor could be hundreds of lines further or earlier in the code if you wanted to see the definition of a functor you had to navigate to a completely different place in the file. Such jumping might slow your productivity.We should also add one more topic to the first and the second point. Lambdas improve locality, readability, but there’s also the naming part. Since lambdas are anonymous, there’s no need for you to select the meaningful name for all of your small functions or functors.Let’s have a look at a case where you’d like to modify a default comparison operation for std::sort with an invocation counter.#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec { 0, 5, 2, 9, 7, 6, 1, 3, 4, 8 };

    size_t compCounter = 0;
    std::sort(vec.begin(), vec.end(), [&compCounter](int a, int b) {
        ++compCounter;
        return a < b;
    });

    std::cout << ""number of comparisons: "" << compCounter << '\n';

    for (auto& v : vec)
        std::cout << v << "", "";
}Play with the code @Compiler ExplorerAs you can see, we can capture a local variable and then use it across all invocations of the binary comparator. Such behaviour is not possible with regular functions (unless you use globals of course), but it’s also not straightforward with custom functors types. Lambdas make it very natural and also very convenient to use.In the example I captured compCounter by reference. This approach works, but if your lambda runs asynchronously or on different threads then you need to pay attention for dangling and synchronisation issues.This is one of the coolest examples not just related to lambdas, but also to several major Modern C++ features (primarily available in C++17):Have a look:#include <iostream>
#include <string>
#include <variant>

template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
template<class... Ts> overload(Ts...) -> overload<Ts...>;

int main() {
    std::variant<int, float, std::string> intFloatString { ""Hello"" };
    std::visit(overload  {
        [](const int& i) { std::cout << ""int: "" << i; },
        [](const float& f) { std::cout << ""float: "" << f; },
        [](const std::string& s) { std::cout << ""string: "" << s; }
      },
      intFloatString
    );        
}Play with the code @Compiler ExplorerThe above example is a handy approach to build a callable object with all possible overloads for variant types on the fly. The overloaded pattern is conceptually equivalent to the following structure:struct PrintVisitor
{
    void operator()(int& i) const {
        std::cout << ""int: "" << i; }

    void operator()(float& f) const {
        std::cout << ""float: "" << f;
    }

    void operator()(const std::string& s) const {
        std::cout << ""string: "" << s;
    }
};You can learn more about this pattern in my separate article, see the reference section. Additionally, it’s also possible to write a compact generic lambda that works for all types held in the variant. This can support runtime polymorphism based on std::variant/std::visit approach.#include <variant>

struct Circle { void Draw() const { } };
struct Square { void Draw() const { } };
struct Triangle { void Draw() const { } };

int main() {
    std::variant<Circle, Square, Triangle> shape;
    shape = Triangle{};
    auto callDraw = [](auto& sh) { sh.Draw(); };
    std::visit(callDraw, shape);
}Play with the code @Compiler ExplorerThis technique is an alternative to runtime polymorphism based on virtual functions. Here we can work with unrelated types. There’s no need for a common base class. See the Reference section for more links about this pattern.You might think that lambdas were introduced in C++11 and that’s all, nothing changed. But it’s not true.Here’s the list of major features related to lambdas that we got with recent C++ Standards:Plus some smaller things and fixes.With this article, we refreshed some basic ideas and advantages of lambda expressions. We reviewed improved readability, locality, ability to hold state throughout all invocations. We event went a bit further and examined the overloaded pattern and list all the features from recent C++ Standards. I guess we can summarise all points into the single statement:C++ Lambda Expressions make your code more readable and simpleLet us know your opinions in comments.Last year, in 2019, I published two extensive articles about lambda expression. They were based on a presentation on our local Cracow C++ User Group:Together, those articles become one of the most popular content, and so far, they generated over 86 thousand views!Later, I took the content from those articles and created an ebook that you can get on Leanpub.
But it’s just part of the story. After the launch, I managed to provide several significant updates, new sections, more examples and better descriptions. 
Right now, the book is massively improved and packed with more than 2X of the original content. You can get it here: 
Get C++ Lambda Story @LeanpubThe book is also available in a package with my C++17 book: 
  C++17 in Detail and Lambda Story Bundle
And also you get get it for free if you join my Patreon page: 
  See Extra Benefits for Patrons and Get Lambda Story for Free
",cpp
2,"Two weeks ago, I announced a little game on my blog! Today I’d like to present some of the solutions you sent me and discuss a few things from various aspects of Modern C++.First of all, I’d like to thank all of the participants for sending the solutions. I got 14 of them.Although the task might sound easy, it required between 100 or 300 lines of code. So it wasn’t just a five-minute coding session. Thanks for your time and I hope it was a funny experience for you :)The task for the game was as follows: write a random spaceship generator which can create amazing spaceships (*)!(*) Not to mistake with the spaceship operator for C++20 :)For example:Spaceship with ionizing engine, small wings, regular cabin, tie fighter style fuselage and rocket launcher weapon.Each participant got a chance to win the following reward:3-month Educative.io service and 15$ Amazon.com Gift CardI have 5 of those “packs” for five people.The winners were selected randomly from all of the participants and should already get notifications.Please have a look at my initial example :)#include <string> 
#include <cstring> 
#include <iostream>
#include <vector>  
#include <fstream>
#include <random>
#include <algorithm>

char partsFileName[128] = ""vehicle_parts.txt"";

std::vector<std::string> allParts;

class Spaceship {
public:
    static void GenerateShip(SpaceShip *pOutShip);

    void Print() {
        // print code...
    }
private:
    std::string _engine;
    std::string _fuselage;
    std::string _cabin;
    std::string _large_wings; // optional
    std::string _small_wings;  // optional
    std::string _armor;
    std::string _weapons[4]; // max weapon count is 4
};

void Spaceship::GenerateShip(Spaceship *pOutShip) {
    std::vector<std::string> engineParts;
    std::vector<std::string> fuselageParts;
    std::vector<std::string> cabinParts;
    std::vector<std::string> wingsParts;
    std::vector<std::string> armorParts;
    std::vector<std::string> weaponParts;

    for (const auto& str : allParts) {
        if (str.rfind(""engine"") != std::string::npos)
            engineParts.push_back(str);
        else if (str.rfind(""fuselage"") != std::string::npos)
            fuselageParts.push_back(str);
        else if (str.rfind(""cabin"") != std::string::npos)
            cabinParts.push_back(str);
        else if (str.rfind(""wings"") != std::string::npos)
            wingsParts.push_back(str);
        else if (str.rfind(""armor"") != std::string::npos)
            armorParts.push_back(str);
        else if (str.rfind(""weapon"") != std::string::npos)
            weaponParts.push_back(str);
    }

    std::random_device rd;
    std::mt19937 g(rd());

    std::shuffle(engineParts.begin(), engineParts.end(), g);
    std::shuffle(fuselageParts.begin(), fuselageParts.end(), g);
    std::shuffle(cabinParts.begin(), cabinParts.end(), g);
    std::shuffle(wingsParts.begin(), wingsParts.end(), g);
    std::shuffle(armorParts.begin(), armorParts.end(), g);
    std::shuffle(weaponParts.begin(), weaponParts.end(), g);

    // select parts:
    pOutShip->_engine = engineParts[0];
    pOutShip->_fuselage = fuselageParts[0];
    pOutShip->_cabin = cabinParts[0];
    pOutShip->_armor = armorParts[0];
    pOutShip->_large_wings = wingsParts[0];
    pOutShip->_weapons[0] = weaponParts[0];
}

int main(int argc, char* argv[]) {
    if (argc > 1) {
        strcpy(partsFileName, argv[1]);
    }    

    std::cout << ""parts loaded from: "" << partsFileName << '\n';

    std::ifstream file(partsFileName);
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            allParts.push_back(line);
        }
        file.close();
    }     

    Spaceship sp;
    Spaceship::GenerateShip(&sp);
    sp.Print();
}As you can see above the program consists of several parts:Can you write better code? :)Yes, you can! Through your submissions, you managed to fix all of my bad patterns :)Here are the code samples extracted from submissions.First of all, my super-advanced starting code example used global variables. The submitted code nicely fixed this issue by using only local variables.For example in solution from Thomas H. there’s a separate class that contains all parts, this is a small Database:PartDB partDB = readPartDB(partsFileName);
const Spaceship sp = makeRandomSpaceShip(partDB);And the details:struct PartDB {
    std::vector<Engine> engines;
    std::vector<Fuselage> fuselages;
    std::vector<Cabin> cabins;
    std::vector<Armor> armors;
    std::vector<Wing> wings;
    std::vector<Weapon> weapons;
    std::vector<Shield> shields;
};

PartDB readPartDB(const std::filesystem::path& partsFileName) {
    PartDB partDB;

    std::ifstream file(partsFileName);
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            if (line.rfind(""engine"") != std::string::npos) {
                partDB.engines.push_back(Engine{line});
            } else if (line.rfind(""fuselage"") != std::string::npos) {
                // ...
            } else {
                std::cerr << ""Unknown part: '"" << line << "" '\n"";
            }
        }
    }

    return partDB;
}This is nice and a simple way to keep all the parts in one place. My starting code mixed loading with the generation, so it was not the best pattern.In my starting code I used only a vector of strings to store all the parts. But many solutions improved that by using maps and even maps of variants:void GetDataFromFile()
    {
        std::string line;
        inputData.exceptions(std::ifstream::badbit);
        while (std::getline(inputData, line))
        {
            int n = line.rfind("" "");
            std::array<std::string, 2> arStrParts{ line.substr(0, n), line.substr(n + 1) };
            if (auto it = umShipParts.find(arStrParts[1]); it != umShipParts.end())
            {
                std::visit([&arStrParts](auto& obj) { obj.add(arStrParts[0]); }, umShipParts[arStrParts[1]]);
            }
        }
    }More in the full solution from Mike @WandboxAnother cool example we can find in the code created by Marius Bancila:part_type find_part_type(std::string_view description)
{
   static std::vector<part_description> parts
   {
      {part_type::engine,  {""engine""}},
      {part_type::fuselage,{""fuselage""}},
      {part_type::cabin,   {""cabin""}},
      {part_type::wings,   {""wings""}},
      {part_type::armor,   {""armor"", ""shield""}},
      {part_type::weapon,  {""weapon""}}
   };

   for (auto const & [type, desc] : parts)
   {
      for (auto const& d : desc)
      {
         if (description.rfind(d) != std::string::npos)
            return type;
      }
   }

   throw std::runtime_error(""unknown part"");
}In the above examples, you can see that we have much better code, more readable and scalable (if you want to add new types of parts).In the another solution Michal stored also the names of the parts:for (auto&& partsLine : partLines)
 {
    auto key   = utils::last_word(partsLine);
    auto part  = partsLine.substr(0, partsLine.size() - key.size() - 1);
    auto keyIt = parts.find(key);

    if (keyIt == parts.end())
    {
        parts.try_emplace(std::move(key), std::vector<std::string> {std::move(part)});
    }
    else
    {
        parts.at(key).emplace_back(std::move(part));
    }
 }This approach allows to specify the mandatory parts in a just an array, without creating the types for each part:constexpr auto mandatoryParts = {""engine""sv, ""fuselage""sv, ""cabin""sv, ""armor""sv};Have a look @WandboxAlso, I’d like to draw your attention to the example sent by JFT who went even further with the flexibility. Rather than fixing the specification of the spaceship in code, he described it in the parts file.That way, the design of the spaceship is fully customisable, and there’s no need to change code of the application. What’s more, the author managed to write quite concise code, so it’s quite short:Example of a spaceship design:1 engine
1 fuselage
1 cabin
1 armor
-4 weapon
-1 wings_s
-1 wings_l
-1 shieldwhere:where    number_required is:
            0 to ignore
            > 0 for required up to
            < 0 for optional up toThe code is available here @WandboxIn a few examples I’ve noticed the following code:enum class spaceshipPartsEnum
{
    engine,
    fuselage,
    cabin,
    wings,
    armor,
    weapon
};And then the tostring() method.std::string enum_to_string (spaceshipPartsEnum part)
{
    switch (part)
    {
        case spaceshipPartsEnum::engine:
            return ""engine"";
        case spaceshipPartsEnum::fuselage:
            return ""fuselage"";
        case spaceshipPartsEnum::cabin:
            return ""cabin"";
        case spaceshipPartsEnum::wings:
            return ""wings"";
        case spaceshipPartsEnum::armor:
            return ""armor"";
        case spaceshipPartsEnum::weapon:
            return ""weapon""; 
    }

    assert (false);
    return {};
}It would be great to have native support for enum to string conversions!From Michal: See @Wandbox
namespace utils
{
    /**
     *  Just a siple wrapper of random nuber generator.
     */
    class random_uniform_int
    {
    private:
        std::mt19937 generator_;
        std::uniform_int_distribution<size_t> distribution_;

    public:
        random_uniform_int(size_t const min, size_t const max, unsigned long const seed) :
            generator_    {seed},
            distribution_ {min, max} 
        {
        }

        auto next_index () -> size_t
        {
            return distribution_(generator_);
        }
    };

    /**
     *  Just a siple wrapper of random nuber generator.
     */
    class random_bool
    {
    private:
        std::mt19937 generator_;
        std::uniform_real_distribution<double> distribution_;

    public:
        random_bool(unsigned long const seed) :
            generator_    {seed},
            distribution_ {0, 1}
        {
        }

        auto next_bool () -> bool
        {
            return distribution_(generator_) < 0.5;
        }
    };

    auto last_word (const std::string& s) -> std::string
    {
        auto const lastSpaceIndex = s.rfind(' ');

        if (lastSpaceIndex == std::string::npos)
        {
            return """";
        }

        return s.substr(lastSpaceIndex + 1);
    }
}I guess that one of the easiest features that you could use from C++20 is starts_with or ends_with member functions that we get for string and string views: In the example from Benjamin he used it to replace rfind() calls:Have a look @WandboxWarehouse& Warehouse::add(std::string description) {
    if (description.ends_with(""engine"")) {
        engines_.emplace_back(std::move(description));
    } else if (description.ends_with(""fuselage"")) {
        fuselage_.emplace_back(std::move(description));       
        // ...And if you’d like to see more of C++, have a look at this code from Jackson @Wandbox. He used ranges and concepts and also…And also one of the coolest use of the spaceship operator:// Spaceship for the Spaceship :)
auto operator<=>(const Spaceship& other) const noexcept = default;One again thank you for all the solutions! In this short blog post, I managed to extract only a few bits of code, but there’s more to that. 
Your solutions even got part validation, logging, template machinery and much more cool ideas!",cpp
3,"4th May is the Star Wars Day so why not join the celebration and build some space ships? Of course in C++ :)Read on and see how to join the game and get a chance to win some extras!The submission dealine is over, I'm in the process of gathering the results. Stay tuned for the final summary and thanks for all of your solutions!Your task is simple: write a spaceship random generator which can create amazing spaceships (*)!(*) Not to mistake with the spaceship operator for C++20 :)For example:Spaceship with ionizing engine, small wings, regular cabin, tie fighter style fuselage and rocket launcher weapon.How to do it?Below, you can find my super-advanced prototype that is written is C… C++ something… legacy. Update it to modern C++, use as many new C++ features and show some cool programming techniques and patterns.Have a look:#include <string> 
#include <cstring> 
#include <iostream>
#include <vector>  
#include <fstream>
#include <random>
#include <algorithm>

char partsFileName[128] = ""vehicle_parts.txt"";

std::vector<std::string> allParts;

class Spaceship {
public:
    static void GenerateShip(SpaceShip *pOutShip);

    void Print() {
        // print code...
    }
private:
    std::string _engine;
    std::string _fuselage;
    std::string _cabin;
    std::string _large_wings; // optional
    std::string _small_wings;  // optional
    std::string _armor;
    std::string _weapons[4]; // max weapon count is 4
};

void Spaceship::GenerateShip(Spaceship *pOutShip) {
    std::vector<std::string> engineParts;
    std::vector<std::string> fuselageParts;
    std::vector<std::string> cabinParts;
    std::vector<std::string> wingsParts;
    std::vector<std::string> armorParts;
    std::vector<std::string> weaponParts;

    for (const auto& str : allParts) {
        if (str.rfind(""engine"") != std::string::npos)
            engineParts.push_back(str);
        else if (str.rfind(""fuselage"") != std::string::npos)
            fuselageParts.push_back(str);
        else if (str.rfind(""cabin"") != std::string::npos)
            cabinParts.push_back(str);
        else if (str.rfind(""wings"") != std::string::npos)
            wingsParts.push_back(str);
        else if (str.rfind(""armor"") != std::string::npos)
            armorParts.push_back(str);
        else if (str.rfind(""weapon"") != std::string::npos)
            weaponParts.push_back(str);
    }

    std::random_device rd;
    std::mt19937 g(rd());

    std::shuffle(engineParts.begin(), engineParts.end(), g);
    std::shuffle(fuselageParts.begin(), fuselageParts.end(), g);
    std::shuffle(cabinParts.begin(), cabinParts.end(), g);
    std::shuffle(wingsParts.begin(), wingsParts.end(), g);
    std::shuffle(armorParts.begin(), armorParts.end(), g);
    std::shuffle(weaponParts.begin(), weaponParts.end(), g);

    // select parts:
    pOutShip->_engine = engineParts[0];
    pOutShip->_fuselage = fuselageParts[0];
    pOutShip->_cabin = cabinParts[0];
    pOutShip->_armor = armorParts[0];
    pOutShip->_large_wings = wingsParts[0];
    pOutShip->_weapons[0] = weaponParts[0];
}

int main(int argc, char* argv[]) {
    if (argc > 1) {
        strcpy(partsFileName, argv[1]);
    }    

    std::cout << ""parts loaded from: "" << partsFileName << '\n';

    std::ifstream file(partsFileName);
    if (file.is_open()) {
        std::string line;
        while (std::getline(file, line)) {
            allParts.push_back(line);
        }
        file.close();
    }     

    Spaceship sp;
    Spaceship::GenerateShip(&sp);
    sp.Print();
}As you can see above the program consists of several parts:Can you write better code? :)Each participant will get a chance to win the following reward:3-month Educative.io service and 15$ Amazon.com Gift CardI have 5 of those “packs” for 5 people.educative.io is a learning  platform with “Rich, text-based courses with embedded coding  environments make learning a breeze”. They have more than 265.000  learners, many courses, and learning tracks. For example, they have  learning tracks to machine learning, DevOps but also Python, Java, and  C++ (My course about C++17 is there!).The winners will be selected randomly from all of the participants and announced in two weeks. You have one week to send me the working code. See the full rules below.The submission dealine is over, I'm in the process of gathering the results. Stay tuned for the final summary and thanks for all of your solutions!Deadline of submission: next Monday 11th May by midnight CESTRequirements:Please send me the submissions to bartlomiej DOT filipek @bfilipek.com. You can use links to Wandbox or Compiler explorer (to make my life easier). 
Also, please Include a description of the major features and techniques used.In two weeks time I will select some of the interesting submissions and share it on the separate blog post (if you agree).If you have questions, or if you like me to clarify something, then don't hesitate and ask in comments or via email.You can use below playground to experiment with the code:(It uses GCC 9.3 to compile the code, so only a limited of C++20 features is available)Additionally, if you want to use some modern features in your submissions and you’d like to learn more about them, you can use this solid discount for my books:The coupons are valid till the end of Monday, 11th May",cpp
4,"Blob storage is an object storage service you use in Azure. It is designed for storing large volumes of unstructured data, including text, binary data, images, and text. In this service, your data is stored in containerized blobs with a directory-like structure. You can use blob storage to ensure flexible access to storage, high availability, and data consistency. Read on to learn how you can use C++ with Azure storage.This article is a guest post from Gilad David Maayan.Gilad is a technology writer who has worked with over 150 technology companies including SAP, Samsung NEXT, NetApp and Imperva, producing technical and thought leadership content that elucidates technical solutions for developers and IT leadership. See his profile at Linkedin.David also wrote another article for this site: A Gentle Intro to Developing C++ Apps for AWS and S3Use cases for blob storage include:When using blob storage, there are three storage tiers you can choose from:When you need to access or manage blob storage and are working in C++, you can use the Azure Storage Client Library for C++. This library enables you to more easily build and integrate applications written in C++ with blob storage services.Features of the library include:When building your applications, you can use the following steps to attach your application to your blob storage resources. If you haven’t migrated to Azure yet, you can find more information in this guide about Azure migration.To add libraries, you need to include the following statements in your code file:#include <was/storage_account.h>
#include <was/blob.h>
#include <cpprest/filestream.h> 
#include <cpprest/containerstream.h> You can find more information about this code in the official documentation.Next, you need to set up a storage connection string. A connection string enables you to store credentials and endpoint information needed to access data management services. When configuring your connection string, you need to include the name of your storage account and your access keys. These are listed in your Azure Portal.You can model your connection string on the following example:const utility::string_t storage_connection_string(U(""DefaultEndpointsProtocol=https;AccountName={Account Name};AccountKey={Account Access Key}""));Once your connection string is created, use the following parse method to retrieve your storage account information. Within this method, cloud_storage_account represents your specific account information.azure::storage::cloud_storage_account storage_account = azure::storage::cloud_storage_account::parse(storage_connection_string);After your information is retrieved, you can retrieve your individual objects by creating a cloud_blob_client class. You can do this with the following lines:azure::storage::cloud_blob_client blob_client = storage_account.create_cloud_blob_client(); Once your application is connected to your blob storage, you can begin performing a variety of common operations. Some of the most useful operations are covered below.Within Blob storage, you can store page and block blobs; block is the recommended type. To upload data to block blobs, you need to obtain your blob reference via a container reference. Once you have a blob reference, you can upload data via the upload_from_stream method. You can use this method to create new blobs or to modify existing blobs.To see how this works, refer to the following code. Keep in mind, this assumes that you already have an existing container, have retrieved your storage account, and created a blob client (as s covered above).To reference your container:azure::storage::cloud_blob_container container = blob_client.get_container_reference(U({Container Name}));To retrieve a reference to your blob:azure::storage::cloud_block_blob blockBlob = container.get_block_blob_reference(U({Blob Name}));To create or overwrite your blob:concurrency::streams::istream input_stream = concurrency::streams::file_stream<uint8_t>::open_istream(U({Text File Name})).get();

blockBlob.upload_from_stream(input_stream);

input_stream.close().wait();To retrieve data stored in blobs, you need to convert your blob data to a stream object which you can then transfer to a local file. You can accomplish this with the download_to_stream method. To perform this action, you need to first retrieve your storage account, create a blob client, and retrieve your container and blob references (as shown above). Once these processes are complete, you can use the following to download your blob data:concurrency::streams::container_buffer<std::vector<uint8_t>> buffer;
concurrency::streams::ostream output_stream(buffer);
blockBlob.download_to_stream(output_stream);

std::ofstream outfile({Text File Name}, std::ofstream::binary);
std::vector<unsigned char>& data = buffer.collection();

outfile.write((char *)&data[0], buffer.size());
outfile.close(); To delete your blobs, you need to determine your blob reference. Once you know the reference, you can use blockBlob.delete_blob(); to delete it. Keep in mind, that this process permanently deletes your blobs so you should use it with care.You can easily use C++ for Azure storage operations, with the Azure Storage Client Library for C++. Once you include Azure’s premade libraries in your code, you can set up a connection string that enables storage of endpoint and credentials data. You should then retrieve your storage account with the parse method provided above. Once C++ is properly configured, you’ll be able to upload data, download blobs, delete blobs, and perform many other actions. Do you run your projects in the cloud? 
Do you use C++ in that area? 
Would you like to see more articles about that technology? 
Let us know in the comments below the article.",cpp
5,"What is SFINAE? Where can you use this metaprogramming technique? Are there any better alternatives in Modern C++? And how about Concepts from C++20?Read on to find out!Last Update: 20th April 2020Note: I’d like to thank KJ for reviewing this article and providing me with valuable feedback from the early stage of the writing process. Also, many thanks go to GW who reviewed the beta version.Let’s start with some basic ideas behind this concept:Very briefly: the compiler can reject code that “would not compile” for a given type.From Wiki:Substitution failure is not an error (SFINAE) refers to a situation in C++ where an invalid substitution of template parameters is not in itself an error. David Vandevoorde first introduced the acronym SFINAE to describe related programming techniques.We’re talking here about something related to templates, template substitution rules and metaprogramming… which make it a possibly a scary area!A quick example: @Wandboxstruct Bar {
    typedef double internalType;  
};

template <typename T> 
typename T::internalType foo(const T& t) { 
    cout << ""foo<T>\n""; 
    return 0; 
}

int main() {
    foo(Bar());
    foo(0); // << error!
}We have one excellent template function that returns T::internalType, and we call it with Bar and int param types.The code, of course, will not compile. The first call of foo(Bar()); is a proper construction, but the second call generates the following error (GCC):no matching function for call to 'foo(int)'
...
template argument deduction/substitution failed:When we make a correction and provide a suitable function for int types. As simple as:int foo(int i) { cout << ""foo(int)\n""; return 0; }The code can be built and run.Why is that?When we added an overloaded function for the int type, the compiler could find a proper match and invoke the code. But in the compilation process, the compiler also ‘looks’ at the templated function header. This function is invalid for the int type, so why was there not even a warning reported (like we got when there was no second function provided)? To understand this, we need to look at the process of building the overload resolution set for a function call.When the compiler tries to compile a function call (simplified):In our example: typename T::internalType foo(const T& t) was not a good match for int and it was rejected from overload resolution set. But at the end, int foo(int i) was the only option in the set, so the compiler did not report any problems.I hope you get a basic idea what SFINAE does, but where can we use this technique? A general answer: whenever we want to select a proper function/specialization for a specific type.Some of the examples:Ok, but how can we write such SFINAE expressions? Are there any helpers?Let’s meet std::enable_if.One of the primary uses of SFINAE can be found through  enable_if expressions.enable_if is a set of tools, available in the Standard Library since C++11, that internally use SFINAE. They allow to include or exclude overloads from possible function templates or class template specialization.For example:// C++11:
template <class T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type 
foo(T t) {
  std::cout << ""foo<arithmetic T>\n"";
  return t;
}This function ‘works’ for all the types, that are arithmetic (int, long, float…). If you pass other types (for instance MyClass), it will fail to instantiate. In other words, template instantiations for non-arithmetic types are rejected from overload resolution sets. This construction might be used as a template parameter, function parameter or as a function return type.enable_if<condition, T>::type will generate T, if the condition is true, or an invalid substitution if condition is false.enable_if can be used along with type traits to provide the best function version based on the trait criteria.Also please note that since C++14 and C++17 we have a nicer syntax and more compact. There’s no need to use ::type or ::value for enable_if or the traits, as there are _v and _t variable templates and template aliases introduced.Our previous code can become:// C++17:
template <class T>
typename std::enable_if_t<std::is_arithmetic_v<T>, T> // << shorter!
foo(T t) {
  std::cout << ""foo<arithmetic T>\n"";
  return t;
}Please notice the use of std::enable_if_t and std::is_arithmetic_v.C++11 has even more complicated option for SFINAE.n2634: Solving the SFINAE problem for expressionsBasically, this document clears the specification, and it lets you use expressions inside decltype and sizeof.For example:template <class T> auto f(T t1, T t2) -> decltype(t1 + t2);In the above case, the expression of t1+t2 needs to be checked. It will work for two int’s (the return type of the + operator is still int), but not for int and std::vector.Expression checking adds more complexity into the compiler. In the section about overload resolution, I mentioned only about doing a simple substitution for a template parameter. But now, the compiler needs to look at expressions and perform full semantic checking.BTW: VS2013 and VS2015 support this feature only partially (msdn blog post about updates in VS 2015 update 1), some expressions might work, some (probably more complicated) might not. Clang (since 2.9) and GCC (since 4.4) fully handle “Expression SFINAE”.SFINAE and enable_if are compelling features, but also it’s hard to get it right. Simple examples might work, but in real-life scenarios, you might get into all sorts of problems:Here is a discussion at StackOverflow: Why should I avoid std::enable_if in function signaturesCan we do something better?We have at least three things: Let’s review them briefly.This is a much more readable version of selecting which version of a function is called. First, we define a core function, and then we call version A or B depending on some compile-time condition.template <typename T>
int get_int_value_impl(T t, std::true_type) {
    return static_cast<int>(t+0.5f);
}

template <typename T>
int get_int_value_impl(T t, std::false_type) {
    return static_cast<int>(t);
}

template <typename T>
int get_int_value(T t) {
    return get_int_value_impl(t, std::is_floating_point<T>{});
}When you call get_int_value the compiler will then check the value of std::is_floating_point and then call the matching _impl function.Since C++17 we have a new tool, build in the language, that allows you to check the condition at compile time - without the need to write complex templated code!In a short form we can present it:template <typename T>
int get_int_value(T t) {
     if constexpr (std::is_floating_point_v<T>) {
         return static_cast<int>(t+0.5f);
     }
     else {
         return static_cast<int>(t);
     }
}You can read more in the following blog post: Simplify code with ‘if constexpr’ in C++17.With each C++ Standard revision, we get much better techniques and tools to write templates. In C++20 we’ll get a long-awaited feature, that will revolutionise the way we write templates!With Concepts, you’ll be able to add constraints on the template parameters and get better compiler warnings.One basic example:// define a concept:
template <class T>
concept SignedIntegral = std::is_integral_v<T> && std::is_signed_v<T>;

// use:
template <SignedIntegral T>
void signedIntsOnly(T val) { }In the code above we first create a concept that describes types that are signed and integral. Please notice that we can use existing type traits. Later, we use it to define a template function that supports only types that match the concept. Here we don’t use typename T, but we can refer to the name of a concept.Let’s now try to wrap our knowledge with an example.To conclude my notes, it would be nice to go through some working example and see how SFINAE is utilized:See the code @WandboxThe test class:template <typename T>
class HasToString {
private:
    typedef char YesType[1];
    typedef char NoType[2];

    template <typename C> static YesType& test(decltype(&C::ToString));
    template <typename C> static NoType& test(...);

public:
    enum { value = sizeof(test<T>(0)) == sizeof(YesType) };
};The above template class will be used to test if some given type T has ToString() method or not. What we have here… and where is the SFINAE concept used? Can you see it?When we want to perform the test, we need to write:HasToString<T>::valueWhat happens if we pass int there? It will be similar to our first example from the beginning of the article. The compiler will try to perform template substitution, and it will fail on:template <typename C> static YesType& test( decltype(&C::ToString) ) ;Obviously, there is no int::ToString method so that the first overloaded method will be excluded from the resolution set. But then, the second method will pass (NoType& test(...)), because it can be called on all the other types. So here we get SFINAE! One method was removed and only the second was valid for this type.In the end the final enum value, computed as:enum { value = sizeof(test<T>(0)) == sizeof(YesType) };returns NoType and since sizeof(NoType) is different than sizeof(YesType) the final value will be 0.What will happen if we provide and test the following class?class ClassWithToString {
public:
    string ToString() { return ""ClassWithToString object""; }
};Now, the template substitution will generate two candidates: both test methods are valid, but the first one is better, and that will be ‘used‘. We’ll get the YesType and finally the HasToString<ClassWithToString>::value returns 1 as the result.How to use such checker class?Ideally it would be handy to write some if statement:if (HasToString<decltype(obj)>::value)
    return obj.ToString();
else
    return ""undefined"";We can write this code with if constexpr, but for the purpose of this example, let’s focus on the C++11/14 solution.To do that, we can use enable_if and create two functions: one that will accept classes with ToString and one that accepts all other cases.template<typename T> 
typename enable_if<HasToString<T>::value, string>::type
CallToString(T * t) {
    return t->ToString();
}

string CallToString(...) {
    return ""undefined..."";
}Again, there is SFINAE in the code above. enable_if will fail to instantiate when you pass a type that generates HasToString<T>::value = false.The above technique is quite complicated and also limited. For example, it doesn’t restrict the return type of the function.Let’s see how Modern C++ - can help.In one comment under the initial version of the article, STL (Stephan T. Lavavej) mentioned that the solution I presented in the article was from old Cpp style. What is this new and modern style then?We can see at several things:Let’s have a look:decltype is a powerful tool that returns type of a given expression. We already use it for:template <typename C> 
static YesType& test( decltype(&C::ToString) ) ;It returns the type of C::ToString member method (if such a method exists in the context of that class).declval is a utility that lets you call a method on a T without creating a real object. In our case, we might use it to check the return type of a method:decltype(declval<T>().toString())constexpr suggests the compiler to evaluate expressions at compile time (if possible). Without that our checker methods might be evaluated only at run time. The new style suggests adding constexpr for most methods.Akrzemi1: “constexpr” function is not “const”Full video for the lecture:CppCon 2014: Walter E. Brown “Modern Template Metaprogramming: A Compendium, Part II” - YouTubeStarting at around 29 minute, and especially around 39 minutes.This is an amazing meta-programming pattern! I don’t want to spoil anything, so just watch the video, and you should understand the idea! :)Walter E. Brown proposes a whole utility class that can be used for checking interfaces and other properties of a given class. Of course, most of it is based on void_t technique.If I am correct and assuming you have void_t in your compiler/library, this is a new version of the code:// default template:
template< class , class = void >
struct has_toString : false_type { };

// specialized as has_member< T , void > or sfinae
template< class T>
struct has_toString<T , void_t<decltype(&T::toString)>> : std::is_same<std::string, decltype(declval<T>().toString())>
{ };See the code @WandboxPretty nice… right? :)It uses explicit detection idiom based on void_t. Basically, when there is no T::toString() in the class, SFINAE happens, and we end up with the general, default template (and thus with false_type). But when there is such a method in the class, the specialized version of the template is chosen. This could be the end if we don’t care about the return type of the method. But in this version, we check this by inheriting from std::is_same. The code checks if the return type of the method is std::string. Then we can end up with true_type or false_type.We can do even better in C++20. With this feature, we can declare a new concept that specifies the interface of a class:For example:template <typename T>
concept HasToString = requires(T v)
{
    {v.toString()} -> std::convertible_to<std::string>;
};And that’s all! all written with a nice and easy to read syntax.We can try this with some test code:#include <iostream>
#include <string>
#include <type_traits>

template <typename T>
concept HasToString = requires(const T v)
{
    {v.toString()} -> std::convertible_to<std::string>;
};

struct Number {
    int _num { 0 };
    std::string toString() const { return std::to_string(_num); };
};

void PrintType(HasToString auto& t) {
    std::cout << t.toString() << '\n';
}

int main() {
    Number x { 42 };
    PrintType(x);
}And if your type doesn’t support toString then you’ll might get the gollowing compiler error (GCC 10):int x = 42;
PrintType(x);And the error (a bit simplified):error: use of function 'void PrintType(auto:11&) [with auto:11 = int]' with unsatisfied constraints
    |     PrintType(x);
    |                ^
   note: declared here
    | void PrintType(HasToString auto& t) {
    |      ^~~~~~~~~
In instantiation of 'void PrintType(auto:11&) [with auto:11 = int]':
required for the satisfaction of 'HasToString<auto:11>' [with auto:11 = int]
in requirements with 'const int v'
note: the required expression 'v.toString()' is invalid
    8 |     {v.toString()} -> std::convertible_to<std::string>;
      |      ~~~~~~~~~~^~We moved to an entirely new world, from some complex SFINAE code, some improvements in C++14 and C++17 to a clear syntax in C++20.
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in Modern C++, check it out here:In this post, we covered theory and examples of SFINAE - a template programming technique that allows you to reject code from the overload resolution sets. In raw form, this can be a bit complicated, but thanks to modern C++ we have many tools that can help: for example enable_if, std::declval and a few others. What’s more, if you’re lucky to work with the latest C++ standard, you can leverage if constexpr from C++17 and also Concepts from C++20.The latter - concepts - can revolutionise our template code and make it easy to read and work with!First thing: if you have more time, please read An introduction to C++’s SFINAE concept: compile-time introspection of a class member by Jean Guegant. This is an excellent article that discusses SFINAE more deeply than I’ve ever found in other places. Highly recommended resource.Thanks for comments: @reddit/cpp thread",cpp
6,"Comments in code might not only be some text floating around the functions, variables and classes, but they might contain some extra semantic information. With this improvement, you can navigate through projects much faster or even organize your knowledge. In this blog post, I’ll show you two ways  on how to add extra metadata to comments in Visual Studio.You can also see thie article at the @WholeTomato Blog.Navigating through a large codebase might be a complicated task. It might be especially an issue when you have big projects (not to mention legacy systems) where logical parts are spread across many different files.In Visual Studio offers many tools that help with moving between headers, declarations, class hierarchies or all references of a given symbol. But what if you’d like to put a “todo”  item? Or some extra note? Such supplementary information can not only help with quick tasks but also might build knowledge about a system.Here are the things you might want to use to help in Visual StudioLet’s start with the first one.Visual Studio contains a feature that enables us to add metadata directly in comments; It’s called Task List. Take a look at this piece of code from my legacy project:class ShaderProgram
{
private:
    GLuint mId;
    std::vector<Shader *> mShaders; // refactor: convert to smart pointers!
public:
    // todo: implement other special member functions!
    ShaderProgram();
    ~ShaderProgram();As you can see above, I put keywords like refactor: or todo: inside comments.Visual Studio builds an index of all comments with those special keywords and shows them in a separate window:This is a handy way of managing simple activities or just taking some small notes for the future. What’s more, the refactor keyword is a custom marker. Visual Studio adds flexibility to set it in the environment settings.Here’s the link to the documentation Use the Task List - Visual Studio | Microsoft DocsThe task list is a nice improvement! The metadata lives inside comments so that other developers can pick up the same information. Still, you cannot easily transfer custom keywords, and the task window offers only basic support. For example, it doesn’t group things (like grouping all of the to-do lines).Is there anything better? For several years I’ve been a happy user of Visual Assist - which is an excellent tool for enhancing various aspects of Visual Studio (have a look at my previous blog posts here or here). The tool also has a powerful feature called Hashtags. This is a combination of named bookmarks, task list and tags that you might know from social networks.Take a look at the example from my project with extra notes:/// creates and can build GLSL programs, #shadersSystem
class ShaderProgram
{
private:
    GLuint mId;
    std::vector<Shader *> mShaders; // #refactor convert to smart pointers 
public:
    /// #refactor #ruleOfZero implement other special member functions!
    ShaderProgram();
    ~ShaderProgram();As you can see, this is just regular source code, but please notice those words proceeded with #. I’m using them to mark places that might be worth refactoring. For example, notes about refactoring:std::vector<Shader *> mShaders; // #refactor convert to smart pointersOr another example:/// creates and can build GLSL programs, #shadersSystemThis time I’ve used #shadersSystem which groups elements that are crucial to the handling of OpenGL Shaders in my animation application.Below you can see all of the tags that are displayed in the VA Hashtags window. Similarly to Visual Studio, Visual Assist scans the source code and presents the indexed data.In the picture above, you can see lots of different tags that I put throughout the code, for example:The screenshot also shows a considerable difference compared to the task window. The hashtags are grouped, you can also filter them, or hide according to the project name, directory or even a filename.Tags are created “on the fly”, there’s no need to predefine them in some configuration window. You just type # and some extra text (you can configure the minimum length of a tag, it’s 3 by default).Tags are stored directly in the source code, so other developers can immediately see the same information (assuming they also use Visual Assist). Such functionality can be used to create even some simple task manager when you can assign a task by the name of a developer:// #bartekToDo: please improve this code! don't use goto!Here are some more things you can do with themHere’s a great video that summarises the tool:In this short blog post, I wanted to describe two tools that you can use to add extra information to comments. Having little todo: comments or additional notes can enhance your daily work and build a handy list of actions for the future, or even build up the knowledge about the system.Depending on your preferences, you can keep those extra notes permanently in your code or just temporarily and gradually move the knowledge and todo actions into external documentation or task manager.In my daily work, I prefer VA hashtags over regular bookmarks, as they are easier to use in most cases and shows that extra information and structure. You can read more about VA Hashtags on their documentation page:  Visual Assist Hashtags.",cpp
7,"Runtime polymorphism usually connects with v-tables and virtual functions. However, in this blog post, I’ll show you a modern C++ technique that leverages std::variant and std::visit. This C++17 technique might not only offer better performance and value semantics, but also interesting design patterns. I bet that in many cases when you hear runtime polymorphism, you immediately imagine virtual functions.You declare a virtual function in a base class and then you override it in derived classes. When you call such a function on a reference or a pointer to the base class, then the compiler will invoke the correct overload. In most of the cases, compilers implement this technique with virtual tables (v-tables). Each class that has a virtual method contains an extra table that points to the addresses of the member functions. Before each call to a virtual method the compiler needs to look at v-table and resolve the address of a derived function.A canonical example:class Base {
public:
    virtual ~Base() = default;

    virtual void PrintName() const { 
        std::cout << ""calling Bases!\n""
    }
};

class Derived : public Base {
public:
    void PrintName() const override { 
        std::cout << ""calling Derived!\n""
    }
};

class ExtraDerived : public Base {
public:
    void PrintName() const override { 
        std::cout << ""calling ExtraDerived!\n""
    }
};

std::unique_ptr<Base> pObject = std::make_unique<Derived>();
pObject->PrintName();What are the advantages of this technique? Let’s name a few:I’d like to draw your attention to the “extensibility” part. For example, thanks to this feature, you can implement a plugin system. You expose the interface through some base class, but you don’t know the final number of plugins. They might be even loaded dynamically. Virtual dispatch is a crucial; part in this system.And what are the drawbacks?However, in C++17 (and also before thanks to the boost libraries) we also got another way of doing dynamic polymorphism! Let’s have a look.With std::variant, which is available since C++17, you can now use safe type unions and store many different types in a single object. Instead of a pointer to a base class, std::variant can store all “derived” classes.Let’s convert our first example with Base class into this new technique:First, the classes:class Derived {
public:
    void PrintName() const { 
        std::cout << ""calling Derived!\n""
    }
};

class ExtraDerived {
public:
    void PrintName() const { 
        std::cout << ""calling ExtraDerived!\n""
    }
};As you can see, there’s no Base class now! We can have a bunch of unrelated types now.And now the core part:std::variant<Derived, ExtraDerived> var;var defines an object that can be Derived or ExtraDerived. By default, it’s initialised with the default value of the first alternative. You can read more about variants in my separate and large blog post: Everything You Need to Know About std::variant from C++17.How can we call PrintName() depending on the type that is currently active inside var? We need two things: a callable object and std::visit.struct CallPrintName {
    void operator()(const Derived& d) { d.PrintName(); }    
    void operator()(const ExtraDerived& ed) { ed.PrintName(); }    
};

std::visit(CallPrintName{}, var);In the above example, I created a struct that implements two overloads for the call operator. Then std::visit takes the variant object and calls the correct overload.Let’s now consider the pros and cons of such an approach. Can you see differences compared with virtual dispatch?Previously I showed you some basic and artificial example, but let’s try something more useful and realistic.Imagine a set of classes that represent a Label in UI. We can have SimpleLabel with just some text, then DateLabel that can nicely show a date value and then IconLabel that also renders some icon next to the text.For each label we need a method that will build an HTML syntax so that it can be rendered later:class ILabel {
public:
    virtual ~ILabel() = default;

    [[nodiscard]] virtual std::string BuildHTML() const = 0;
};

class SimpleLabel : public ILabel {
public:
    SimpleLabel(std::string str) : _str(std::move(str)) { }

    [[nodiscard]] std::string BuildHTML() const override {
        return ""<p>"" + _str + ""</p>"";
    }

private:
    std::string _str;    
};

class DateLabel : public ILabel {
public:
    DateLabel(std::string dateStr) : _str(std::move(dateStr)) { }

    [[nodiscard]] std::string BuildHTML() const override {
        return ""<p class=\""date\"">Date: "" + _str + ""</p>"";
    }

private:
    std::string _str;    
};

class IconLabel : public ILabel {
public:
    IconLabel(std::string str, std::string iconSrc) : 
         _str(std::move(str)), _iconSrc(std::move(iconSrc)) { }

    [[nodiscard]] std::string BuildHTML() const override {
        return ""<p><img src=\"""" + _iconSrc + ""\""/>"" + _str + ""</p>"";
    }

private:
    std::string _str;    
    std::string _iconSrc;
};The example above shows ILabel interface and then several derived classes which implements BuildHTML member function.And here we have the use case, where we have a vector with pointers to ILabel and then we call the virtual function to generate the final HTML output:std::vector<std::unique_ptr<ILabel>> vecLabels;
vecLabels.emplace_back(std::make_unique<SimpleLabel>(""Hello World""));
vecLabels.emplace_back(std::make_unique<DateLabel>(""10th August 2020""));
vecLabels.emplace_back(std::make_unique<IconLabel>(""Error"", ""error.png""));

std::string finalHTML;
for (auto &label : vecLabels)
    finalHTML += label->BuildHTML() + '\n';

std::cout << finalHTML;Nothing fancy above, the calls to BuildHTML are virtual so at the end we’ll get the expected output:<p>Hello World</p>
<p class=""date"">Date: 10th August 2020</p>
<p><img src=""error.png""/>Error</p>And here’s the case with std::variant:struct VSimpleLabel {
    std::string _str;    
};

struct VDateLabel {
    std::string _str;    
};

struct VIconLabel {
    std::string _str;    
    std::string _iconSrc;
};

struct HTMLLabelBuilder {
    [[nodiscard]] std::string operator()(const VSimpleLabel& label) {
        return ""<p>"" + label._str + ""</p>"";
    }
    [[nodiscard]] std::string operator()(const VDateLabel& label) {
        return ""<p class=\""date\"">Date: "" + label._str + ""</p>"";
    }
    [[nodiscard]] std::string operator()(const VIconLabel& label) {
        return ""<p><img src=\"""" + 
               label._iconSrc + ""\""/>"" + label._str + ""</p>"";
    }
};In the previous code sample, I simplified the interface for the Label classes. Now, they store only the data and the HTML operations are moved to HTMLLabelBuilder.And the use case:using LabelVariant = std::variant<VSimpleLabel, VDateLabel, VIconLabel>;
std::vector<LabelVariant> vecLabels;
vecLabels.emplace_back(VSimpleLabel { ""Hello World""});
vecLabels.emplace_back(VDateLabel { ""10th August 2020""});
vecLabels.emplace_back(VIconLabel { ""Error"", ""error.png""});

std::string finalHTML;
for (auto &label : vecLabels)
    finalHTML += std::visit(HTMLLabelBuilder{}, label) + '\n';

std::cout << finalHTML;The example is available at ColiruHTMLLabelBuilder is only one option that we can use. Alternatively, we can also write a generic lambda that calls the member function from the derived classes:struct VSimpleLabel {
    [[nodiscard]] std::string BuildHTML() const {
        return ""<p class=\""date\"">Date: "" + _str + ""</p>"";
    }

    std::string _str;    
};

struct VDateLabel {
    [[nodiscard]] std::string BuildHTML() const {
        return ""<p class=\""date\"">Date: "" + _str + ""</p>"";
    }

    std::string _str;    
};

struct VIconLabel {
    [[nodiscard]] std::string BuildHTML() const {
        return ""<p><img src=\"""" + _iconSrc + ""\""/>"" + _str + ""</p>"";
    }

    std::string _str;    
    std::string _iconSrc;
};

auto callBuildHTML = [](auto& label) { return label.BuildHTML(); };
for (auto &label : vecLabels)
    finalHTML += std::visit(callBuildHTML, label) + '\n'This time we’re using a generic lambda, which gives a benefit of having the call in one place.In the disadvantage section for std::variant/std::visit I mentioned that Duck typing might sometimes be an issue. If you like, you can enforce the interface on the types and functions. For example, with C++20, we can write a concept that allows us to call generic lambda only on types that expose the required interface.(Thanks to Mariusz J for this idea!)template <typename T>
concept ILabel = requires(const T v)
{
    {v.buildHtml()} -> std::convertible_to<std::string>;
};The concept is satisfied by all types that have buildHtml() const member function that returns types convertible to std::string.Now we can use it to enforce the generic lambda (thanks to the constrained auto terse syntax):auto callBuildHTML = [](ILabel auto& label) -> std::string { 
    return label.buildHtml(); 
};
for (auto &label : vecLabels)
    finalHTML += std::visit(callBuildHTML, label) + '\n';See the example at @WandboxAnother critical question you may want to ask is about the performance of this new technique.Is std::visit faster than virtual dispatch?Let’s find out.When I created a simple benchmark for my ILabel example, I got no difference.You can see the benchmark here @QuickBenchI guess the string handling has high cost over the whole code execution; also there are not many types in the variant, so this makes the actual call very similar.But, I have another benchmark that uses a particle system.using ABC = std::variant<AParticle, BParticle, CParticle>;
std::vector<ABC> particles(PARTICLE_COUNT);

for (std::size_t i = 0; auto& p : particles) {
  switch (i%3) {
    case 0: p = AParticle(); break;
    case 1: p = BParticle(); break;
    case 2: p = CParticle(); break;
  }
  ++i;
}

auto CallGenerate = [](auto& p) { p.generate(); };
for (auto _ : state) {
  for (auto& p : particles)
    std::visit(CallGenerate, p);
}The Particle class (and their versions AParticle, BParticle, etc) uses 72 bytes of data, and they have the Generate() method that is “virtual”.And this time I got 10% per improvement for the std::visit version!So why the code might be faster? I think we might have several things here:Here’s also another benchmark that shows that the variant version is 20% slower than a vector with just one type: std::vector<AParticle> particles(PARTICLE_COUNT);. See it at QuickBenchMy test was relatively simple and might not mean that std::visit is always faster. But to get a better perspective you might want to have a look at this excellent presentation from Mateusz Pusz who implemented a whole TCPIP state machine and got much better performance with std::visit. The execution times were also more stable and predictable than virtual calls.CppCon 2018: Mateusz Pusz “Effective replacement of dynamic polymorphism with std::variant” - YouTubeThere are also concerns about the code bloat that you might get from std::visit. Since this feature is a pure library implementation without extra support from the language, we can expect that it will add extra bytes to your executable. If you worry about this issue, then you might check the following links:It’s also worth remembering that the library solution works with all mixtures of std::variant, even with many variants passed in, so you pay for that “generic” support. If you’re not satisfied with the performance of the library, and you have a limited set of use cases, you can roll your implementation and see if that improves your code.
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in Modern C++, check it out here:In the article, we looked at a new technique to implement runtime polymorphism. With std::variant we can express an object that might have many different types - like a type-safe union, all with value semantics. And then with std::visit we can call a visitor object that will invoke an operation based on the active type in the variant. All makes it possible to have heterogeneous collections and call functions similarly to virtual functions.But is std::variant-based polymorphism better than a regular “virtual” polymorphism? There’s no clear answer, as both have their strengths and weaknesses. For example with std::variant, you need to know all of the possible types upfront, which might not be the case when you write a generic library or some kind of a plugin system. But on the other hand std::variant offers value semantics which might improve the performance of the system and reduce the need to use dynamic allocation.I also got a perfect summary from people who used that code in production. Here’s one great comment from Borys J (see his profile at Github):Some time ago I used std::variant/std::visit to implement processing of  different types of commands in an embedded system. Good thing about  variants is that polymorphism works without indirection - you don’t need a pointer or reference like with virtual functions. This helps in cases when the object would need to be created in a function and then  returned from it. I often code without using heap/dynamic memory at all  so I cannot just create an object dynamically within a function and then pass the ownership upwards. With variant, I can just return it by value (assuming it’s reasonably small) without loosing polymorphism.On the other hand, using them as a type-oriented branching technique I  found that as you move them around (in common sense, I don’t mean move  semantics) and you need to process them at different stages you end up  writing a new type of visitor each time you need to do something with  the variant. To make things worse, sometimes the way different types  within the variant are processed differs only slightly. In the result,  you end up with multiple visitors, some of them being kind of  intermediate and unnatural, each with few separate member functions for  each variant type. At the end of the day, you have the good old callback hell once again. Sure, you can utilise the lambda overload construct but it doesn’t change that much.Back to you:Share your experience in comments below!",cpp
8,"Memory access patterns are one of the key factors for writing efficient code that runs over large data sets. In this blog post, you’ll see why there might be a perf difference of almost 2.5x (in both directions!) when working with a vector of pointers versus a vector of value types.Let’s jump in.Last update: 23rd March 2020Let’s compare the following cases:For this blog post, let’s assume that Object is just a regular class, without any virtual methods. With pointers to a base class and also with virtual methods you can achieve runtime polymorphism, but that’s a story for some other experiment. For example, we can try std::variant against regular runtime polymorphism…Ok, so what are the differences between each collection? Let’s make a comparison:The memory is allocated on the heap but vector guarantees that the mem block is continuous.On the diagram above, you can see that all elements of the vector are next to each other in the memory block.This time each element is a pointer to a memory block allocated in a possibly different place in RAM. We use unique_ptr so that we have clear ownership of resources while having almost zero overhead over raw pointers.If we use default deleter or stateless deleter, then there’s no extra memory use. You can read more in a separate blog post: Custom Deleters for C++ Smart PointersWith shared_ptr we have a collection of pointers that can be owned by multiple pointers. This can simulate, for example, references in C#.This time, however, we have a little more overhead compared to the case with unique_ptr. To support reference counting the shared pointer needs to have a separate control block. Inside the block, there is a place to store the reference counter, the “weak” counter and also the deleter object.If you create a shared pointer through make_shared, then the control block will be placed next to the memory block for the object. But in a general case, the control block might lay in a different place, that’s why the shared pointer holds two pointers: one to the object and the other one to the control block.Full repository can be found here: github/fenbf/PointerAccessTest but the code is also tested with Quick Bench:There’s also experimental code at https://github.com/fenbf/benchmarkLibsTest where I wrote the same benchmark with a different library: Celero, Google Benchmark, Nonius or Hayai (and see the corresponding blog post: Revisiting An Old Benchmark - Vector of objects or pointers)Core parts of the benchmark:To have a useful example for the object class I selected the Particle class which can simulate some physical interactions and implements a basic Euler method:class Particle {
public:
    float pos[4];
    float acc[4];
    float vel[4];
    float col[4];
    float rot;
    float time;
    //uint8_t extra[EXTRA_BYTES];
public:

    void generate() noexcept {
        acc[0] = randF();
        acc[1] = randF();
        acc[2] = randF();
        acc[3] = randF();
        pos[0] = pos[1] = pos[2] = pos[3] = 0.0f;
        vel[0] = randF();
        vel[1] = randF();
        vel[2] = randF();
        vel[3] = vel[1] + vel[2];
        rot = 0.0f;
        time = 2.0f+randF();
    }

    void update(float dt) noexcept {
        vel[0] += acc[0] * dt;
        vel[1] += acc[1] * dt;
        vel[2] += acc[2] * dt;
        vel[3] += acc[3] * dt;
        pos[0] += vel[0] * dt;
        pos[1] += vel[1] * dt;
        pos[2] += vel[2] * dt;
        pos[3] += vel[3] * dt;
        col[0] = pos[0] * 0.001f;
        col[1] = pos[1] * 0.001f;
        col[2] = pos[2] * 0.001f;
        col[3] = pos[3] * 0.001f;
        rot += vel[3] * dt;
        time -= dt;

        if (time < 0.0f)
            generate();
    }
};The Particle class holds 72 bytes, and there’s also some extra array for our further tests (commented out for now). The update() method is simple, has only several arithmetic operations and a single branch. This method will be memory-bound as all operations inside are too simple.Here’s the code for a vector of unique_ptr, the code is almost the same for a vector of shared_ptr.static void UniquePtrUpdate(benchmark::State& state) {
  std::vector<std::unique_ptr<Particle>> particles(count);
    for (auto& p : particles)
        p = std::make_unique<Particle>();

  for (auto& p : particles)
            p->generate();

  ShuffleVector(particles);

  // Code inside this loop is measured repeatedly
  for (auto _ : state) {
    for (auto& p : particles)
            p->update(DELTA_TIME);
  }
}
BENCHMARK(UniquePtrUpdate);And also here’s the code that benchmarks std::sort:static void SharedPtrSort(benchmark::State& state) {
  std::vector<std::shared_ptr<Particle>> particles(count);
    for (auto& p : particles)
        p = std::make_shared<Particle>();

  for (auto& p : particles)
            p->generate();

  ShuffleVector(particles);

  // Code inside this loop is measured repeatedly
  for (auto _ : state) {
    std::sort(std::begin(particles), std::end(particles),
            [](const std::shared_ptr<Particle>& a, const std::shared_ptr<Particle>& b) {
                return a->pos[0] < b->pos[0];
            }
        );
  }
}
BENCHMARK(SharedPtrSort);When you allocate hundreds of (smart) pointers one after another, they might end up in memory blocks that are next to each other. This can affect the performance and be totally different than a regular use case when objects are allocated in random order at a random time and then added to a container. To mitigate this issue, the benchmark code adds a randomisation step: ShuffleVector().Before randomisation, we could get the following pointers’ addresses:After randomize:The second table shows large distances between neighbour objects. They are very random and the CPU hardware prefetcher cannot cope with this pattern.Vector of objects is just a regular vector with one call to the update method.static void ValueUpdate(benchmark::State& state) {
  std::vector<Particle> particles(count);

  for (auto& p : particles)
    p.generate();

  ShuffleVector(particles);

  // Code inside this loop is measured repeatedly
  for (auto _ : state) {
    for (auto& p : particles)
        p.update(DELTA_TIME);
  }
}
BENCHMARK(ValueUpdate);To fully understand why we have such performance discrepancies, we need to talk about memory latency.Here’s a great summary that explains the problem: 
The picture comes from the book: Systems Performance: Enterprise and the CloudIn the picture, you can see that the closer to the CPU a variable, the faster the memory access is. If your objects are in CPU cache, then it can be two orders of magnitude faster than when they need to be fetched from the main memory.So, why it is so important to care about iterating over continuous block of memory?Let us look at out main loop:for each particle p:
    p->update(DELTA_TIME);For 1000 particles we need 1000*72bytes = 72000 bytes, that means 72000/64 = 1125 cache line loads. In other words, for each particle, we will need 1.125 cache line reads.But CPUs are quite smart and will additionally use a thing called Hardware Prefetcher. CPU will detect that we operate on one huge memory block and will prefetch some of the cache lines before we even ask. Thus instead of waiting for the memory, it will be already in the cache!What about the case with a vector of pointers?For 1000 particles we need on the average 2000 cache line reads! This is 78% more cache line reads than the first case! Additionally, the hardware Prefetcher cannot figure out the pattern - it is random - so there will be a lot of cache misses and stalls.In one of our experiments, the pointer code for 80k of particles was more 266% slower than the continuous case.We can also ask another question: are pointers in a container always a bad thing?Have a look at the std::sort() case:.. ok… what happened there?As you can see this time, we can see the opposite effect. Having vector of objects is much slower than a vector of pointers.Here’s another result when the size of a Particle object is increased to 128 bytes (previously it was 72 bytes):See the benchmark at @QuickBenchThe results are because algorithms such as sorting need to move elements inside the container. So they not only read the data but also perform a copy (when the algorithm decides to swap items or move to a correct place according to the order).Copying pointers is much faster than a copy of a large object.If you know that copying is a blocker for the elements in the container, then it might be good to even replace the sorting algorithm into selection sort - which has a worse complexity than quicksort, but it has the lowest number of “writes”. So, as usual, it’s best to measure and measure.In the article, we’ve done several tests that compared adjacent data structures vs a case with pointers inside a container. Most of the time it’s better to have objects in a single memory block. Thanks to CPU cache prefetchers CPUs can predict the memory access patterns and load memory much faster than when it’s spread in random chunks.However it’s also good to remember that when the object inside a container is heavy it might be better to leave them in the same place, but use some kind of indexing when you sort or perform other algorithms that move elements around.And as usual with those kinds of experiments: pleas measure, measure and measure - according to your needs and requirements.Do you try to use memory-efficient data structures? Do you optimise for memory access patterns? Or maybe you have some story to share? Let us know in comments.You can also have a look and join discussions in those places:",cpp
9,"Today I have one use case for you: how to declare a const collection of unique pointers of polymorphic types? Can we use std::vector? or maybe std::array? What are the options here? What if we’d like to have such collection as a class member? Have a look in the article.Here’s the code idea:struct Base { virtual ~Base() = default; virtual void doStuff() = 0; };
struct A : Base { void doStuff() override { } };
struct B : Base { void doStuff() override { } };
struct C : Base { void doStuff() override { } };As you can see, we have a bunch of derived classes that implement doStuff() virtual function. We’d like to build a collection of pointers to Base, so that we can call the function polymorphically. To be precise: we want a const collection, but objects inside won’t be const. In other words, I don’t want to add/remove things from the collection, but I want to call non-const member functions on the objects - something like a pool of objects to reuse.Originally I had this use case for my algorithm visualisation application, where I needed a collection of pointers to Algorithm classes (see another post “Use the Force, Luke”… or Modern C++ Tools). Each class represents a different sorting algorithm, and throughout the lifetime users could switch from one algorithm to another. The number of algorithms is fixed at the start of the program.We can of course do this:Base* const collectionRaw[] = { new A(), new B(), new C()};
collectionRaw[0]->doStuff(); // test call

// ...
// remember to ""delete"" each array member of collectionRaw!But let’s not go that way, as it’s definitely not modern C++.What are the options then?How about unique_ptr? This type of smart pointer allows us to use RAII and wraps the raw pointer. Also it will destroy it for us. If you’re not convinced, you can also read my older article called:  5 ways how unique_ptr enhances resource safety in your code.We can easily change the code into:const std::unique_ptr<Base> rawArr[] = {
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    };

rawArr[0]->doStuff();That’s great, and we have a simple const array. What if we complicate things a bit?In my first use case, I need to have such an array as a class member. The class represents the “Application State”.Shouldn’t be a big deal, let’s write:struct MyClass {    
    const std::unique_ptr<Base> m_rawArr[] = {
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    };
};Unfortunately in GCC it gives me:main.cpp:13:33: warning: ISO C++ forbids flexible array member 'm_rawArr' [-Wpedantic]To avoid that we have to provide the size of the array:struct MyClass {    
    const std::unique_ptr<Base> m_rawArr[3] = {
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    };
};Now it compiles.Hmm… but cannot the compiler extract the information about the size of my array. Shouldn’t that be simple?I’d really like to avoid the need to provide a number of elements. In the final application, you might add or remove items from the collection (at compile time), so you’d always have to remember about changing the parameter. In our code it’s [3]…, and since it’s a magic number, we’d probably want to extract that to some constant value.How about std::array? It has CTAD since C++17 so that it could deduce all the template types…Unfortunately, we cannot use std::array either, as in our initialiser list I use different types, so the compiler won’t deduce the proper type… plus CTAD is not allowed for non-static data member initialisation.That’s why we have the same problem as with a regular array, where we have to provide the number of elements:struct MyClassArr {
    const std::array<std::unique_ptr<Base>, 3> m_arr = {
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    };
};How about std::vector?std::vector will allocate extra memory on the heap, but if that’s not a big issue for us.  Let’s try that:struct MyClassVec {
    const std::vector<std::unique_ptr<Base>> m_vec = {
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    };
};Super cool! We don’t need to specify the number of elements… but will that compile?Eh…You can try to read the full message…TLDR:  we cannot use the initializer list to init a vector with moveable only types. We have two options here:Using shred_ptr might be the most comfortable option, but here we need to pay the price of additional reference counting mechanism, plus it also changes the meaning of our class. I’m not in favour of such an approach, so let’s stick with unique_ptr.We have to implement a method that would solve the issue with moveable only types.So let’s try to come up with some handy function that would create such a vector for us:template<typename T, typename... Args>
auto initFromMoveable(Args&&... args)
{
    std::vector<std::unique_ptr<T>> vec;
    vec.reserve(sizeof...(Args)); 
    (vec.emplace_back(std::forward<Args>(args)), ...);
    return vec;
}

struct MyClassVecFunc {
    const std::vector<std::unique_ptr<Base>> m_vec = initFromMoveable<Base>(
        std::make_unique<A>(),
        std::make_unique<B>(),
        std::make_unique<C>()
    );
};That’s nice!We pay the price of vector creation and memory allocation, but we don’t have to specify the number of objects!Note that I used a few modern C++ things here:template<typename Key, typename T, typename... Args>
auto initMapFromMoveable(Args&&... args)
{
    map<Key, unique_ptr<T>> map;
    (map.emplace(forward<Args>(args)), ...);
    return map;
}

struct MyClassMapFunc {
    const map<int, unique_ptr<Base>> m_map = initMapFromMoveable<int, Base>(
        pair{ 10, make_unique<A>() },
        pair{ 11, make_unique<B>() },
        pair{ 12, make_unique<C>() }
    );
};The main reason for using pointers in the collection was to be able to call DoStuff() polymorphically.However, since C++17, we have another way: using std::variant and std::visit to perform polymorphism. What’s more, rather than with pointers, we can now work with regular value types.Here’s a basic example for our use case:using ElementType = std::variant<A, B, C>
const std::vector<ElementType> collection { A{}, B{}, C{}};

auto DoStuffCaller = [](auto& obj) { return obj.DoStuff(); };
std::visit(DoStuffCaller, collection[id]);As you can see in the example, I used std::variant to build the collection and then call std::visit with a callable object that then invokes doStuff().But… can you spot a semantic problem here?...The whole collection is now const, so the elements inside are also const. And I cannot call non-const methods there.While the whole idea is promising, it doesn’t work for my use case. Unless maybe, I create something like a custom const collection that blocks adding/removing elements but allows changing them.And you can read about std::visit and std::variant in my separate blog posts, for example: Everything You Need to Know About std::variant from C++17.When I started messing around with those arrays, vectors, pointers, I noticed that I might miss an important design decision: Do I need all of those objects to be alive all the time?If the creation of an object costs a lot, then it’s probably fine to have a “pool” of such objects. However, in my case, my classes were simple things. It was easy to create and destroy them on demand. And such event occurs maybe several times per minute (when a user switches between menu entries).Another reason for having several objects might be when you need all of them to be active at the same time. For example, if you have a collection of game actors, you need to Update() them and maybe Render() later. In my case, it was only one algorithm visualisation class that is active at a given time.So… why not throw away all of that complicated stuff with arrays, moveable only types… and just have:std::unique_ptr<Base> m_currentObject;To sum up:If you want to init a const collection of unique_ptr on the stack:But if you want to do that as a class member.Extra: you can also have a look at std::variant which enables to use of polymorphic classes but with value types.But, it’s also essential to think about the design of the whole problem. In my case, I didn’t need a collection, so having only a single pointer was good enough.Source code:http://coliru.stacked-crooked.com/a/9617f4f94e90257c 
with a map: http://coliru.stacked-crooked.com/a/a498115cdd3075aa",cpp
10,"With modern C++ and with each revision of the standard we get more comfortable way to initialise fields of a class: both static and non-static: there’s non-static data member initialisation (from C++11) and also inline variables (for static members since C++17).In this blog post, you’ll learn how to use the syntax and how it changed over the years from C++11, through C++14, C++17 until C++20.Updated: 2nd March 2020.Before C++11,  if you had a class member, you could only initialise it with a default value through the initialisation list in a constructor.// pre C++11 class:
struct SimpleType {
    int field;
    std::string name;

    SimpleType() : field(0), name(""Hello World"") { }
}Since C++11, the syntax is improved, and you can initialise field and name in the place of the declaration:// since C++11:
struct SimpleType {
    int field = 0;                        // works now!
    std::string name { ""Hello World ""} // alternate way with { }

    SimpleType() { }
}As you can see, the variables get their default value in the place of declaration. There’s no need to set values inside a constructor.The feature is called * non-static data member initialisation*, or NSDMI in short.What’s more, since  C++17, we can initialise static data  members thanks to inline variables:struct OtherType {
    static const int value = 10;
    static inline std::string className = ""Hello Class"";

    OtherType() { }
}Now, there’s no need to define className in a corresponding cpp file. The compiler guarantees that all compilation units will see only one definition of the static member. Previously, before C++17, you had to put the definition in one of cpp files.And note, that for constant integer static fields (value), we could initialise them “in place” even in C++98.Let’s explore those useful features: NSDMI and inline variables. We’ll see the examples and how the features improved over the years.In short, the compiler performs the initialisation of your fields as you’d write it in the constructor initialiser list.SimpleType() : field(0) { }Let’s see this in detail:With a little “machinery” we can see when the compiler performs the initialisation.Let’s consider the following  type:struct SimpleType
{
    int a { initA() }; 
    int b { initB() }; 

    // ...
};The implementation of  initA() and initB() functions have side effects and they log extra messages::int initA() {
    std::cout << ""initA() called\n"";
    return 1;
}

std::string initB() {
    std::cout << ""initB() called\n"";
    return ""Hello"";
}This allows us to see when the code is called.For example:struct SimpleType
{
    int a { initA() }; 
    std::string b { initB() }; 

    SimpleType() { }
    SimpleType(int x) : a(x) { }
};And the use:std::cout << ""SimpleType t10\n"";    
SimpleType t0;
std::cout << ""SimpleType t1(10)\n"";    
SimpleType t1(10);The output:SimpleType t0:
initA() called
initB() called
SimpleType t1(10):
initB() calledt0 is default initialised, therefore both of the fields are initialised with their default value.In the second case, for t1, only one value is default initialised, and the other one comes from the constructor parameter.As you might already guess, the compiler performs the initialisation of the fields as if the fields were initialised in a “member initialisation list”. So they get the default values before the body of the constructor is invoked.In other words the compiler expands the  code:int a { initA() }; 
std::string b { initB() }; 

SimpleType() { }
SimpleType(int x) : a(x) { }intoint a; 
std::string b; 

SimpleType() : a(initA()), b(initB()) { }
SimpleType(int x) : a(x), b(initB())  { }How about other constructors?The compiler performs the initialisation of the fields in all constructors, including copy and move constructors. However, when a copy or move constructor is default, then there’s no need to perform that extra initialisation.See the examples:struct SimpleType
{        
    int a { initA() }; 
    std::string b { initB() };

    SimpleType() { }

    SimpleType(const SimpleType& other) {
        std::cout << ""copy ctor\n"";

        a = other.a;
        b = other.b;
    };

};And the use case:SimpleType t1;
std::cout << ""SimpleType t2 = t1:\n"";
SimpleType t2 = t1;The output:SimpleType t1:
initA() called
initB() called
SimpleType t2 = t1:
initA() called
initB() called
copy ctorSee code here @Wandbox.In the above example, the compiler initialised the fields with their default values. That’s why it’s better to also use the initialiser list inside a copy constructor:SimpleType(const SimpleType& other) : a(other.a), b(other.b) {
        std::cout << ""copy ctor\n"";
    };We get:SimpleType t1:
initA() called
initB() called
SimpleType t2 = t1:
copy ctorThe same happens if you rely on the default copy constructor generated by the compiler:SimpleType(const SimpleType& other) = default;The same thing happens for a move constructor.It’s hard to come up with drawbacks, but let’s try:Do you see any other issues?Originally, in C++11, if you used default member initialisation then your class couldn’t be an agregate type:struct Point { float x = 0.0f; float y = 0.0f; };

// won't compile in C++11
Point myPt { 10.0f, 11.0f};I was not aware of this issue, but Shafik Yaghmour noted that in the comments below the article.In C++11 spec did not allow aggregate types to have such initialisation, but in C++14 this requirement was removed. Link to the StackOverflow question with detailsFortunately, it’s fixed in C++14, so Point myPt { 10.0f, 11.0f};Compiles as expected, see @WandboxSince C++11 the code only considered “regular” fields… but how about bit fields in a class?class Type {
    unsigned int value : 4;
};This is only a recent change in C++20 that allows you to write:class Type {
    unsigned int value : 4 = 0;
    unsigned int second : 4 { 10 };
};The proposal that was accepted into C++20 is Default Bit Field Initialiser for C++20 P0683.So far, we talked about non-static data members. Do we have any improvements for declaring and initialising static variables in a class?In C++11/14 you had to define a variable in a corresponding cpp file:// a header file:
struct OtherType {
    static int classCounter;

    // ...
};

// implementation, cpp file
int OtherType::classCounter = 0;Fortunately with C++17 we also got inline variables, that means you can define a static inline variable inside a class, without the need to define them in a cpp file.// a header file, C++17:
struct OtherType {
    static inline int classCounter = 0;

    // ...
};The compiler guarantees that there’s precisely one definition of this static variable for all translation units that include the declaration of the class. Inline variables are still static class variables so that they will be initialised before the main() function is called (You can read more in my separate article What happens to your static variables at the start of the program?).The feature makes it much easier to develop header-only libraries, as there’s no need to create cpp files for static variables or use some hacks to keep them in a header file.Here’s the full example at @WandboxSince we can declare and initialise a variable inside a class, there’s an interesting question about auto. Can we use it? It seems quite a natural way and would follow the AAA (Almost Always Auto) rule.You can use auto for static variables:class Type {
    static inline auto theMeaningOfLife = 42; // int deduced
};But not as a class non-static member:class Type {
    auto myField { 0 };   // error
    auto param { 10.5f }; // error  
};Unfortunately, auto is not supported. For example in GCC I geterror: non-static data member declared with placeholder 'auto'While static members are just static variables and that’s why it’s relatively easy for the compiler to deduce the type, it’s not that easy for regular members. Mostly because of a possibility of cyclic dependencies of types and the class layout. If you’re interested in the full story, you can read this great explanation at cor3ntin blog: The case for Auto Non-Static Data Member Initializers | cor3ntin.Similarly, as with auto we also have limitations with non-static member variables and CTAD:It works for static variables:class Type {
    static inline std::vector ints { 1, 2, 3, 4, 5, 6, 7}; // deduced vector<int>
};But not as a non-static-member:class Type {
    std::vector ints { 1, 2, 3, 4, 5, 6, 7}; // error!
};On GCC 10.0 I geterror: 'vector' does not name a type
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in Modern C++, check it out here:In this article, we reviewed how in-class member initialisation changed with Modern C++.In C++11, we got NSDMI - non-static data member initialisation. You can now declare a member variable and init that with a default value. The initialisation will happen before each constructor body is called, in the constructor initialisation list.NSDMI improved with C++14 (aggregates) and in C++20 (bit fields are now supported).What’s more in C++17 we got inline variables, which means you can declare and initialise a static member without the need to do that in a corresponding cpp file.Here’s a “summary” example that combines the features: struct Window
{        
    inline static unsigned int default_width = 1028;
    inline static unsigned int default_height = 768;

    unsigned int _width { default_width };
    unsigned int _height { default_height };
    unsigned int _flags : 4 { 0 };
    std::string _title { ""Default Window"" };

    Window() { }
    Window(std::string title) : _title(std::move(title)) { }
    // ...
};Play at @Wandbox For simplicity default_width and default_height are static variables that might be loaded, for example, from a configuration file, and then be used to initialise a default Window state.Do you use NSDMI in your projects? Do you use static Inline variables as class members?Do you use it in your code?",cpp
11,"In C++20, we have a new and cool way to do text formatting. It’s more like Python style and combines C-Style printf and with modern C++ type-safety. In this guest post written by the author of the proposal - Victor Zverovich - you’ll learn how to use this new technique!This is a guest post from Victor Zverovich.Victor is a software engineer at Facebook working on the Thrift RPC framework and the author of the popular {fmt} library, a subset of which is proposed into C++20 as a new formatting facility. He is passionate about open-source software, designing good APIs, and science fiction.You can find Victor online on Twitter, StackOverflow, and GitHub.Victor originally wrote that blog post for Fluent C++, but this one is heavily updated with the information about C++20.(with apologies to Stanisław Lem)Consider the following use case: you are developing the Enteropia[2]-first Sepulka[3]-as-a-Service (SaaS) platform and have server code written in C++ that checks the value of requested sepulka’s squishiness received over the wire and, if the value is invalid, logs it and returns an error to the client. Squishiness is passed as a single byte and you want to format it as a 2-digit hexadecimal integer, because that is, of course, the Ardrite[1] National Standards Institute (ANSI) standard representation of squishiness. You decide to try different formatting facilities provided by C++ and decide which one to use for logging.First you try iostreams:#include <cstdint>
#include <iomanip>
#include <iostream>

void log_error(std::ostream& log, std::uint_least8_t squishiness) {
  log << ""Invalid squishiness: ""
      << std::setfill('0') << std::setw(2) << std::hex
      << squishiness << ""\n"";
}The code is a bit verbose, isn’t it? You also need to pull in an additional header, <iomanip>, to do even basic formatting. But that’s not a big deal.However, when you try to test this code (inhabitants of Enteropia have an unusual tradition of testing their logging code), you find out that the code doesn’t do what you want. For example,log_error(std::cout, 10);printsInvalid squishiness: 0Which is surprising for two reasons: first it prints one character instead of two and second the printed value is wrong. After a bit of debugging, you figure out that iostreams treat the value as a character on your platform and that the extra newline in your log is not a coincidence. An even worse scenario is that it works on your system, but not on the one of your most beloved customers.So you add a cast to fix this which makes the code even more verbose (see the code @Compiler Explorer)log << ""Invalid squishiness: ""
    << std::setfill('0') << std::setw(2) << std::hex
    << static_cast<unsigned>(squishiness) << ""\n"";Can the Ardrites do better than that?Yes, they can.Surprisingly, the answer comes from the ancient 1960s (Gregorian calendar) Earth technology, format strings (in a way, this is similar to the story of coroutines). C++ had this technology all along in the form of the printf family of functions and later rediscovered in std::put_time.What makes format strings so useful is expressiveness. With a very simple mini-language, you can easily express complex formatting requirements. To illustrate this, let’s rewrite the example above using printf:#include <cstdint>
#include <cstdio>

void log_error(std::FILE* log, std::uint_least8_t squishiness) {
  std::fprintf(log, ""Invalid squishiness: %02x\n"", squishiness);
}Isn’t it beautiful in its simplicity? Even if you’ve somehow never seen printf in your life, you can learn the syntax in no time. In contrast, can you always remember which iostreams manipulator to use? Is it std::fill or std::setfill? Why std::setw and std::setprecision and not, say, std::setwidth or std::setp?A lesser-known advantage of printf is atomicity. A format string and arguments are passed to a formatting function in a single call which makes it easier to write them atomically without having an interleaved output in the case of writing from multiple threads.In contrast, with iostreams, each argument and parts of the message are fed into formatting functions separately, which makes synchronization harder. This problem was only addressed in C++20 with the introduction of an additional layer of std::basic_osyncstream.However, the C printf comes with its set of problems which iostreams addressed:Safety: C varargs are inherently unsafe, and it is a user’s responsibility to make sure that the type of information is carefully encoded in the format strings. Some compilers issue a warning if the format specification doesn’t match argument types, but only for literal strings. Without extra care, this ability is often lost when wrapping printf in another API layer such as logging. Compilers can also lie to you in these warnings.Extensibility: you cannot format objects of user-defined types with printf.With the introduction of variadic templates and constexpr in C++11, it has become possible to combine the advantages of printf and iostreams. This has finally been done in C++20 formatting facility based a popular open-source formatting library called {fmt}.Let’s implement the same logging example using C++20 std::format:#include <cstdint>
#include <format>
#include <iostream>

void log_error(std::ostream& log, std::uint_least8_t squishiness) {
  log << std::format(""Invalid squishiness: {:02x}\n"", squishiness);
}As you can see, the formatting code is similar to that of printf with a notable difference being {} used as delimiters instead of %. This allows us and the parser to find format specification boundaries easily and is particularly essential for more sophisticated formatting (e.g. formatting of date and time).Unlike standard printf, std::format supports positional arguments i.e. referring to an argument by its index separated from format specifiers by the : character:log << std::format(""Invalid squishiness: {0:02x}\n"", squishiness);Positional arguments allow using the same argument multiple times.Otherwise, the format syntax of std::format which is largely borrowed from Python is very similar to printf’s. In this case format specifications are identical (02x) and have the same semantics, namely, format a 2-digit integer in hexadecimal with zero padding.But because std::format is based on variadic templates instead of C varargs and is fully type-aware (and type-safe), it simplifies the syntax even further by getting rid of all the numerous printf specifiers that only exist to convey the type information. The printf example from earlier is in fact incorrect exhibiting an undefined behaviour. Strictly speaking, it should have been#include <cinttypes> // for PRIxLEAST8
#include <cstdint>
#include <cstdio>

void log_error(std::FILE* log, std::uint_least8_t squishiness) {
  std::fprintf(log, ""Invalid squishiness: %02"" PRIxLEAST8 ""\n"",
               squishiness);
}Which doesn’t look as appealing. More importantly, the use of macros is considered inappropriate in a civilized Ardrite society.Here is a (possibly incomplete) list of specifiers made obsolete: hh, h, l, ll, L, z, j, t, I, I32, I64, q, as well as a zoo of 84 macros:In fact, even x in the std::format example is not an integer type specifier, but a hexadecimal format specifier, because the information that the argument is an integer is preserved. This allows omitting all format specifiers altogether to get the default (decimal for integers) formatting:log << std::format(""Invalid squishiness: {}\n"", squishiness);Following a popular trend in the Ardrite software development community, you decide to switch all your code from std::uint_least8_t to something stronger-typed and introduced the squishiness type:enum class squishiness : std::uint_least8_t {};Also, you decide that you always want to use ANSI-standard formatting of squishiness which will hopefully allow you to hide all the ugliness in operator<<:std::ostream& operator<<(std::ostream& os, squishiness s) {
  return os << std::setfill('0') << std::setw(2) << std::hex
            << static_cast<unsigned>(s);
}Now your logging function looks much simpler:void log_error(std::ostream& log, squishiness s) {
  log << ""Invalid squishiness: "" << s << ""\n"";
}Then you decide to add another important piece of information, sepulka security number (SSN) to the log, although you are afraid it might not pass the review because of privacy concerns:void log_error(std::ostream& log, squishiness s, unsigned ssn) {
  log << ""Invalid squishiness: "" << s << "", ssn="" << ssn << ""\n"";
}To your surprise, SSN values in the log are wrong, for example:log_error(std::cout, squishiness(0x42), 12345);givesInvalid squishiness: 42, ssn=3039After another debugging session, you realize that the std::hex flag is sticky, and SSN ends up being formatted in hexadecimal. So you have to change your overloaded operator<< tostd::ostream& operator<<(std::ostream& os, squishiness s) {
  std::ios_base::fmtflags f(os.flags());
  os << std::setfill('0') << std::setw(2) << std::hex
     << static_cast<unsigned>(s);
  os.flags(f);
  return os;
}A pretty complicated piece of code just to print out an SSN in decimal format.std::format follows a more functional approach and doesn’t share formatting state between the calls. This makes reasoning about formatting easier and brings performance benefits because you don’t need to save/check/restore state all the time.To make squishiness objects formattable you just need to specialize the formatter template and you can reuse existing formatters:#include <format>
#include <ostream>

template <>
struct std::formatter<squishiness> : std::formatter<unsigned> {
  auto format(squishiness s, format_context& ctx) {
    return format_to(ctx.out(), ""{:02x}"", static_cast<unsigned>(s));
  }
};

void log_error(std::ostream& log, squishiness s, unsigned ssn) {
  log << std::format(""Invalid squishiness: {}, ssn={}\n"", s, ssn);
}You can see the message ""Invalid squishiness: {}, ssn={}\n"" as a whole, not interleaved with <<, which is more readable and less error-prone.Now you decide that you don’t want to log everything to a stream but use your system’s logging API instead. All your servers run the popular on Enteropia GNU/systemd operating system where GNU stands for GNU’s, not Ubuntu, so you implement logging via its journal API. Unfortunately, the journal API is very user-unfriendly and unsafe. So you end up wrapping it in a type-safe layer and making it more generic:#include <systemd/sd-journal.h>
#include <format> // no need for <ostream> anymore

void vlog_error(std::string_view format_str, std::format_args args) {
  sd_journal_send(""MESSAGE=%s"", std::vformat(format_str, args).c_str(),
                  ""PRIORITY=%i"", LOG_ERR, nullptr);
}

template <typename... Args>
inline void log_error(std::string_view format_str,
                      const Args&... args) {
  vlog_error(format_str, std::make_format_args(args...));
}Now you can use log_error as any other formatting function and it will log to the system journal:log_error(""Invalid squishiness: {}, ssn={}\n"",
          squishiness(0x42), 12345);The reason why we don’t directly call sd_journal_send in log_error, but rather have the intermediary vlog_error is to make vlog_error a normal function rather than a template and avoiding instantiations for all the combinations of argument types passed to it. This dramatically reduces binary code size. log_error is a template but because it is inlined and doesn’t do anything other than capturing the arguments, it doesn’t add much to the code size either.The std::vformat function performs the actual formatting and returns the result as a string which you then pass to sd_journal_send. You can avoid string construction with std::vformat_to which writes to an output iterator, but this code is not performance critical, so you decide to leave it as is.Finally you decide to log how long a request took and find out that std::format makes it super easy too:void log_request_duration(std::ostream& log,
                                std::chrono::milliseconds ms) {
  log << std::format(""Processed request in {}."", ms);
}This writes both the duration and its time units, for example:Processed request in 42ms.std::forma supports formatting not just durations but all chrono date and time types via expressive format specifications based on strftime, for example:std::format(""Logged at {:%F %T} UTC."",
            std::chrono::system_clock::now());In the process of developing your SaaS system you’ve learnt about the features of C++20 std::format, namely format strings, positional arguments, date and time formatting, extensibility for user-defined types as well as different output targets and statelessness, and how they compare to the earlier formatting facilities.Note to Earthlings: your standard libraries may not yet implement C++20 std::format but don’t panic: all of these features and much more are available in the open-source {fmt} library}. Some additional features include:All of the examples will work in{fmt} with minimal changes, mostly replacing std::format with fmt::format and <format> with <fmt/core.h> or other relevant include.The picture and references come from the book ""Star Diaries"" by Stanislaw Lem.",cpp
12,"Continuing the tradition for other ISO C++ Meetings, I prepared a blog post where you’ll learn about:Let’s start!Disclaimer: the view presented here is mine and does not represent the opinion of the ISO C++ Committee.Here’s a short list of things that are in the new standard:You can also read my previous blog post about the Belfast meeting or have a look at the C++ at the end of the year article, where I listed a few more parts.There’s also a C++20 Reference Card: https://www.bfilipek.com/2020/01/cpp20refcard.htmlThe meeting might already start my city - Cracow - is in the same time zone as Prague. The event is mostly about solving the national body comments for the Standard, so we won’t see any new features… and hopefully, we also shouldn’t see any removals. Since last year, the Cologne meeting the Standard is now in the feature freeze mode.If time allows the committee will discuss papers that target C++23 and beyond.The next meeting - where the C++20 draft will be ready for the last publication efforts - will be in Varna (Bulgaria). Probably during the meeting, the committee will discuss new things for C++23, and maybe some of the new parts will be voted in.You can always find the list of ISO meetings here: 
Upcoming Meetings, Past Meetings: Standard C++The papers (mailings) for meeting “Pre-Prague” can be found under the following link: 
JTC1/SC22/WG21 - mailing2020-01.or in a easier-to read form:There are so many papers that it’s tough to keep up with all of them, but below you can find a few that caught my attention. I tried to skip the “big” things and focus on something maybe less attractive, but still important.Let’s start with something scary - Spectre!P0928R1To maximise the performance, in most modern CPUs, we have various forms of code speculations. The most common technique is through a branch predictor. The CPU tries to predict which path of an if statement will be executed and then runs it ahead. When the result of the condition is the same as the prediction, then we have a win situation. But in the other case, the CPU has to “revert” and execute the correct branch.The result of that “guess” execution, even if it’s to be forgotten by CPU can be observed by various side channels. In some cases, it’s very unsafe - especially when you can observe some critical/private data.Now, most of CPU has fixed the issues, via a system patch or even hardware solutions. But maybe it’s better to have fine-grain control over that fix?In our code, a lot of places are not sensitive to such data leakage, and we don’t want to pay the price of reduced performance.The paper shows several code examples, in C++, that explain some unsafe code and its risks. The authors also discuss a possible mechanism that would allow developers to get the best performance while keeping the critical code parts protected.One solution might be extra attributes: like [[​speculative_load_hardening​(​true​)]] that would then translate to instructions like __mm_lfence​(); or some forms of “Speculative Load Hardening”.I think the proposal might be quite crucial as it allows you to have more control over the system. I’d like to see a regular code to be “spectre safe” by default, but if I want, I can skip that extra safety and allow a bit more performance. Of course, the important bit here is that you have to be a real security expert if you want to allow that unsafe path and be sure about the safety of your code.P2043R0Since the introduction of constexpr we can execute more and more code at compile time. But sometimes it feels unnatural and hard due to the limitations and complexity. It’s also hard for non-experts to fully leverage the capabilities of the constexpr metaprogramming model.But what if we could execute all code at compile time? With just a tiny change in the code?The paper describes how we could use a really interesting C++17 compatible compiler that allows some powerful features (reflection, pattern matching!) plus the @meta code execution!It’s called CircleThe example that shows the core capabilities, and might be good advertisements is as follows:#include <iostream>

@meta std::cout << ""Hello at compile time!"" << std::endl;
int main() { 
    std::cout << ""Hello at run time!"" << std::endl; 
}And then when compiling:$ circle test.cpp
Hello at compile time!
$ ./test
Hello at run time!As you can see std::cout or stream operators are not redefined with constexpr, but the compiler knows how to execute them at compile time. The trick is to enable special compiler runtime to handle the code.You can also have a look at this CppCast episode with the author of the whole project Baxter - see here: Cicrle with Sean Baxter - CppCastOf course, I don’t expect to throw away all constexpr code and move to Circle model for C++23. Still, we might get some good lessons on how to make code more natural for compile-time evaluations and also improve the learning/teaching experience. What do you think? Do you like the proposed alternative to constexpr?Another paper which is linked to Circle P2062R0 and tries to extract some essential parts from that model.P2077R0Following the addition of heterogeneous lookup for ordered containers in C++14 (see my post about that for C++14) and also for unordered containers in C++20, we can now think about extending that approach for other member functions. One of the best examples is that we can use string_view or const char* to find or erase elements in the container where the key is std::string - there’s no need to create extra copies of the string object, just for the comparison.The paper proposes to add new overloads for the .erase() functions.The authors also show the performance improvements of around 20% when using the new approach.One problematic thing is that there’s an overload for const iterator and iterator, so the new overloads must reject such cases, The compare object must also have is_transparent subtype exposed, similar as for the heterogeneous lookup. And for unordered containers we need Hash::transparent_key_equal to be exposed.P2073R0This is an interesting paper that shows some real issues with working with coroutines. This early adoption paper might help the compiler teams to improve their support and focus on the core parts of the developer experience.The authors ported a web socket server into coroutines and shared their experience. They used early GCC implementation and Visual Studio 2019 16.5.For the debugging the authors stresses the importance of having visible local coroutine values and input arguments. Ability to seat a breakpoint inside a coroutine, or see promise_type object of the currently running coroutine.I think it’s good to see such reports as they will definitely help when the C++20 is ready and shipped in our favourite toolchains. It’s not just the compiler that should work, but also debugger and even source code editors that are important for our productivity.P2025R0Since C++17 we have the guarantee that “copy elision” will happen for more or less unnamed objects returned from a function. For examplewidget setup_widget(int x) {
  return widget(x);
}But if you want a named returned value optimisation (NRVO) then there’s no guarantee, most of the time the compiler can omit the copy, but still, the type has to be copyable.The authors discuss options to enable NRVO and guarantee it.For example for cases likewidget setup_widget(int x) {
  widget w;
  w.set_x(x);
  return w;
}What are your favourite features that might be included in the next Standard?",cpp
13,"In this blog post, we’ll show you how to write a library that displays a task activity indication for multithreading applications. Have a look at several essential Modern C++ techniques and how to combine them to write good code.Let’s dive in!This article is a guest post from Pranav Srinivas Kumar:Pranav has 5+ years of industry experience in C++, focusing on safety-critical embedded software. He works at Permobil, researching on drive-assist technology for powered wheelchairs. Pranav frequently publishes hobby projects on GitHub.Progress bars and loading spinners are a valuable part of my daily life as a software engineer. Installing libraries with apt or pip? Training a neural network with TensorFlow? Copying files to an external hard drive? They’re everywhere. How long should I wait before I CTRL-C this process? Is it even doing anything? We need activity indicators. They keep us engaged - we are more likely to finish tasks when there is a clear indication of progress. Here’s a page from Apple’s Human Interface Guidelines wiki regarding progress indicators.Inspired by tqdm and indicatif, I’ve recently published a library called indicators that provides configurable activity indicators for use in C++ command-line applications. In this post, I’ll present a minimal implementation of two indicators: ProgressBar and MultiProgress. ProgressBar will provide an interface to model and manage a single, thread-safe progress bar. MultiProgress will provide an interface to manage multiple progress bars simultaneously. Although the indicators library supports C++11 and higher, we will assume C++17 support for this post.Let’s set some expectations. Our progress bar must be:Let’s assume progress is measured as a float in [0.0f, 100.0f] with the semantics: 25.0f implies 25% completed. We can provide an .set_progress(float) method that users can use to update the progress bar state.#include <atomic>
#include <mutex>
#include <iostream>

class ProgressBar {
public: 
  void set_progress(float value) {
    std::unique_lock lock{mutex_};  // CTAD (C++17)
    progress_ = value;
  }

private:
  std::mutex mutex_;
  float progress_{0.0f};
};Now, let’s focus on the layout. We want a progress bar that (1) spans a specific width, (2) progresses from left to right, (3) shows percentage completion, and (4) maybe shows some status text. Here’s a minimalist design:[{...completed} {remaining...}] {percentage} {status_text}
 ◄-------- Bar Width --------►

Example:
[■■■■■■■■■■■■■■■■■■■■■■-------] 71% Extracting ArchiveBelow are some setters that users can use to configure our progress bar. Note the use of std::unique_lock - we want to be able to change properties like status_text from multiple threads based on application state. public:
  // [...]

  void set_bar_width(size_t width) {
    std::unique_lock lock{mutex_};
    bar_width_ = width;    
  }

  void fill_bar_progress_with(const std::string& chars) {
    std::unique_lock lock{mutex_};
    fill_ = chars;    
  }

  void fill_bar_remainder_with(const std::string& chars) {
    std::unique_lock lock{mutex_};
    remainder_ = chars;    
  }

  void set_status_text(const std::string& status) {
    std::unique_lock lock{mutex_};
    status_text_ = status;    
  }

private:
  // [...]

  size_t bar_width_{60};
  std::string fill_{""#""}, remainder_{"" ""}, status_text_{""""};  If the width of our bar is 60 characters, then the completed portion of our bar should span 60 * progress_ / 100 characters. We can use this logic in a .write_progress() to write our bar to a stream, e.g., console.Let’s add an .update method that sets the progress and immediately prints the bar to the stream. public:   
  // [...]

  void update(float value, std::ostream &os = std::cout) {
    set_progress(value);
    write_progress(os);
  }

  void write_progress(std::ostream &os = std::cout) {
    std::unique_lock lock{mutex_};

    // No need to write once progress is 100%
    if (progress_ > 100.0f) return;

    // Move cursor to the first position on the same line and flush 
    os << ""\r"" << std::flush;

    // Start bar
    os << ""["";

    const auto completed = static_cast<size_t>(progress_ * static_cast<float>(bar_width_) / 100.0);
    for (size_t i = 0; i < bar_width_; ++i) {
      if (i <= completed) 
        os << fill_;
      else 
        os << remainder_;
    }

    // End bar
    os << ""]"";

    // Write progress percentage
    os << "" "" << std::min(static_cast<size_t>(progress_), size_t(100)) << ""%""; 

    // Write status text
    os << "" "" << status_text_;
  }We’re choosing to use std::ostream here so we can use this class for unit testing, mocking, and writing to log files.Note that use of os << ""\r"" <<. We don’t want to print our progress bar in a newline after each change; we want to update the progress bar in-place. So, we use the RETURN character to go back to the first position on the same line. Time to test this out. Let’s write a simple program that configures a ProgressBar object and updates its state. For a little extra bling, I’m going to use the excellent termcolor library.#include ""progress_bar.hpp""
#include ""termcolor.hpp""
#include <thread>

int main() {
  std::cout << termcolor::bold << termcolor::yellow;

  ProgressBar bar;
  bar.set_bar_width(50);
  bar.fill_bar_progress_with(""■"");
  bar.fill_bar_remainder_with("" "");

  for (size_t i = 1; i <= 100; ++i) {
    bar.update(i);
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
  }

  std::cout << termcolor::reset;
}Great. We have a thread-safe progress bar class that is reasonably configurable. How do we handle more than one? As it stands, if we use more than one progress bar, their stdout will overlap.We need a management class that can refer to multiple progress bars and prints them nicely - one bar per line to the console. Something like Docker’s parallel download progress bars:Here are some design considerations: For simplicity, let’s assume that our MultiProgress class manages a fixed number of progress bars and this number is known at compile-time, e.g., MultiProgress<3> bars;I like the idea of our MultiProgress class not owning the progress bars but simply referring to them. This way, we can construct progress bars and use them as is or as part of a multi-progress bar indicator (or both). So how do we achieve this? Based on the above docker example, we know the MultiProgress class needs to hold a container, e.g., an array of indicators. We don’t want to store raw pointers to progress bars. We also can’t use a vector of references; the component type of containers like vectors needs to be assignable and references are not assignable. We can use std::reference_wrapper instead. reference_wrapper<T> is a CopyConstructible and Assignable wrapper around a reference to an object of type T. Instances of std::reference_wrapper<T> are objects (they can be copied or stored in containers) but they are implicitly convertible to T&, so that they can be used as arguments with the functions that take the underlying type by reference. Let’s allow the user to specify the number of progress bars to manage and have the user also provide references to each bar in the constructor:#include <atomic>
#include <mutex>
#include <functional>
#include <array>
#include <iostream>

template <typename Indicator, size_t count>
class MultiProgress {
public:
  template <typename... Indicators,
              typename = typename std::enable_if_t<(sizeof...(Indicators) == count)>>
  explicit MultiProgress(Indicators &... bars) : bars_({bars...}) {}

private:
  std::array<std::reference_wrapper<Indicator>, count> bars_;
};Note that MultiProgress takes a template Indicator. This allows for easily extending this class to support other types of progress indicators, e.g., progress spinners, block progress bars, or other specializations.Also note that our use of std::reference_wrapper comes with a hidden assumption - the Indicators referred to by a MultiProgress object need to outlast the MultiProgress object itself. Else our bars_ array will be referring to objects that are already destroyed. Constructing MultiProgress now looks like below. This object is configured for exactly 3 bars - the constructor will accept exactly 3 arguments and the object will hold references to these bars.MultiProgress<ProgressBar, 3> bars(bar1, bar2, bar3);Our .update method will simply loop over all the bars we’re managing and call each one’s .set_progress method.// multi_progress.hpp
// [...]
public:
  template <size_t index>
  typename std::enable_if_t<(index >= 0 && index < count), void> 
  update(float value, std::ostream &os = std::cout) {
    bars_[index].get().set_progress(value);
  }Okay, now our code can update the progress of each bar. We aren’t printing anything yet, though.Let’s work on printing all these bars. We need to iterate over each bar and print its progress. When printing repeatedly, we need to move the cursor up some number of lines (once for each bar) before printing the bars. This is to ensure that we’re printing “in place” - to give the effect the we’re updating that bar. Not doing this will cause the .write_progress to keep printing in new lines.public:
  template <size_t index>
  typename std::enable_if<(index >= 0 && index < count), void>::type 
  update(float value, std::ostream &os = std::cout) {
    // [...]
    write_progress(os);
  }

  void write_progress(std::ostream &os = std::cout) {
    std::unique_lock lock{mutex_};

    // Move cursor up if needed
    if (started_)
      for (size_t i = 0; i < count; ++i)
        os << ""\x1b[A"";

    // Write each bar
    for (auto &bar : bars_) {
      bar.get().write_progress();
      os << ""\n"";
    }

    if (!started_)
      started_ = true;
  }

private:
  // [...]
  std::mutex mutex_;
  std::atomic<bool> started_{false};Note that we’re simply reusing code written in the ProgressBar class - set_progress and write_progress.Time to test this out. Let’s create three progress bars: bar1, bar2, and bar3. Create a MultiProgress object for managing these bars. We want to update the state of these bars in different threads and at different rates. In the example below, bar1 is updated every 100 ms, bar2 every 200 ms, and bar3 every 60 ms. #include ""progress_bar.hpp""
#include ""multi_progress.hpp""
#include ""termcolor.hpp""
#include <thread>

int main() {
  std::cout << termcolor::bold << termcolor::green << ""\n\n"" << std::endl;

  ProgressBar bar1, bar2, bar3;
  MultiProgress<ProgressBar, 3> bars(bar1, bar2, bar3);

  // Job for the first bar
  auto job1 = [&bars]() {
    for (size_t i = 0; i <= 100; ++i) {
      bars.update<0>(i);
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
  };

  // Job for the second bar
  auto job2 = [&bars]() {
    for (size_t i = 0; i <= 100; ++i) {
      bars.update<1>(i);
      std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
  };

  // Job for the third bar
  auto job3 = [&bars]() {
    for (size_t i = 0; i <= 100; ++i) {
      bars.update<2>(i);
      std::this_thread::sleep_for(std::chrono::milliseconds(60));
    }
  };

  std::thread first_job(job1);
  std::thread second_job(job2);
  std::thread third_job(job3);

  first_job.join();
  second_job.join();
  third_job.join();

  std::cout << termcolor::reset << std::endl;

  return 0;
}As you can imagine, it should be easy from here to add additional style-related properties to the ProgressBar class, e.g., foreground color, background color, etc. There is plenty of room to get creative. In this post, we have explored some activity indicators with C++17 - a thread-safe progress bar and a multi-progress indicator. The indicators library provides a few additional classes, e.g., block progress bars and progress spinners, along with a slightly richer interface for presenting stats, e.g., estimated time remaining. Thanks for reading!",cpp
14,"While the C++20 Standard is still being finalised and polished, we know all of its core features. At first, the new specification of the language might sound complex and overwhelming. That’s why, if you want to have an overview of the core elements and get the bigger picture, you can have a look at my new reference card.If you like, I prepared PDF which packs both language and the Standard Library features. Each item has a short description and an example if possible. Here’s what the text covers:Special thanks to the CppPolska team, Andrzej Krzemienski (akrzemi1), Łukasz R., Yehezkel B. and many others from my mailing list - for valuable feedback about the features, typos and other improvements.All of the existing subscribers of my mailing list have already got the new document, so If you want to download it just subscribe here:Please notice that along with the new ref card you’ll also get C++17 language reference card that I initially published three years ago. With this “package” you’ll quickly learn about all of the latest parts that Modern C++ acquired over the last few years.Let’s now go through some of the core parts of C++20.Constrains on the template parameters and meaningful compiler messages in a case on an error. Can also reduce the compilation time.template <class T>
concept SignedIntegral = std::is_integral_v<T> &&
                         std::is_signed_v<T>;
template <SignedIntegral T> // no SFINAE here!
void signedIntsOnly(T val) { }Also with terse syntax:void floatsOnly(std::floating_point auto fp) { }(constrained auto)The replacement of the header files! With modules, you can divide your program into logical parts.import helloworld; // contains the hello() function
int main() {
   hello(); // imported from the “helloworld” module!
}Explicit member names in the initializer expression:struct S { int a; int b; int c; };
S test {.a = 1, .b = 10, .c = 2}; Create another variable in the scope of the for loop:for (int i = 0; const auto& x : get_collection()) {   
    doSomething(x, i);   
    ++i; 
}A new keyword that specifies an immediate function – functions that produce constant values, at compile time only. In contrast to constexpr function, they cannot be called at runtime.consteval int add(int a, int b) { return a+b; }
constexpr int r = add(100, 300);Plus many more like coroutines, constinit, CTAD updates and more!Python-like formatting library in the Standard Library!auto s = std::format(""{:-^5}, {:-<5}"", 7, 9);’s` has a value of “–7–, 9—-” centred, and then left aligned 
Also supports the Chrono library and can print dates.A radical change in how we work with collections! Rather than use two iterators, we can work with a sequence represented by a single object.std::vector v { 2, 8, 4, 1, 9, 3, 7, 5, 4 };
std::ranges::sort(v);
for (auto& i: v | ranges:view::reverse) cout << i;With Ranges, we also get new algorithms, views and adapters.A non-owning contiguous sequence of elements. Unlike string_view, span is mutable and can change the elements that it points to.vector<int> vec = {1, 2, 3, 4};
span<int> spanVec (vec);
for(auto && v : spanVec) v *= v;Joining thread, semaphores, latches and barriers, Chrono library updates with calendar and timezones, source_location, erase/erase_if container functions, and many more!I hope with this concise reference card it will be easier to understand the scope of the new Standard.Do you like the new features of C++20? What’s your favourite part? Let us know in comments.",cpp
15,"In this blog post, I’d like to show you how I could quickly improve my old project with Modern C++. Thanks to using the newest compilers and free code analysis checkers you can cover and modernise a lot of code.If you have a terrible code like:float* pfloats = new float[10]; // no delete [] later! :)
int x = pfloats[0];You can quickly come up with the issues here and how to fix them. Even the basic compiler will also tell you about a narrowing conversion error from float to int.But how about some larger code samples? And your commercial projects at work? In Visual Studio 2019 16.4 (but also in VS 2015 and later) there’s code analysis functionality you can enable and have some meaningful insights about the code.For a start see this code:#include <iostream>

class SuspiciousType {
public:
    SuspiciousType() { }
    ~SuspiciousType() { std::cout << ""destructor!\n""; }

    int compute(int z) { return x + y + z; }

    int x;
    int y;
};

int main() {
    SuspiciousType st;
    float* pfloats = new float[10]{ 100.5f };
    int z = pfloats[0];
}In Visual Studio 2019, we can go to projects options and select rules that fit your needs. You can enable all of them, or focus on some smaller “profile” of the code.When I enabled the code analysis I got the following issues:For the SuspiciousType class:cpptests.cpp(5): warning C26495: Variable 'SuspiciousType::x' is uninitialized. Always initialize a member variable (type.6).
cpptests.cpp(5): warning C26455: Default constructor may not throw. Declare it 'noexcept' (f.6).
cpptests.cpp(6): warning C26432: If you define or delete any default operation in the type 'class SuspiciousType', define or delete them all (c.21).
cpptests.cpp(6): warning C26447: The function is declared 'noexcept' but calls function 'operator<<<std::char_traits<char> >()' which may throw exceptions (f.6).
cpptests.cpp(8): warning C26440: Function 'SuspiciousType::compute' can be declared 'noexcept' (f.6).And later here are the warnings for the code in the main() function:cpptests.cpp(16): warning C26462: The value pointed to by 'pfloats' is assigned only once, mark it as a pointer to const (con.4).
cpptests.cpp(17): warning C26496: The variable 'z' is assigned only once, mark it as const (con.4).
cpptests.cpp(17): warning C26481: Don't use pointer arithmetic. Use span instead (bounds.1).
cpptests.cpp(16): warning C26409: Avoid calling new and delete explicitly, use std::make_unique<T> instead (r.11).
cpptests.cpp(16): warning C26400: Do not assign the result of an allocation or a function call with an owner<T> return value to a raw pointer, use owner<T> instead (i.11).That’s quite nice!  Visual Studio reported all of the essential issues.What’s more, in many cases, when a rule comes from a C++ core guideline, you can see there’s a rule number mentioned at the end of the comment. You can open core guidelines and just look up the rule.Here’s the link to all of the guidelines: C++ Core Guidelines @GithubAnother thing is that the lines that are found to be suspicious are now shown with a green squiggle line, and when you move the mouse over those lines, you can get messages as tooltips:One note: if you cannot use the latest Visual Studio, you can also have a look at Clang Power Tools that allows you to check your code with clang-tidy integration. Have a look at this website: https://clangpowertools.com/Ok, but I wrote that lousy code intentionally, … can we use it on something “real”?At the beginning of December 2019, I dig out my old project from the studies. It’s an application that visualises sorting algorithms. I wrote it in 2005/2006 and used old C++, Win32Api and OpenGL.Here’s the app preview:Above you can see a cool animation of quick sort algorithm. The algorithm works on an array of input values and performs a single step around 30 times per second. The input data is then taken and drawn as a diagram with some reflection underneath. The green element is the currently accessed value, and the light-blue section represents the part of the array that the algorithm is working on.While the app looks nice, It has some awful ideas in the code… so please don’t blame me much :) Looking at code that I wrote so long time ago is a positive experience. Since I like the app, I decided to convert it to a VS 2019 project and then start refactoring it. For example, initially, the application didn’t have the quick sort algorithm, so I implemented it and that way I also “recalled” how to work in that system.The application uses C++03… or something like that :), so having such a “toy” is an excellent thing as you can experiment and modernise the code in many ways. It’s not massive, but it’s also not that super small (it’s around 5k LOC).Ok, back to the code analysis… can something go wrong in a project written that long time ago? Maybe I was super smart at that time, and I wrote amazing code that’s still valid in 2020? Yeah… right :)I enabled all of the code analysis warnings… and I got 956 of them!Let’s have a look at some more substantial warnings.The compiler can see that you don’t change the variable and suggests using const. 
For example, for code like:case cmYawPitchRoll: {
    float r = cos(m_fPitch);
    float x = r*sin(m_fYaw);
    float y = sin(m_fPitch);
    float z = -r*cos(m_fYaw);
    m_vTarget = VECTOR3D(x, y, z);
    m_vUp = VECTOR3D(sin(m_fRoll), cos(m_fRoll), 0.0f);
    break;
}The warning:Warning    C26496    The variable 'r' is assigned only once, mark it as const (con.4).    It can even suggest using constexpr for functions like:// ang * M_PI / 180.0f
inline float DegToRad(float a) { return a*0.01745329252f; };  
// rads * 180.0f / M_PI
inline float RadToDeg(float a) { return a*57.29577951f; };    The warning:Warning    C26497    The function 'DegToRad' could be marked constexpr if compile-time evaluation is desired (f.4).That’s a common error in my code, unfortunately! It’s easy to initialise all variables when you create a class, but then, when you add new member variables, I forgot to initialise them:For CGLFont:CGLFont(): m_FontMode(fmNone), m_iList(0), m_iTexture(0) { }But I forgot about m_fSize.The message:Warning    C26495    Variable 'CGLFont::m_fSize' is uninitialized. Always initialise a member variable (type.6).    Back in 2005, I didn’t know much about smart pointers, so I used new and delete all the time.Now in Modern C++ we should really avoid such code and Visual Studio can easily find places to be updated:g_Algorithms[ABUBBLE_SORT] = new CBubbleSortAlgorithm();
g_Algorithms[ASHAKER_SORT] = new CShakerSortAlgorithm();And the message:Warning    C26409    Avoid calling new and delete explicitly, use std::make_unique<T> instead (r.11).
The compiler can detect issues with null pointer checks and for example reported:Warning    C26429    Symbol 'avSystem' is never tested for nullness, it can be marked as not_null (f.23).Render(CAVSystem *avSystem) {
    ColorType ct;
    avSystem->BeginDrawing(1.0, (int)m_vArray.size());
    ...So I should decide if the pointer can be null in this situation or not.That’s an easy thing, but in all the places where I used NULL, I can now replace that with nullptr from C++11.There are even clang-tidy features to do that automatically.While my code used exceptions to some extent, I didn’t write consistent code in that regards. With C++11 we got noexcept, and now, for every function, we should decide what to do.In dozens of places the compiler reported:Warning    C26440    Function 'CBeat::SetTempoBPS' can be declared 'noexcept' (f.6).        For code like:void SetTempoBPS(double fTempo) { m_fTempo = fTempo; }
void SetTempoBPM(double fTempo) { m_fTempo = fTempo/60.0; }
double GetTempoBPS() { return m_fTempo; }
double GetTempoBPM() { return m_fTempo*60.0; }    Not to mention, getters should be const…Contrary to setting noexcept for every function, sometimes we’d have to remove this specifier or consider updating the function.For example, I got:Warning    C26447    The function is declared 'noexcept' but calls function 'Destroy()' which may throw exceptions (f.6).    For:CGLApp::~CGLApp() {
    Destroy();
}Back in 2005 there was no support for override so when I had an interface that defined three pure virtual functions:// in the interface
virtual void Init(CViData *viData) = 0;
virtual void Step() = 0;
virtual void Stop() = 0;I had no way to express that in a derived class, so I just used:// in derived:
void Init(CViData *viData);
void Step();
void Stop();With C++11 we can, of course, change it and mark as// in derived:
void Init(CViData *viData) override;
void Step() override;
void Stop() override;For whatever reason I defined a lot of empty destructors for my classes and the compiler reports now:Warning    C26432    If you define or delete any default operation in the type 'class CCamera', define or delete them all (c.21).    That’s a classic Rule of Zero, and I should reconsider my classes, should they only expose constructors or maybe I need some extra resource handling inside?Returning to an ancient project is fun, especially if you liked the project’s idea. It’s amazing how tools changed over time. With the help of a modern compiler and code analysis, I could detect a lot of issues and fix them. It’s like having a colleague who does a basic code overview. Additionally, through such checks and refactoring, you can learn a lot about Modern C++.Going back to the title of this text: You can rely on your “force”, knowledge and experience and see through the code and improve it. But you can also try modern C++ tools (Visual Studio is just one of them, but there are others on other platforms) and modernise code even easier.The project repo: github.com/fenbf/ViAlg-Update.Back To YouIf you’d like to know more about Visual Studio Code Analysis:The core guideline checkers are installed by default in Visual Studio 2017 and Visual Studio 2019, and are available as a NuGet package for Visual Studio 2015.",cpp
16,"While I was doing research for my book and blog posts about C++17 several times I stumbled upon this pattern for visitation of std::variant:template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
template<class... Ts> overload(Ts...) -> overload<Ts...>;With the above pattern, you can provide separate lambdas “in-place” for visitation.It’s just two lines of compact C++ code, but it packs a few interesting concepts.Let’s see how this thing works and go through the three new C++17 features that make this patter possible.Updated on 13th January 2020:  better description for the whole article and C++ 20 features were mentioned - CTAD for aggregates.The code mentioned at the top of the article forms a pattern called overload (or sometimes overloaded), and it’s mostly useful for std::variant visitation.With such helper code you can write:template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
template<class... Ts> overload(Ts...) -> overload<Ts...>;

std::variant<int, float, std::string> intFloatString { ""Hello"" };
std::visit(overload  {
      [](const int& i) { std::cout << ""int: "" << i; },
      [](const float& f) { std::cout << ""float: "" << f; },
      [](const std::string& s) { std::cout << ""string: "" << s; }
    },
    intFloatString
);The output:string: Hello
Little reminder: std::variant is a helper vocabulary type, a discriminated union. As a so-called sum-type it can hold non-related types at runtime and can switch between them by reassignmentstd::visit allows you to invoke an operation on the currently active type from the given variant. Read more in my blog post Everything You Need to Know About std::variant from C++17.Without the overload you’d have to write a separate class or struct with three overloads for the call operator `()’:struct PrintVisitor
{
    void operator()(int& i) const {
        std::cout << ""int: "" << i; }

    void operator()(float& f) const {
        std::cout << ""float: "" << f;
    }

    void operator()(std::string& s) const {
        std::cout << ""string: "" << s;
    }
};

std::variant<int, float, std::string> intFloatString { ""Hello"" };
std::visit(PrintVisitor(), intFloatString);So how does the overload patter work? Why do we need to inherit from lambdas there?As you might already know the compiler conceptually expands lambda expression into a uniquely-named type that has operator().What we do in the overload pattern is that we inherit from several lambdas and then exposes their operator() for std::visit. That way you write overloads “in place”.What are the C++17 features that compose the pattern?Here’s the list:Let’s explore section by section the new elements that compose the overload pattern. That way we can learn a few interesting things about the language.As you can see, we have three features to describe, and it’s hard to tell which one is the simplest to explain.But let’s start with using. Why do we need it at all?To understand that, let’s write a simple type that derives from two base classes:#include <iostream>

struct BaseInt {
    void Func(int) { std::cout << ""BaseInt...\n""; }
};

struct BaseDouble {
    void Func(double) { std::cout << ""BaseDouble...\n""; }
};

struct Derived : public BaseInt, BaseDouble {
    //using BaseInt::Func;
    //using BaseDouble::Func;
};

int main() {
    Derived d;
    d.Func(10.0);
}We have two bases classes that implement Func. We want to call that method from the derived object.Will the code compile?When doing the overload resolution set, C++ states that the Best Viable Function must be in the same scope.So GCC reports the following error:error: request for member 'Func' is ambiguous
See a demo here @ColiruThat’s why we have to bring the functions into the scope of the derived class.We have solved one part, and it’s not a feature of C++17. But how about the variadic syntax?The issue here was that before C++17 using... was not supported.In the paper Pack expansions in using-declarations P0195R2 - there’s a motivating example that shows how much extra code was needed to mitigate that limitation:template <typename T, typename... Ts>
struct Overloader : T, Overloader<Ts...> {
     using T::operator();
     using Overloader<Ts...>::operator();
     // […]
};

template <typename T> struct Overloader<T> : T {
    using T::operator();
};In the example above, in C++14, we had to create a recursive template definition to be able to use using. But now we can write:template <typename... Ts>
struct Overloader : Ts... {
    using Ts::operator()...;
    // […]
};Much simpler now!Ok, but how about the rest of the code?We derive from lambdas, and then we expose their operator() as we saw in the previous section. But how can we create objects of this overload type?As you know there’s no way to know up-front the type of the lambda, as the compiler has to generate some unique type name for each of them. For example, we cannot just write:overload<LambdaType1, LambdaType2> myOverload { ... } // ???
// what is LambdaType1 and LambdaType2 ??The only way that could work would be some make function (as template argument deduction works for function templates since like always):template <typename... T>
constexpr auto make_overloader(T&&... t) {
    return Overloader<T...>{std::forward<T>(t)...};
}With template argument deduction rules that were added in C++17, we can simplify the creation of common template types and the make_overloader function is not needed.For example, for simple types, we can write:std::pair strDouble { std::string{""Hello""}, 10.0 };
// strDouble is std::pair<std::string, double>There’s also an option to define custom deduction guides. The Standard library uses a lot of them, for example, for std::array:template <class T, class... U>
array(T, U...) -> array<T, 1 + sizeof...(U)>;and the above rule allows us to write:array test{1, 2, 3, 4, 5};
// test is std::array<int, 5>For the overload patter we can write:template<class... Ts> overload(Ts...) -> overload<Ts...>;Now, we can typeoverload myOverload { [](int) { }, [](double) { } };And the template arguments for overload will be correctly deduced. In our case, the compiler will know the types of lambdas so it willLet’s now go to the last missing part of the puzzle - aggregate Initialization.This functionality is relatively straightforward: we can now initialise a type that derives from other types.As a reminder: from dcl.init.aggr:An aggregate is an array or a class with: 
  * no user-provided, explicit, or inherited constructors  
  * no private or protected non-static data members 
  * no virtual functions, and 
  * no virtual, private, or protected base classesFor example (sample from the spec draft):struct base1 { int b1, b2 = 42; };

struct base2 {
  base2() { b3 = 42; }
  int b3;
};

struct derived : base1, base2 {
   int d;
};

derived d1{{1, 2}, {}, 4};
derived d2{{}, {}, 4};initializes d1.b1 with 1, d1.b2 with 2, d1.b3 with 42, d1.d with 4, and d2.b1 with 0, d2.b2 with 42, d2.b3 with 42, d2.d with 4.In our case, it has a more significant impact. Because for the overload class, without the aggregate  initialisation, we’d had to implement the following constructor:struct overload : Fs... 
{
  template <class ...Ts>
  overload(Ts&& ...ts) : Fs{std::forward<Ts>(ts)}...
  {} 

  // ...
}It’s a lot of code to write, and probably it doesn’t cover all of the cases like noexcept.With aggregate initialisation, we “directly” call the constructor of lambda from the base class list, so there’s no need to write it and forward arguments to it explicitly.You can play with code below:Or here @Coliru
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in C++17, check it out here:With each C++ revision, there’s usually a chance to write even more compact code. With C++20 it’s possible to have even shorter syntax.Why?It’s because in C++20 there are extensions to Class Template Argument Deduction and aggregates are automatically handled. That means that there’s no need to write a custom deduction guide.For a simple type:template <typename T, typename U, typename V>
struct Triple { T t; U u; V v; };In C++20 you can write:Triple ttt{ 10.0f, 90, std::string{""hello""}};And T will be deduced as float, U as int and V as std::string.The overloaded pattern in C++20 is now just:template<class... Ts> struct overload : Ts... { using Ts::operator()...; };The proposal for this feature is available in P1021 and also P1816 (wording).GCC10 seems to implement this proposal, but it doesn’t work for advanced cases with inheritance, so we have to wait for the full conformance here.The overload pattern is a fascinating thing. It demonstrates several C++ techniques, gathers them together and allows us to write shorter syntax.In C++14 you could derive from lambdas and build similar helper types, but only with C++17 you can significantly reduce boilerplate code and limit potential errors. With C++20 we’ll get even shorter syntax as CTAD will work with aggregates.You can read more in the proposal for overload P0051 (it was not accepted for C++20, but it’s worth to see discussions and concepts behind it).The pattern presented in this blog post supports only lambdas, and there’s no option to handle regular function pointers. In the paper, you can see a much more advanced implementation that tries to handle all cases.",cpp
17,"Amazon Web Services (AWS) provide multiple tools for developing a native cloud application. In particular, the Software Development Kit (SDK) for C++ programming language enables developers to build powerful and efficient AWS applications for any platform. This includes Android, iOS, Linux and Windows apps.This article introduces the basic concepts of C++ app development for AWS and S3, including real code examples.This article is a guest post from Gilad David Maayan.Gilad is a technology writer who has worked with over 150 technology companies including SAP, Samsung NEXT, NetApp and Imperva, producing technical and thought leadership content that elucidates technical solutions for developers and IT leadership. See his profile at Linkedin.Developers can use AWS for database storage, compute power, content delivery and other operations like:Host dynamic websites on a server in the cloudStore files in a secure environmentStore data in managed databases like PostgreSQL, Oracle or SQL ServerDeliver dynamic and static files using a CDNMonitor your environments like CPU usage of RDS instances and trigger alarmsAWS launched the initial experimental version of an open-source SDK for C++ back in 2015. A developer preview version was released in March 2016. Finally, in September 2016, the SDK reached its production-ready 1.0 status.The AWS SDK for C++ allows you to develop AWS applications using a modern C++ interface. It provides both low-level and high-level APIs for almost all AWS features. In addition, it decreases dependencies and provides platform portability on Linux, Windows, macOS, and mobile.In their first announcement in 2015, Amazon highlighted that game developers are the main target of the C++ SDK. However, developers can also use it for systems engineering tasks and projects that require the efficiency of native code. This SDK makes it easier for developers and game studios to build code with hooks on AWS infrastructure.In general, two main markets might benefit from the C++ SDK for AWS:C++ game developers who want to build different 3D rendering engines, virtual reality apps, networking libraries and audio systems.Development teams who require the power and efficiency of bare-metal programming languages like C++.Developers can choose between Linux, Windows, Mac, iOS and Android as their operating systems. Integrated Development Environments (IDEs), like Visual Studio, are available for C++ development on AWS. In addition, the AWS SDK enables you to integrate Visual Studio with CMake, a tool for managing the software build process.The list below specifies the necessary prerequisites to install the C++ SDK on your machine:C++ compilers like Visual Studio starting from the 2015 version, GNU Compiler Collection (GNU) or Clang 3.3At least 4 GB of RAMFor Linux, you need to have the header files for libopenssl, libcurl, libuuid, zlib, and libpulse for Amazon Polly supportTo install the C++ SDK on your machine, you can use the following methods:Installation on Debian/Ubuntu systemssudo apt-get install libcurl4-openssl-dev libssl-dev uuid-dev zlib1g-dev libpulse-devInstallation on Redhat/Fedora systemssudo dnf install libcurl-devel openssl-devel libuuid-devel pulseaudio-develInstallation on CentOS systemssudo yum install libcurl-devel openssl-devel libuuid-devel pulseaudio-libs-develWindows based-systems installation using NuGetMicrosoft Visual C++ developers can manage AWS C++ SDK dependencies using NuGet. To use this option, you have to install NuGet on your machine.To use the SDK with NuGetOpen your Visual Studio projectRight-click your project name, and then select Manage NuGet Packages in the Solution ExplorerSearch for a specific library name or service and select the packages you want. For instance, you can search for aws s3 nativeClick on Install to install the librariesWindows based-systems installation using VcpkgAs an alternative to NuGet, you can use vcpkg to manage dependencies for AWS SDK for C++ projects that you develop with Microsoft Visual C++.To use the SDK with vcpkgNavigate to the vcpkg directory in the Windows command promptIntegrate vcpkg into Visual Studio using the following command vcpkg integrate installInstall the AWS SDK C++ package with vcpkg install aws-sdk-cpp[*]:x86-windows –recurseOpen your Visual Studio projectInclude the header files of AWS SDK for C++ in the source codeTo connect to any of the AWS services with the SDK, you must provide credentials. The AWS CLI and SDKs use provider chains to search for AWS credentials in different regions. This includes local AWS configuration files and system or user variables.You can set your AWS credentials in multiple ways. The list below reviews the recommended approaches.Using the AWS credentials profile fileThe credentials file is located on your local machine at:The file contains the following format:[default]
aws_access_key_id = personal_access_key_id
aws_secret_access_key = personal_secret_access_keyChange the personal\_access\_key\_id and personal\_secret\_access\_key in the code to your own credentials.Set the AWS\_SECRET\_ACCESS\_KEY, the AWS\_ACCESS\_KEY\_IDenvironment variables.To set these variables on Linux, macOS, or Unix, use export :export AWS\_ACCESS\_KEY\_ID=your\_access\_key\_id
export AWS\_SECRET\_ACCESS\_KEY=your\_secret\_access\_keyTo set these variables on Windows.set AWS\_ACCESS\_KEY\_ID=your\_access\_key\_id
set AWS\_SECRET\_ACCESS\_KEY=your\_secret\_access\_keyUsing IAM rolesSpecify an IAM role for the EC2 instances you plan to host your applications on. Make sure to include access to EBS Volumes if you’re using them. Once your role is created, you can give your instances and volumes access to that role. For more details, see IAM Roles for Amazon EC2 in the Amazon EC2 User Guide for Linux.The AWS SDK for C++ loads the credentials automatically by using the default credential provider chain.After you’re done with the installation, you can develop C++ apps by leveraging different AWS services, such as S3. With S3, you can store files accessible by a range of services and applications. The following tutorial shows how to create Amazon S3 Buckets in any region. You can find the full code on this GitHub repository.In S3, each bucket represents a folder of files or objects. Each bucket has its own unique name in the AWS ecosystem. The default option is to create buckets in the us-east-1 (N. Virginia) region.Include the following files when developing S3 apps with the AWS SDK for C++#include <aws/core/Aws.h>
#include <aws/s3/S3Client.h>
#include <aws/s3/model/CreateBucketRequest.h>Define the main function variablesbool create_bucket(const Aws::String &bucket_name,
    const Aws::S3::Model::BucketLocationConstraint &region = Aws::S3::Model::BucketLocationConstraint::us_east_1)
{Set up the request for creating S3 bucketsThe CreateBucket method from the S3Client class is used to pass the CreateBucketRequest with the name of the bucket.    Aws::S3::Model::CreateBucketRequest request;
    request.SetBucket(bucket_name);Check if the region is us-east-1    if (region != Aws::S3::Model::BucketLocationConstraint::us_east_1)
    {Specify the region as a location constraint        Aws::S3::Model::CreateBucketConfiguration bucket_config;
        bucket_config.SetLocationConstraint(region);
        request.SetCreateBucketConfiguration(bucket_config);
    }Create the S3 bucket    Aws::S3::S3Client s3_client;
    auto outcome = s3_client.CreateBucket(request);
    if (!outcome.IsSuccess())
    {
        auto err = outcome.GetError();
        std::cout << ""ERROR: CreateBucket: "" << 
            err.GetExceptionName() << "": "" << err.GetMessage() << std::endl;
        return false;
    }
    return true;
}The following are online tutorials and resources for C++ developers on AWS.The C++ language first appeared in the late 1970s. Some experts argue that C++ will fade out of existence due to the growing popularity of new languages and technologies. However, there is a growing demand in the industry for C++ development of virtual reality and 3D applications. AWS’ C++ SDK was designed to help developers meet this demand.Hopefully, this article has helped you understand the first steps you should take to develop C++ apps in AWS using the SDK. With a little practice, you should be able to get your apps running in no time.",cpp
18,"2019 is almost over. Let’s reflect on how C++ changed during this time! What were some significant events, how the Standard progressed, how tools changed and many more.Let’s have a look!Previous reports:
2018,
2017,
2016,
2015,
2014,
2013,
2012.Disclaimer: the view presented here is mine and does not represent the opinion of the entire ISO C++ Committee.Here are the main things for this year that got my attention:Read on to get the full picture.The below table helps to see the main events:Just for the completeness and reminder  Clang (since 3.4 ), GCC (since 5.0) and Intel (version 15.0) already have full support for C++11/14.Visual Studio Team announced full conformance with C++17 with the version 2017,  15.7… and that also means the support for C++11/14. Now, you can build complex codebases like boost::hana or range v3.Since C++11/14 is supported in all major compilers, you have no excuses not to use modern C++ :)In December 2017 C++17 was published as ISO/IEC 14882:2017 Programming languages – C++.You can download a free version of the last draft: N4700, 2017-10-16, PDF.The full version of compiler support can be found @cppreference: C++17 compiler support, Or you can read my blog posts:C++17 FeaturesOr get my Language Ref Card:Regarding Language Features:Starting from Clang 5.0, GCC 8.0, Visual Studio 15.7 and Intel C++ Compiler 19.0.1 we can say that all the compiler support language features.More work needed to be done for The Standard Library: Especially when we talk about large things like parallel algorithms and the filesystem.For std::filesystem you need GCC 8.1 (or better GCC 9.1), Clang 3.9 (or better 7.0) and Visual Studio 2017 15.7.The parallel algorithm update was first available in Visual Studio 2017 15.7, but with later updates, the MSVC team added a few more algorithms.Then you can use Intel PSTL implementation, and it was also added into GCC 9.1. You need Intel Threading Building Blocks as the backend implementation. Have a look at this article.C++17 STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and macOS by Paul SilisteanuAnd we’re still waiting for Clang Library to catch up.Another issue is with the implementation of low-level conversion functions.Visual Studio stared to supportfrom_chars()/to_chars()for integers from 15.7, and then added floating point support for from_chars() with 15.8. But the fully conformant implementation is available in 16.4 (floating point version for to_chars()). 
So far Clang and GCC versions only support integer numbers. Maybe due to MSVC STL implementation being open-sourced, we can expect that some code will be ported into those other Standard Library implementations.Discussions on C++20 dominate this year. The feature freeze happened during the Summer ISO C++ Meeting in Cologne. Later, in Belfast, some of the first national body comments were resolved.All in all, it means that we’re on an excellent path to publishing the new standard next year!As for the major features we can list the following things:What’s more, a lot of C++20 features are already implemented in the popular compilers. The biggest things like modules are still not done (we have only some experimental TS implementations).The full list is as usual available at cppreference: C++20 compiler support, but here I’d like to list a few:There were three committee meetings this year - in Kona, Cologne and Belfast. This year it seems that the Committee prefers to stay in Europe :)The plan for the meetings is available here: Upcoming Meetings and Past MeetingsThe next one is planned in February 2020, in Prague.New things that were voted into C++20:Parallelism TS v2 was also published as ISO/IEC TS 19570:2018 - Programming Languages – Technical Specification for C++ Extensions for Parallelism.The main trip report summary:r/cpp: 2019-02 Kona ISO C++ Committee Trip Report and post Kona mailingOther trip reports:This meeting was a feature freeze meeting for the C++20 standard. This was the last chance for a feature to be voted in.Also, this time a major feature was voted out from the draft. Contracts were very appealing, but actually, the committee could not agree on the final implementation points. So it was decided that it’s better to form a separate study group and try to prepare the feature for C++23.Some notable changes and feature:The main meeting summary: r/cpp thread - cologne meeting.And the post Cologne mailingTrip reports:This time the Committee didn’t vote any new features but spent most of the time on solving the national body comments for the C++20 draft.The main trip report at r/cpp:  Post-meeting mailing: https://isocpp.org/blog/2019/12/2019-11-post-belfast-mailing-availableOther trip reportsCurrent versions and most notable updates.The current version is Visual Studio 2019 16.4, last update in 3rd December  - Release 
notes.This year we had a launch of new version Visual Studio 2019! It brings lots of new features and enhancement to the already superb IDE.Here’s the initial launch post: Visual Studio 2019: Code faster. Work smarter. Create the future. | Visual Studio BlogSome notable features:Another major update came from Cppcon where the MSVC team announced their Standard Library Implementation to be open source! Have a look: 
Open Sourcing MSVC’s STL | C++ Team BlogSome other news:And here’s a documentation page about the conformance with C++ Standards (including C++20): 
Microsoft C++ language conformance tableCurrent stable version GCC 9.2, August 12th, GCC 9 Release Series ChangesCurrent stable version: 9.0 - 19th Sept 2019, Release NotesThe Version 19.1 appeared in April  2nd  (release notes)The current version is Rio 10.3 update 3. Latest release in November 21st, 2019, see Release notes.The IDE uses a modified Clang Compiler (version 5.5) and the Dinkumware STL implementation It works with both Win32 and Win64 apps. Embarcadero C++ Builder is a full featured IDE for building iOS, Android, Windows and macOS apps from a single C++ codebase.Some of the news:And here you can see a conformance table for tha C++ features: 
Modern C++ Language Features Compliance Status
While compilers do the primary job with our C++ code, we cannot forget about the importance of other tools.Here are some important tools that it’s worth to know:Clang/LLVM powers many great utilities! For example:For a better code understanding, you can also have a look at SourceTrail. It was recently released as fully free version! 
Sourcetrail is now free and open-source software – Sourcetrail Developer BlogWe cannot complain about the lack of C++ conferences :) There are many options, especially around Spring and then in Autumn, To name a few code events:But there are more: like Code::Dive, Italian C++ Conference, C++ on Sea, C++ Italian Day C++Russia, or Core C++ 2019.It’s also amazing that if you haven’t been at a conference, you can quickly type its name on YouTube and find most of the lectures from it. You can easily find trip reports using some web search engine.Just in case here’s the link to ISO C++ page with all registered conferences around the world: Conferences Worldwide, C++FAQ.User groups are a chance for you to meet other C++ programmers, share your experience and learn new things. I highly recommend visiting such groups regularly… or at least once in a while.I am delighted that my city - Cracow - continued its C++ group this year: C++ User Group Krakow - join if you’re nearby!If you don’t have a User Group close to your place (but please check User Groups Worldwide), you can also participate in:Additionally this year we also pushed with the Polish C++ Blog: C++ Polska. We have several active authors there with great content every month! 
We also started a Slack Channel where you can discuss C++ and non-C++ things :) 
Join here: C++ Polska SlackSome of the books and courses released this year worth seeing:One of the strong points here is John Lakos’ book! I’ve been waiting for that for several years, and it’s finally available!And we also have the print versions of popular C++ self-published books:Where is C++ regarding popularity? Is all eaten up by JavaScript?Apparently not, as in some places C++ has grown or stayed at a stable position.Let’s have a look at some charts/stats:In my opinion, I feel that C++ is still strong among others. It’s not perfect, it’s not easy to learn… but a lot of code is built still with that language. Rust or other system languages won’t quickly replace it. The tools are getting better and better, the language aims to reduce the complexity (sometimes not :)), so the experience for beginners hopefully is getting better.Yet, C++ is only a tool, and we can be grateful we have a lot of tools at our disposal today.I also found a recent article from Daniel Lemire, who made some predictions on the programming and the programming languages ten years ago. He was positively surprised by the growth of C++:From Daniel Lemire:I would say that C++ has become a much better language since 2010. It is not any easier, but it has exceeded my expectations. More than a week ago, I started a quick survey where I wanted to get some data about C++ use. I got  574 answers! Thank you!On a daily basis, which C++ Standard do you use?(The numbers for the above do not sum to 100%)I didn’t specify what does “use” mean, so it can be both for production code and also hobby projects. For example there’s a high use of C++20, but I believe it’s mostly for testing and not yet for the full production code… or maybe I’m wrong?What’s your experience with C++17?This year we can see steady progress in the adoption of the C++ Standard.What’s your experience with C++20?What compiler do you use?(The numbers for the above do not sum to 100%)(The numbers for the above do not sum to 100%), Last year I didn’t ask that question.I think that asking for using “debuggers” wasn’t super clever… as we probably can assume all of the devs use it at some point :)Some “other” answers include: ccache, meson, make, Boost build, QMake, Autotools, cmake format, Emacs, Whole Tomato.This was an open question and from what I’ve seen the main things was as follows (no special order, based on occurrences in the list):You also listed a few personal achievements: for example, someone started using C++17, someone had his first talk at a conference. You also motioned about the introduction of Conan in your project, or that you changed your job. There was also a comment about “being finally retired”. Good for all of you!It’s also a pleasure to me that you also wrote that the best thing was my book :) Thank you! :)For example:“C++17 in Detail”, of course! The free version convinced me to use C++17 in my projects.Regarding surveys, The C++ Committee also sent us a survey in February. 
They managed to gather more than 2000 votes.Have a look: Second Annual C++ Foundation Developer Survey “Lite” : Standard C++ and the results.There’s also a survey from Jetbrains:C++ 2019 - The state of Developer Ecosystem in 2019 InfographicThree things that I’d like to emphasise for the year:All in all, I think we can look positively on C++ in the next decade. Not sure what happens later, but for the next ten years, I believe that C++ should be relatively in a stable position. With all the tools, new C++ standard writing C++ code is more accessible and less error-prone. C++ is still the best choice for apps that require performance - it even takes over from C and Fortran.(This post might be filled with typos, grammar issues, sorry for that I 
hope to improve it during the next few days).Your turn",cpp
19,"It’s almost the end of the year!I prepared a quick survey, so we can learn about our experience with the language.Update:  Thank you for all of your votes! The survey is now disabledLooking form the perspective of a language on its own, we see that the whole year was focused on C++20. The almost-final spec for the new standard is ready; there are some discussions about fixes and improvements; there will also be an ISO meeting where the Committee will address the problems. but hopefully, it’s ready to be published in 2020.So that’s a”big picture” for the language… but how was that year for you?What was your favourite events this year? 
Have you modernised your projects a bit? 
Maybe you have used some new tools? 
Or maybe you was on your first C++ conference?All of the answers to the above questions are important to me, so I prepared a small, quick survey where you can express your observations.The responses will allow me to update my final status blog post that I should be able to publish next week.


Update:  Thank you for all of your votes! The survey is now disabled
Here’s the link to google forms: 

 
C++ at the End of 2019 - Survey
Since It's the end of the year, I have a special offer for you if you want to learn about C++17!
With this link you can buy my book 30% cheaper: 
C++17 In Detail @Leanpup - 30% offAlso, you can buy it 25% off, along with two other books that form ""C++ Modern Pack"": 
""The Legacy Code Programmer's Toolbox"" and ""Concurrency with Modern C++"" 
Modern C++ Pack @Leanpub
",cpp
20,"In today’s article, I’ll show you battle-tested features from the well-known Boost libraries that were adapted into C++17.With the growing number of elements in the Standard Library, supported by experience from Boost you can write even more fluent C++ code.Read on and learn about the cool things in C++.Some time ago I saw a collection of articles at Fluent C++ about boost algorithms:In the series, Jonathan described various sorting algorithms, extended partitioning, pattern searching and a few others. I realised that a lot of elements from Boost are now part of the Standard Library, so that inspired me to tackle this topic.As you know, Boost libraries give us a vast set of handy algorithms, types and features that we don’t have in the Standard Library. Many functionalities were “ported” into core C++. For example, in C++11 we got std::regex, threading and smart pointers.In that context, we can treat Boost as a testing battleground before moving to the Standard Library.When I was writing my book about C++17, I’ve noticed that there is a large number of elements that were “moved” from Boost in the new Standard.For example:The good news is that if you used only small parts of Boost like boost::variant or boost::optional, now you can use almost the same code and convert to the Standard Library types (via std::variant and std::optiona).Let’s have a look at those areas, and the first topic is “vocabulary types”.Being able to write expressive code is a compelling capability. Sometimes using only built-in types doesn’t provide those options. For example, you can set up some number and assign it as “NOT_NUMBER” or treat values of -1 as null entries. As an “ultimate solution” you could even use a pointer and treat nullptr as null… but wouldn’t it be better to have explicit type from the Standard?Alternatively, how about storing several alternative types in a single object? You can try with C-style unions, but they are hard to use and very low-level… and causing troubles. How about having a type that can store several alternatives… or an object that can store any type?If you use Boost, then you probably stumbled upon types like boost::optional, boost::variant and boost::any.Rather than treating -1 as “null number” you leverage optional<int> - if optional is “empty” then you don’t have a number. Simple as it is.Alternatively, variant<string, int, float> is the type that allows you to store three possible types and switch between them at runtime.Finally, there’s any that is like a var type in dynamic languages; it can store any type and dynamically change them. It might be int, and later you can switch it to string.Let’s have a look at some code:The first one is std::optional:template  <typename Map,  typename Key>
std::optional<typename Map::value_type::second_type> TryFind(const Map& m,  const Key& k)  {
    auto it = m.find(k);
    if  (it != m.end())
        return std::make_optional(it->second);
    return std::nullopt;
}TryFind returns optional of the value stored in the map, or nullopt. See demo @Wandbox.You can use it in the following way:std::map<std::string, int> mm {  {""hello"",  10},  {  ""super"",  42  }};
auto ov =  TryFind(mm,  ""hello"");

// one:
std::cout << ov.value_or(0)  <<  '\n';

// two:
if  (ov)
    std::cout <<  *ov <<  '\n';If the optional ov contains a value, we can access it through the .value() member function or operator*. In the above code, we used another alternative which is the value_or() function that returns the value if present or returns the passed parameter.std::optional stores one value or nothing, so how about storing more types in a safe union type?Here’s an example:std::variant<int,  float, std::string>  TryParseString(std::string_view sv)  {
    // try with float first
    float fResult =  0.0f;
    const  auto last = sv.data()  + sv.size();
    const  auto res = std::from_chars(sv.data(), last, fResult);
    if  (res.ec != std::errc{}  || res.ptr != last)  {
        // if not possible, then just assume it's a string
        return std::string{sv};
    }

    // no fraction part? then just cast to integer
    if  (static_cast<int>(fResult)  == fResult)
        return static_cast<int>(fResult);

    return fResult;
}std::variant can be used to store different types as a parsing result. One common use case is parsing command line or some configuration file. The function TryParseString takes a string view and then tries to parse it into float, int or string. If the floating-point value has no fraction part, then we store it as an integer. Otherwise, it’s a float. If the numerical conversion cannot be performed, then the function copies the string.To access the value stored in a variant, you first have to know the active type. Here’s a code that shows how to do it and use the return value from TryParseString:const  auto var =  TryParseString(""12345.98"");

try  {
    if (std::holds_alternative<int>(var))
        std::cout <<  ""parsed as int: ""  << std::get<int>(var)  <<  '\n';
    else if (std::holds_alternative<float>(var))
        std::cout <<  ""parsed as float: ""  << std::get<float>(var)  <<  '\n';
    else if (std::holds_alternative<string>(var))
        std::cout <<  ""parsed as string: ""  << std::get<std::string>(var)  <<  '\n';
}

catch (std::bad_variant_access&) {
    std::cout <<  ""bad variant access...\n"";
}The main idea is to use std::holds_alternative() that allows us to check what type is present. variant also offers the .index() member function that returns number from 0… to the max num of stored types.But one of the coolest uses is a thing called std::visit().With this new functionality, you can pass a variant and visit the type that is actively stored. To do it you need to provide a functor that has call operator for all possible types in the given variant:struct PrintInfo {
    void  operator()(const  int& i)  const  { cout <<  ""parsed as int""  << i <<  '\n';  }
    void  operator()(const  float& f)  const  { cout <<  ""parsed as float""  << f <<  '\n';  }
    void  operator()(const string& s)  const  { cout <<  ""parsed as str""  << s <<  '\n';  }
};


auto PrintVisitorAuto = [](const  auto& t) { std::cout << t << '\n';  };

const  auto var =  TryParseString(""Hello World"");

std::visit(PrintVisitorAuto , var);
std::visit(PrintInfo{}, var);In the above example, we used two “types” of visitors. The first one - PrintInfo is a structure that provides all overrides for the call operator. We can use it to show more information about the given type and perform unique implementations. The other version - PrintVisitorAuto - leverages generic lambdas, which is convenient if the implementation for all of the types is the same.You can also read about the overload pattern in a separate blog post. This allows you to write all lambdas locally in a place where std::visit() is called: Bartek’s coding blog: 2 Lines Of Code and 3 C++17 Features - The overload Patternstd::any is probably the least know vocabulary type, and I think there are not many use cases for such a flexible type. It’s almost like var from JavaScript, as it can hold anything.A little demo of std::any (comes from the proposal N1939:struct property {
    property();
    property(const std::string &,  const std::any &);

    std::string name;
    std::any value;
};
typedef std::vector<property> properties;With such property class, you can store any type. Still, if you can restrict the number of possible types, then it’s better to use std::variant as it performs faster than std::any (no extra dynamic memory allocation needed).If you want to know more about the vocabulary types you can read separate articles :std::string_view is a not owning view on the contiguous sequence of characters. It has been ready in Boost for several years now (see boost utils string_view). As far as I know, their interfaces were a bit different, but now the boost version is conformant with C++17.Conceptually string_view consists of a pointer to the character sequence and the size:struct BasicCharStringView {
    char* dataptr;
    size_t size;
};You may wonder what’s unique about std::string_view?First of all string_view is a natural replacement for char* arguments. If your function takes const char* and then performs some operation on that, then you can also use view and benefit from nice string-like API.For example:size_t CStyle(const  char* str,  char ch)  {
    auto chptr =  strchr(str, ch);
    if  (chptr !=  nullptr)
        return  strlen(str)  +  (chptr - str);
    return  strlen(str);
}

size_t CppStyle(std::string_view sv,  char ch)  {
    auto pos = sv.find(ch);
    if  (pos != std::string_view::npos)
        return sv.length()  + pos;
    return sv.length();
}

// use:
std::cout <<  CStyle(""Hello World"",  'X')  <<  '\n';
std::cout <<  CppStyle(""Hello World"",  'X')  <<  '\n';See the code @WandboxGoing further, as you might know, there are many string-like class implementations. CString, QString, etc… and if your code needs to handle many types, string_view might help. Those other types can provide access to the data pointer and the size, and then you can create a string_view object.Views might also be helpful when doing some work on large strings and when you slice and cut smaller sections. For example, in the parsing of files: You can load file content into a single std::string object and then use views to perform the processing. This might show a nice performance boost as there won’t be any extra copies of strings needed.It’s also important to remember that since the string_view doesn’t own the data, and also might not be null-terminated, there are some risks associated with using it:A good summary of string views can be found at Marco Arena’s blog post: string_view odi et amo.C++20 info: Another good news is that starts_with()/ends_with() algorithms from Boost are now part of C++20… and many compilers already have implemented them. They are available both for string_view and std::string.As Jonathan wrote in his second part of the searchers series, Boost offers three pattern searching algorithms:All of the algorithms beat the naive pattern searching for large strings by using a preprocessing step. They build additional tables based on the input pattern, and the search is more efficient.The last two of those algorithms were ported into C++17, and they are available as an additional searcher object for the std::search function.Right now, C++17 provides a new overload for std::search:template<class ForwardIterator,  class Searcher>
ForwardIterator search( ForwardIterator first, ForwardIterator last,
const Searcher& searcher );The Searcher is a template parameter (so you can even come up with your implementation!), and the library offers three types:All in all you can use it like:std::string testString =  ""Hello Super World"";
std::string needle =  ""Super"";
auto it =  search(testString.begin(), testString.end(),
boyer_moore_searcher(needle.begin(), needle.end()));

if  (it == testString.end())
    cout <<  ""The string ""  << needle <<  "" not found\n"";The searcher object is created once for each pattern. If you want to search the same text in different containers, then you can save a bit of preprocessing time.On my blog, I did some performance experiments, and it looks like for larger patterns and boyer_moore we can achieve much better performance than with a default searcher. For example, when scanning inside text with 547412 characters, and looking for a 200-letter pattern, I got 8x perf speedup over the default searcher. And even 3x perf over optimised std::string::find.If you want more about the searchers, with even some basic benchmarks you can have a look here: Speeding up Pattern Searches with Boyer-Moore Algorithm from C++17.This is a massive addition to C++17 and The Standard Library. The committee took years of experience with boost::filesystem improved it, proposed a technical specification and later merged into the Standard.As the canonical example, let’s have a look at the directory iteration from Boost:#include  <boost/filesystem.hpp>

namespace fs = boost::filesystem;

fs::path inputPath = GetInputPath();
for (const auto& entry : fs::directory_iterator(inputPath))
    std::cout << entry.path()  <<  '\n';And now, the C++17’s version:#include  <filesystem>

namespace fs = std::filesystem;

fs::path inputPath = GetInputPath();
for  (const  auto& entry : fs::directory_iterator(inputPath))  {
    std::cout << entry.path()  <<  '\n';Do you see any difference? :) The code is almost the same as in Boost!We can even extend it a bit and add more logging:#include  <filesystem>

namespace fs = std::filesystem;

for  (const  auto& entry : fs::directory_iterator(inputPath))  {
    const  auto filenameStr = entry.path().filename().string();
    if  (entry.is_directory()) 
        std::cout <<  ""dir: ""  << filenameStr <<  '\n';
    else  if  (entry.is_regular_file()) 
        std::cout <<  ""file: ""  << filenameStr <<  '\n';
    else
        std::cout <<  ""?? ""  << filenameStr <<  '\n';
}As you can see, in the above code we can efficiently work with path objects, run the iteration over a directory (recursive or not) and print various information about the given directory entry.The filesystem library is composed of four main parts:The path object - a type that represents a path in the system. With various methods to extract the path parts, compose it, convert between formats and even from string to wide string.directory_entry - holds information about the path that is inside some directory, plus cacheDirectory iterators - two classes that allow you to scan a directory: just once or recursively.Plus many supportive non-member functions:getting information about the pathfiles manipulation: copy, move, create, symlinkslast write timepermissionsspace/filesize…The library is enormous, and I hope it will be beneficial for applications that rely on file access (and which app doesn’t have to work with files?)On my blog, I published one article by a guest author who described his process of moving from boost::filesystem into std::filesystem. Check it out if you also need to convert some of your file handling code.Bartek’s coding blog: Converting from Boost to std::filesystemThe Boost libraries offer lots of algorithms and functions that help with even advanced math calculations.For example, there’s a whole Math Toolkit 2.9.0 - 1.70.0 module with almost everything you can expect from a math library.The C++17 Standard extended the library with a few extra functions.We have a simple functions like clamp , gcd and lcm :#include  <iostream>
#include  <algorithm>  // clamp
#include  <numeric>  // for gcm, lcm

int  main()  {
    std::cout << std::clamp(300,  0,  255)  <<  ', ';
    std::cout << std::clamp(-10,  0,  255)  <<  '\n';
    std::cout << std::gcd(24,  60)  <<  ', ';
    std::cout << std::lcm(15,  50)  <<  '\n';
}And, also there’s a set of special math functions: assoc_laguerre, beta, comp_ellint_1/_2/_3, hermite, laguerre, riemann_zeta and a few others.The full list of those special math function can be found at Mathematical special functions - @cppreference.P0013 proposes to add the metafunctions and_, or_ and not_ to the standard library and cites Boost.MPL as one of the standard libraries having implemented such features for a long time. The paper was adopted in C++17 as std::conjunction, std::disjunction and std::negation.Here’s an example, based on the code from the proposal:template<typename... Ts>
std::enable_if_t<std::conjunction_v<std::is_same<int, Ts>...>  >
PrintIntegers(Ts ... args)  {
    (std::cout <<  ...  << args)  <<  '\n';
}The above function PrintIntegers works with a variable number of arguments, but they all have to be of type int.As you might already know in C++20 we’ll get Ranges and Concepts… but did you know that an earlier version was also available in Boost?Here’s a link to the Ranges library Boost Range 2.0And now while the Concepts in C++20 are part of the language, you can simulate them with The Boost Concept Check Library:The library is heavily based on macros, but you could get some outline about generic programming and what we might want to achieve with Real concepts.
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in C++17, check it out here:I hope with this blog post I gave you more incentives to start using C++17 :). The last C++ standard offers not only many language features (like if constexpr, structured bindings, fold expressions…), but also a broad set of utilities from the Standard Library. You can now use many vocabulary types: variant, optional, any, string views and even a significant component: std::filesystem. All without the need to reference some external library.Share your experience in comments.",cpp
21,"Multithreading is a tough nut in software development. Not just because there are dozens of ways to approach a single problem, but also since one can get so many things wrong.In this article, I want to present how to realize the concept of a Looper with Dispatchers in C++17.This article is a guest post by Marc-Anton Boehm-von Thenen:Marc (a.k.a DottiDeveloper) is a freelance software engineer primarily working with C++, C# as well as a lecturer in the games and graphics programming environment.  
  He has been developing his spare-time, playground project “ShirabeEngine” for more than 2.5 years, which made C++ the primary aspect of his everyday job and passion.  
  But wait, there’s more: He is a passionate dad, loves music, drawing and painting as well as creating analogue learning games for school children (more on this publicly in march 2020). 
  Check out his github, XING, LinkedIN and twitter profiles and his blog at http://craft-deploy.it/Many widely used systems are based on this paradigm, despite their various expressions of the individual use case based on it.Just to name a few:AndroidOS - Loopers as a message queue and one or more Handler types, depending on the specific message. 
(See: https://developer.android.com/reference/android/os/Looper )Qt Framework - Also as message queue upon which the signal and slot mechanism is built to signal across thread boundaries. 
(See: https://doc.qt.io/qt-5/signalsandslots.html and https://woboq.com/blog/how-qt-signals-slots-work.html )**Windowing system**s with a UI-Thread and event-callbacks.Most Game-Loops in game engines (even though they might not be reusable components), which attach to the main thread and hook into operating system specific event systems - the classic WINAPI-hooks (admit it, you know them ;) )Let’s examine the concept.Usually, it is no problem to start a thread and execute a function on it, e.g. using C++11’s <thread> and std::thread:#include <thread>
#include <iostream>
#include <stdint.h>

void work(uint32_t const &aNumberOfIterations)
{
    for(uint32_t k=0; k<aNumberOfIterations; ++k)
    {
        std::cout << ""I am a manifestation of an iteration\n"";
    }

    // Thread will terminate here.
}

// ...
std::thread worker(work); // ATTENTION: Will start immediately!
worker.join(); // Block and wait for completion 
// ...So, why not use it everywhere and be happy?Well, threads are not for free.There will at least be a stack allocated for the thread. There is the management of all threads to be done with respect to the governing process in kernel space and the operating system implementation. Also, when having a large number of threads, scaleability, will almost certainly become a critical factor, regarding the huge amount of permutations of target systems.And even worse, the specific expression of a thread is dependent on the operation system and the threading library used.  See: 
https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/Finally, we hardly have any control about the threads and its execution.As long as we don’t have co_routines and executors, let’s look at another way to approach thread reusability and controlled threading.Loopers, in its core, are objects, which contain or are attached to a thread with a conditional infinite loop, which runs as long as the abort-criteria is unmet. Within this loop, arbitrary actions can be performed. 
Usually, a methodology like start, run and stop are provided.Let’s derive an example class in three steps.Wrapping a thread 
First things first, we define the CLooper-class, which contains an std::thread-member and a run-method, which will create the thread, invoking runFunc - our second method - implementing the effective thread operation.#include <thread>
#include <atomic>
#include <memory>
#include <functional>
#include <stdexcept>

class CLooper
{
public:
    CLooper() 
    { }
    // Copy denied, Move to be implemented

    ~CLooper()
    {
    }

    // To be called, once the looper should start looping.
    bool run()
    {
        try 
        {
            mThread = std::thread(&CLooper::runFunc, this);
        }
        catch(...) 
        {
            return false;
        }

        return true;
    }

private:
    void runFunc() 
    {
        // Thread function
    }

private:
    std::thread mThread;
};Running the infinite loop 
Then, we add the infinite loop to the looper implementation as well as an atomic flag mRunning and a corresponding getter running() indicating whether the looper is running or not.public: // Methods
    bool running() const 
    {
        return mRunning.load();
    }

private: // Methods
    // Conditionally-infinite loop doing sth. iteratively
    void runFunc() 
    {
        mRunning.store(true);

        while(true)
        {
            try
            {
                // Do something...
            }
            catch(std::runtime_error& e) 
            {
                // Some more specific
            }
            catch(...) 
            {
                // Make sure that nothing leaves the thread for now...
            }
        }

        mRunning.store(false);
    }

private: // Members
    std::atomic_bool mRunning;Stopping the looper cleanly 
In order to stop the looper, however, we need some more methodology.We add an abort-criteria to the infinite loop - mAbortRequested - of type std::atomic<bool>, which is checked against in each iteration.We also add a private method abortAndJoin(), which will set the mAbortRequested-flag to true, invoke join() on the thread and waits until the looper-function has been exited and the worker thread was joined. The destructor will also invoke abortAndJoin() in case the looper goes out of scope.The public method stop() serves as a public API handle to control the looper.public: // Ctor/Dtor
    ~CLooper()
    {
        abortAndJoin();
    }

public: // Methods
    void stop()
    {
        abortAndJoin();
    }

private: // Methods
    // Conditionally-infinite loop doing sth. iteratively
    void runFunc() 
    {
        mRunning.store(true);

        // We now check against abort criteria
        while(false == mAbortRequested.load())
        {
            try
            {
                // Do something...
            }
            catch(std::runtime_error& e) 
            {
                // Some more specific
            }
            catch(...) 
            {
                // Make sure that nothing leaves the thread for now...
            }
        }

        mRunning.store(false);
    }

    // Shared implementation of exiting the loop-function and joining 
    // to the main thread.
    void abortAndJoin()
    {
        mAbortRequested.store(true);
        if(mThread.joinable())
        {
            mThread.join();
        }
    }

private: // Members
    std::atomic_bool mAbortRequested;This basic construct can now be used as follows:auto looper = std::make_unique<CLooper>();

std::cout << ""Starting looper"" << std::endl;
// To start and run
looper->run();

std::this_thread::sleep_for(std::chrono::seconds(5));

std::cout << ""Stopping looper"" << std::endl;
// To stop it and clean it up
looper->stop();
looper = nullptr;The above example implementation, however, is an iterative no-op, it doesn’t do anything.Let’s base upon it and fill it with life by permitting the looper to execute something.In the context of loopers, these are little executable portions of code sharing a common signature, i.e. one or more **Task**s, which can be fetched from an internal collection, e.g. a FIFO-queue, and be executed on the worker thread.Let’s start with the definition of a task type by adding this to the CLooper-class: 
using Runnable = std::function<void()>;  Next, permit the looper to hold runnables by addingstd::recursive_mutex mRunnablesMutex; 
std::queue<Runnable> mRunnables;to the list of members. 
The mutex is required to guard against simultaneous access to the task collection by the worker and dispatching thread.In order to access the Runnables, in case the queue is not empty, add the below function.Runnable next()
{
    std::lock_guard guard(mRunnablesMutex); // CTAD, C++17

    if(mRunnables.empty())
    {
        return nullptr;
    }

    Runnable runnable = mRunnables.front();
    mRunnables.pop();

    return runnable;
}And finally, in order to have the runnables be executed, add the below snippet into runFunc’s try-block.using namespace std::chrono_literals;
Runnable r = next();
if(nullptr != r)
{
    r();
}
else
{
    std::this_thread::sleep_for(1ms);
}If there were any means of adding tasks yet, the looper would happily process the tasks pushed to the vector now.The looper still is useless, since no tasks can be pushed to the queue.The final concept to solve this is the Dispatcher.Imagine the dispatcher to be a bouncer in front of the looper. 
It will accept a task but will manage insertion into the working-queue. 
This way, some fancy usage scenarios can be enabled, e.g. delayed execution or immediate posting.In this blog-post, however, I will elaborate regular FIFO-insertion only.Let’s describe the dispatcher-class briefly, as a nested class in CLooper BELOW the alias Runnable.public:
    using Runnable = std::function<void()>;

    class CDispatcher
    {
        friend class CLooper; // Allow the looper to access the private constructor.

    public: 
       // Yet to be defined method, which will post the runnable 
       // into the looper-queue.
       bool post(CLooper::Runnable &&aOther);

    private: // construction, since we want the looper to expose it's dispatcher exclusively!
        CDispatcher(CLooper &aLooper)
            : mAssignedLooper(aLooper)
       {}

    private:
       // Store a reference to the attached looper in order to 
       // emplace tasks into the queue.
       CLooper &mAssignedLooper;
    };With this definition given, we add a std::shared_ptr<CDispatcher> mDispatcher; in CLooper and add mDispatcher(std::shared_ptr<CDispatcher>(new CDispatcher(*this))) to the constructor’s initialization-list.  Remark: 
The std::shared_ptr<T>-constructor is required over std::make_shared, since the constructor of CDispatcher is private and inaccessible from std::make_shared.Next, add the below method into the CLooper-class, in order to retrieve the dispatcher:std::shared_ptr<CDispatcher> getDispatcher()
{
   return mDispatcher;
}Next, let’s implement the CDispatcher’s post-method as below:bool post(CLooper::Runnable &&aRunnable)
{
   return mAssignedLooper.post(std::move(aRunnable));
}And finally, add this private method to CLooper.private:
    bool post(Runnable &&aRunnable)
    {
        if(not running())
        {
            // Deny insertion
            return false;
        }

        try
        {
            std::lock_guard guard(mRunnablesMutex); // CTAD, C++17

            mRunnables.push(std::move(aRunnable));
        }
        catch(...) {
            return false;
        }

        return true;
    }The whole construct can be used as follows now:auto looper = std::make_unique<CLooper>();

std::cout << ""Starting looper"" << std::endl;
// To start and run
looper->run();

auto dispatcher = looper->getDispatcher();

std::cout << ""Adding tasks"" << std::endl;
for(uint32_t k=0; k<500; ++k)
{
    auto const task = [k]()
    { 
        std::cout << ""Invocation "" << k 
                  << "": Hello, I have been executed asynchronously on the looper for "" << (k + 1) 
                  << "" times."" << std::endl;
    };

    dispatcher->post(std::move(task));
}

std::cout << ""Waiting 5 seconds for completion"" << std::endl;
std::this_thread::sleep_for(std::chrono::seconds(5));

std::cout << ""Stopping looper"" << std::endl;
// To stop it and clean it up
dispatcher = nullptr;
looper->stop();
looper = nullptr;Working example: @WandboxThis example code can be improved in a lot of places and is far from perfect and I would say not necessarily even safe.There are many things we can do, which we will maybe describe in follow-up posts.This construct is a good starting point to regain control of your threading and reuse threads while simultaneously reducing threading-overhead.The design is simple and comprehensible and permits thread-safe dispatching of work-items to a single worker-thread while reducing the spread of thread-dispatches throughout the codebase.It has its limitations, though!The looper is just a control-construct attached to a single worker-thread and can not handle parallelized execution or workload balancing, which Thread-Pools with work-stealing are perfect for.But, if there’s a single worker thread required for a specific type of tasks, the Looper can be a more simple and more comprehensible approach to solve the multithreading issue!",cpp
22,"In this post, I’ll show you how to use the newest, low-level,  conversion routines form C++17. With the new functionality, you can quickly transform numbers into text and have super performance compared to previous techniques.Until C++17, we had several ways of converting numbers into strings:And with C++17 we get another option: std::to_chars (along with the corresponding method from_chars) ! The functions both reside in the <charconv> header.Why do we need new methods? Weren’t the old technique good enough?In short: because to_chars/from_chars is low-level, and offers the best possible performance.The new conversion routines are:A simple example:std::string str { ""xxxxxxxx"" };
const int value = 1986;
std::to_chars(str.data(), str.data() + str.size(), value);

// str is ""1986xxxx""The new methods are available in the following compilers:This article is part of my series about C++17 Library Utilities. Here’s the list of the articles:Resources about C++17 STL:to_chars is a set of overloaded functions for integral and floating-point types.For integral types there’s one declaration:std::to_chars_result to_chars(char* first, char* last,
                              TYPE value, int base = 10);Where TYPE expands to all available signed and unsigned integer types and char.Since base might range from 2 to 36, the output digits that are greater than 9 are represented as lowercase letters: a...z.For floating-point numbers, there are more options.Firstly there’s a basic function:std::to_chars_result to_chars(char* first, char* last, FLOAT_TYPE value);FLOAT_TYPE expands to float, double or long double.The conversion works the same as with printf and in default (“C”) locale. It uses %f or %e format specifier favouring the representation that is the shortest.The next function overload adds std::chars_format fmt that let’s you specify the output format:std::to_chars_result to_chars(char* first, char* last, 
                              FLOAT_TYPE value,
                              std::chars_format fmt);chars_format is an enum with the following values: scientific, fixed, hex and general (which is a composition of fixed and scientific).Then there’s the “full” version that allows also to specify precision:std::to_chars_result to_chars(char* first, char* last, 
                              FLOAT_TYPE value,
                              std::chars_format fmt, 
                              int precision);When the conversion is successful, the range [first, last) is filled with the converted string.The returned value for all functions (for integer and floating-point support) is to_chars_result, it’s defined as follows:struct to_chars_result {
    char* ptr;
    std::errc ec;
};The type holds information about the conversion process:As you can see, we have only two options: success or out of range - as there’s a chance your buffer doesn’t have enough size to hold the result.To sum up, here’s a basic demo of to_chars.#include <iostream>
#include <charconv> // from_chars, to_chars
#include <string>

int main() {
    std::string str { ""xxxxxxxx"" };
    const int value = 1986;

    const auto res = std::to_chars(str.data(), 
                                   str.data() + str.size(), 
                                   value);

    if (res.ec == std::errc())    {
        std::cout << str << "", filled: ""
            << res.ptr - str.data() << "" characters\n"";
    }
    else if (res.ec == std::errc::value_too_large) {
        std::cout << ""value too large!\n"";
    }
}Below you can find a sample output for a set of numbers:On MSVC (starting from 15.9, full support in 16.0 + improvements later) we can also try the floating-point support.std::string str{ ""xxxxxxxxxxxxxxx"" }; // 15 chars for float

const auto res = std::to_chars(str.data(), str.data() + str.size(),  value);

if (res.ec == std::errc())     {
    std::cout << str << "", filled: ""
              << res.ptr - str.data() << "" characters\n"";
}
else if (res.ec == std::errc::value_too_large)     {
    std::cout << ""value too large!\n"";
}Below you can find a sample output for a set of numbers:In my book, I did some perf experiments for integer conversions, and the new functionality is several times faster than to_string or sprintf and more than 10… or even 23x faster than stringstream versions!I also have to check the floating-point support, but the results that I see from various places also claim order of magnitude speedup over the older techniques.See the Stephan T. Lavavej’s talk about implementing charconv in MSVC where he shared some floating-point benchmark results.In C++20, we’ll have more methods that allow us to convert data into strings and format them.The library is called std::format and is based on a popular framework {fmt}Have a look: https://en.cppreference.com/w/cpp/utility/formatSo far (Nov 2019) any of the standard library implementations don’t offer std::format, but we can try an example from the base library:Taking some samples from https://www.zverovich.net/2019/07/23/std-format-cpp20.html:std::vector<char> buf;
std::format_to(std::back_inserter(buf), ""{}"", 42);
 // buf contains ""42""You can also check out this blog post that nicely introduces you to the concepts of {fmt}:  
An Extraterrestrial Guide to C++ Formatting - Fluent C++As for the benchmarks you can read this one: http://www.zverovich.net/2013/09/07/integer-to-string-conversion-in-cplusplus.html, but unfortunately there’s no comparison with std::to_chars.
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in C++17, check it out here:With C++17, we got new functionality that allows easy and low-level conversions between numbers and text. The new routines are potent and expose all the information you need to create advanced parsers or serialises. They won’t throw, won’t allocate, they bound check, and they offer super performance.Read here about the corresponding from_chars methodExtra: since CppCon 2019 Microsoft opened their STL implementation, so you can even have a look at the code of charconv!And maybe there’s hope that the code will be used in GCC and Clang library implementations, as they lack for floating post support now. Do you know any rumours about that?I also highly suggest watching Stephan’s talk about the progress and the efforts for full charconv support. The feature looked very simple at first sight, but it appeared to be super complicated to support as the C library couldn’t be used, and everything had to be done from scratch.Floating-Point <charconv>: Making Your Code 10x Faster With C++17’s Final Boss by Stephan T. LavavejWhat do you think about the new conversion routines? Have you tried them?What other conversion utilities do you use?",cpp
23,"
They say “performance is king’… It was true a decade ago and it certainly is now. With more and more data the world generates each day, we need more and more computing power to process it. It used to be the case that some SW vendors preferred to wait for a new generation of HW to speed up their application and did not spend human resources on making improvements in their code. When it’s no longer the case that each HW generation provides a significant performance boost, we must start paying more attention to how fast our code actually runs.This article is a guest post from Denis Bakhvalov:Denis has more than 10 years of industry experience with C++. He works at Intel doing C++ compiler development. Denis makes his blog easyperf.net, where he focuses on performance.I see lots of people rely on their intuition when they try to optimize their application. And usually, it ends up with random fixes here and there without making any real impact on the performance of the application. I believe that finding the right place to fix should be a result of careful performance analysis, not intuition. But even then, it’s only half of the job. The second half is to actually fix it properly. Often changing one line in the program source code can yield 2x performance boost. Performance analysis is all about how to find and fix this line! Missing such opportunities can be a big waste.Modern CPUs are getting more and more cores each year. As of the end of 2019, you can buy the top bin server processor which will have more than 100 logical cores. This is very impressive, but that doesn’t mean we don’t have to care about performance anymore. Very often, application performance might not get better if you assign more cores to it. Understanding why that happens and possible ways to fix it is critical for future scaling of the product. Not being able to do proper performance analysis and tuning leaves lots of performance on the table. It’s so tempting to ask: “Why HW does not solve all our problems? Why compilers do not solve all our problems?” The short answer is: they do certainly help, but they can’t solve all of the problems. Modern CPUs execute instructions at incredible speed, but still can’t do much if the instructions that are used to perform the job are not optimal or even redundant. Compilers are usually full of heuristics that work well in general but do not cover all the corner cases; it’s simply impossible.Given that, we as maintainers of our code have no excuse for blaming compilers or HW and not doing performance-related work ourselves. I’m sure that the value of careful performance analysis and tuning will only increase over the upcoming years.Modern CPU is a very complicated thing. But relax, there is no single person in the world who understands all the aspects of how modern multicore CPU works. Unfortunately, that means that the topic of performance analysis is quite complicated with all sorts of unfamiliar metrics and terminology. That’s why I always strive to keep the things simple in my blog. I believe that there is a simple bridge to the world of performance analysis.“Okay, okay, I buy it, but the topic seems too big, where should I start?” My blog (easyperf.net) covers lots of performance-related topics very extensively, but for someone just starting, this post will be a good overview.Later in the article, I will touch on the following 4 pillars of the subject: 
1. How to configure machine and measure performance properly? 
2. What features for performance analysis does HW provide and how SW tools interact with them? 
3. Essential methodologies in performance analysis. 
4. How to address typical performance problems.Take it as a roadmap if you will.There are many different features in HW and SW that are intended to increase performance automagically. But some of them have non-deterministic behaviour. Take turbo boost feature, for example: if we start two runs, one right after another on a “cold” processor, first run will possibly work for some time in overclocked mode (read: work faster), but the second run will operate on its base frequency without entering the turbo mode. That’s where variation in results might come from. Since we have little control over such features, it makes sense to disable them for the time of the experiment to receive more consistent results. Ideally, in such cases, we want all the potential sources of performance non-determinism to be disabled in a system. This article is an attempt to bring all the tips together, provide examples and give instructions on how to configure your machine correctly.Probably, the oldest method for doing performance analysis is the code instrumentation. We all did it many times. Remember when you insert some printf statement at the beginning of the function just to count the number of times the function was called? Ha, me too. This is the easiest and likely the most precise and verbose technique to analyze the performance of the application. Yet code instrumentation has serious disadvantages. In particular, large overhead and the need to recompile the app every time we want to count something different. People do not use manual code instrumentation these days very often. So, during the years, new methods for doing performance analysis have been developed. One of them is based on performance monitoring interrupts (PMI) and is known as “profiling”. The easiest way to look at it is the following. If you use a debugger and will stop the program every second and record the place where you stop, you will get a collection of the samples. If you then aggregate all the samples and make a histogram, it will show you where your program spends time the most. This is the oversimplified description of what profiling tools are doing, but the idea is similar. There are automated tools like Linux “perf” and “Intel Vtune” that record thousands of interrupts (samples) per second while your program is running and then aggregate information about them.The underlying component that allows this to happen is the Performance Monitoring Counter (PMC). It allows counting different events. A simple example of using PMC can be count how much assembly instructions were executed since the beginning of the application. I.e. we can configure it in such a way that with every executed assembly instruction our HW counter will be incremented by one.For a profiling case, PMC can be used in a little bit more sophisticated way. Let’s imagine our CPU runs at 1GHz, that’s 109 cycles per second. To interrupt the program each time after one million (106) cycles (at the frequency of 1000 samples per second) we would do the following steps:1. set counter to -1'000'000
2. enable counting
3. wait for the overflow which will be issued by the CPU
3.1. disable counting when it happens
3.2. catch the PMI
3.3. inside the interrupt handler capture instruction pointer (IP).
4. go to step 1Now, if we aggregate all the collected IPs together, we will know the hottest spots in our program.For a ground-up introduction on PMUs read this blog post. For underlying mechanics of profiling with Linux “perf” tool read this article.While profiling being the most popular use case of utilizing HW performance monitoring capabilities, it’s not the only one. If you want to know what other advanced features modern CPUs provide and how to utilize them take a look at the following articles: this, this and this.Finally, the concept of tracing might be very helpful for performance analysis as well. If you’re familiar with Linux strace/ftrace tools this won’t be new to you. While interrupt-based monitoring by definition skips a significant number of events we are interested in, tracing captures them all. You can view it as a hybrid solution of code instrumentation and interrupt-based monitoring. Tracing technologies take the best of both worlds. It is not that expensive as instrumentation but allows to capture a lot of information about the execution of the program. Processor tracing capabilities in modern CPUs allows tracing almost every assembly instruction at a relatively low overhead. Read more about Processor Traces (PT) here.In the most straight forward case identifying hotspots of the application will be all that you need. You might see some part of the code which shouldn’t be consuming that much time actually does so. In such case you can implement high-level transformation to optimize the runtime. For example, this could be a situation when you see some redundant work is done and can be avoided in certain scenarios.However, when all the low-hanging fruits (high-level optimizations) are implemented and you still need some improvements in order to meet the requirements, you need additional information, not just the hotspots. This is what you can consider as “tuning” (low-level optimizations). Modern CPUs have support for such tuning as well.It’s important to understand that even with the best support CPU might provide, it can’t do miracles if the application has major performance issues. For example, if the program does sorting with BubbleSort, it’s no point to even look into advanced CPU performance metrics, we need to fix the major problem first.Now, let’s demystify what do I mean by low-level optimizations. The compiler usually performs low-level transformations and often target a particular platform on which the code will be running on. This is not something a programmer typically do, but which can significantly improve the runtime performance of the program. Well-known examples of such transformations are: 
- Function inlining 
- Loop unrolling 
- VectorizationThere are many existing methodologies to do performance analysis, but not so many of them are robust and formal. One can go a naive path of just profiling the app and trying to grasp through the hotspots hoping to find something there. This often leads to random experiments in which sometimes you can be lucky. So, when doing microarchitectural optimizations (another term for low-level analysis), we’ve better rely on something robust and proven.One of such methodologies is called Top-down Microarchitecture Analysis Method (TMAM). This is an iterative process of identifying the source of the problem, finding the exact place in the code where the issue occurs and fixing it. The process is designed in a way to characterize the bottleneck of the application by putting it in one of the 4 buckets: “Retiring”, “Bad Speculation”, “Front-End Bound” and “Back-End Bound”. After that you keep drilling down inside a single bucket to find specific type of event that is limiting the application’s performance. When you finally found what type of bottleneck you are dealing with, you need to run the app again and locate places where this particular type of event is triggered. After the issue is fixed you start over the TMAM process until you get the performance you are looking for.Multithreaded applications have their own specifics. Certain assumptions of single-threaded execution are invalid when we’re dealing with multiple threads. For example, we can’t no longer identify hotspots by looking at a single thread. Profiling a thread which is waiting during most of the running time won’t sched light on the reason why our multithreaded application is not scaling well. Another example is: When dealing with the single-threaded application, optimizing one portion of the program usually yields positive results on performance. However, it’s not necessary the case for multithreaded applications. There could be one thread which does some very heavy operation, and which acts as a barrier for all the others. I.e. even though most part of the threads already finished their job, the process will not exit until there is one thread that is still running.But the most important and complex feature of multithreaded applications is locking. Having threads communicate efficiently is essential on the way to fully utilize all of the compute power in the system. Like with functions, some locks could be accessed more frequently than the others, so it’s important to know which locks are hot and focus on those. Also, there are interesting effects like false sharing that do not occur in the single-threaded world.If you want to know more about different aspects of how to analyze the performance of multithreaded applications, I wrote a series of articles about that topic.According to my personal experience, ~90% of all optimizations can be done on the source code of the application without touching the environment, like a compiler, OS settings, etc. If you choose to master the skill of performance tuning, you’ve better be familiar with the recipes for typical performance problems. At the beginning of 2019, I started making challenges with the goal of practice tuning existing benchmarks. There you can find examples of possible optimization opportunities with a detailed description of how they were found. Feel free to use them as templates when optimizing your application.I hope this was useful and I will be extremely happy if this will help developers to optimize their code.",cpp
24,"In the previous post about lazy initialisation, we showed examples and differences between using raw pointers, unique_ptr and std::optional to store the object and create it later. However, we implemented the samples from the perspective of single-threaded scenarios.In this post, we’ll try to fill the gap and show you how to make your lazy objects available in a multithreading environment.If your application creates several threads that might access such “lazy” resource, you might run into troubles. How do you know if the resource is initialised only once? What if two threads try to invoke the init code?To create a background, you’ll find an example below that operates on a vector of Employees. Each employee contains a record that will be fetched from a database. We want a lazy call to the database, so each object at the start knows only its ID and then connects to the DB if needed.class Employee {
public:
    explicit Employee(size_t id, const CompanyDatabase& db) : _id(id), _db(&db) { }

    std::string Name() const { MakeSureWereReady(); return _rec->_name; }
    std::string Surname() const { MakeSureWereReady(); return _rec->_surname; }
    std::string City() const { MakeSureWereReady(); return _rec->_city; }
    TSalary Salary() const { MakeSureWereReady(); return _rec->_salary; }

    friend std::ostream& operator<<(std::ostream& os, const Employee& em) {...}
private:
    void MakeSureWereReady() const {
        if (!_rec)
            _rec = _db->FetchRecord(_id);
    }

    size_t _id{ CompanyDatabase::InvalidID };
    mutable std::optional<CompanyDatabase::EmployeeRecord> _rec;
    const CompanyDatabase* _db;
};The class stores an observing pointer to a database, and in each getter, we make sure we have the data loaded before accessing it.For a reference here’s the CompanyDatabase::EmployeeRecord structure that holds the data:using TSalary = long; // might be replaced into decimal, fixed-point type...

struct EmployeeRecord { 
    std::string _name; 
    std::string _surname; 
    std::string _city; 
    TSalary _salary{ 0 };
};CompanyDatabase is just a simple class that contains some preallocated data in a vector.See the full code here: @WandboxTo illustrate that we might have issues with multithreading, let’s look at the following use case:void SalaryTask(const std::vector<Employee>& workers) {
    auto SalaryOp = [](TSalary curr, const Employee& em) {
        return curr + em.Salary();
    };
    const auto sumSalary = std::accumulate(std::cbegin(workers), std::cend(workers), 0, SalaryOp);
    std::cout << ""Sum salary: "" << sumSalary << '\n';
}

void CityTask(const std::vector<Employee>& workers) {
    std::map<std::string, int> mapByCity;
    for (auto& em : workers)
        mapByCity[em.City()]++;

    for (const auto& [city, num] : mapByCity)
        std::cout << city << "": "" << num << '\n';
}

void OptionalTest() {
    CompanyDatabase db;
    std::vector<Employee> workers;
    for (size_t i = 0; i < db.MaxEntries(); ++i)
        workers.emplace_back(Employee{ i, db });

    std::thread t1(SalaryTask, std::cref(workers));
    std::thread t2(CityTask, std::cref(workers));
    t1.join();
    t2.join();
}The code creates a vector of workers and then it passes the vector into two tasks: one that calculates the salary, and the other for some location stats.If we’re lucky, and there are no “collisions” we might get the following output:Fetching record: 0
Fetching record: 1
Fetching record: 2
Fetching record: 3
Sum salary: 440
Cracow: 2
Warsaw: 2What we have here is a nice serial execution.First, the salary thread kicks in and calls the getter of Salary() that causes to fetch record from the database. Each database access prints some output, so we can see which element is referenced. Later, the city thread starts and then there are no needs to get the data from the database.It’s super simple, with only four elements… but still, on Wandbox I could get the following output:Fetching record: Fetching record: 0
0
Fetching record: 1
Fetching record: 2
Fetching record: 3
Sum salary: 440
Cracow: 2
Warsaw: 2The above output means that two threads tried to access the first element simultaneously! note: we also don't sync std::cout, so the output might even show more artefacts. Or evenFetching record: 0
Fetching record: 0
Fetching record: 1
Fetching record: 1
Fetching record: 2
Fetching record: 3
Sum salary: 440
Cracow: 2
Warsaw: 2Now, we duplicated access for two elements…The final computations are correct and such access is not harmful to our particular example, but some worse things could happen in a real application.At this point we also have to make a disclaimer: for our test application, we assume that once the records are read from the DB, the code only reads the data and doesn’t modify it (doesn’t change the values for employees in the input vector). In other words, we focus only on the lazy init part.OK, how to make our code safer?As with most of the multithreading scenarios, we should be aware of data races. It means that to have safe code, we need to wrap it in some form of a critical section.Let’s try a first solution with a mutex:class EmployeeMut {
public:
    explicit EmployeeMut(size_t id, const CompanyDatabase& db) : _id(id), _db(&db) { }

    std::string Name() const { MakeSureWereReady(); return _rec->_name; }
    std::string Surname() const { MakeSureWereReady(); return _rec->_surname; }
    std::string City() const { MakeSureWereReady(); return _rec->_city; }
    TSalary Salary() const { MakeSureWereReady(); return _rec->_salary; }

    friend std::ostream& operator<<(std::ostream& os, const EmployeeMut& em) { ... }

private:
    void MakeSureWereReady() const {
         std::scoped_lock lock(mut); // !! !!
         if (!_rec)
            _rec = _db->FetchRecord(_id);
     }
private:
    size_t _id{ CompanyDatabase::InvalidID };
    const CompanyDatabase* _db;

    mutable std::mutex mut;
    mutable std::optional<CompanyDatabase::EmployeeRecord> _rec;    
};What I did here is a simple addition of std::mutex to the class…, and that’s all… but of course, when I tried to compile it, you’ll get an error. Do you know what’s wrong here?...std::mutex is not copyable nor moveable, so it means that if you want to use it as a class member, then you need to write custom copy ctors, assignments and other special functions.As a basic solution, I used the following implementation:~EmployeeMut() { }

EmployeeMut(const EmployeeMut& other) noexcept 
    : _id(other._id), _db(other._db), _rec(other._rec) { }
EmployeeMut& operator=(const EmployeeMut& other) noexcept 
    { _id = other._id; _db = other._db; _rec = other._rec; return *this; }
EmployeeMut(EmployeeMut&& other) noexcept 
    : _id(other._id), _db(other._db), _rec(std::move(other._rec)) { }
EmployeeMut& operator=(EmployeeMut&& other) noexcept 
    { _id = other._id; _db = other._db; _rec = std::move(other._rec); return *this; }In the above code, I’m skipping the mutex, and I assume that such copy/move actions are only invoked in a well defined serial scenario.To improve the implementation, you might want to check this solution suggested at StackOverflow: mutex - How should I deal with mutexes in movable types in C++? - Stack Overflow. It handles read and write scenarios.If we test the EmployeeMut, we should always get the correct order.Fetching record: 0
Fetching record: 1
Fetching record: 2
Fetching record: 3
Cracow: 2
Warsaw: 2
Sum salary: 440Full code at @WandboxSince C++11 we can also use possibly simplified approach: std::call_once():class EmployeeOnce {
public:
    explicit EmployeeOnce(size_t id, const CompanyDatabase& db) : _id(id), _db(&db) { }
    ~EmployeeOnce() { }

    EmployeeOnce(const EmployeeOnce& other) noexcept : _id(other._id), _db(other._db), _rec(other._rec) { }
    EmployeeOnce& operator=(const EmployeeOnce& other) noexcept { _id = other._id; _db = other._db; _rec = other._rec; return *this; }
    EmployeeOnce(EmployeeOnce&& other) noexcept : _id(other._id), _db(other._db), _rec(std::move(other._rec)) { }
    EmployeeOnce& operator=(EmployeeOnce&& other) noexcept { _id = other._id; _db = other._db; _rec = std::move(other._rec); return *this; }

    std::string Name() const { MakeSureWereReady(); return _rec->_name; }
    std::string Surname() const { MakeSureWereReady(); return _rec->_surname; }
    std::string City() const { MakeSureWereReady(); return _rec->_city; }
    TSalary Salary() const { MakeSureWereReady(); return _rec->_salary; }

    friend std::ostream& operator<<(std::ostream& os, const EmployeeOnce& em){ }

private:
    void MakeSureWereReady() const {
        if (!_rec) {
            std::call_once(_flag, [&]() {   // !!!
            if (!_rec)
              _rec = _db->FetchRecord(_id);
            });
        }
    }

private:
    size_t _id{ CompanyDatabase::InvalidID };
    const CompanyDatabase* _db;

    mutable std::once_flag _flag;
    mutable std::optional<CompanyDatabase::EmployeeRecord> _rec;    
};To use call_once in our code, we need to store a flag that will indicate if the callable object was invoked or not. As you can see, this is _flag in EmployeeOnce. Later, we only changed MakeSureWereReady() which now calls std::call_once().What I noticed is that once_flag is much smaller than std::mutex. It’s just 8 bytes in GCC 9.2, vs 30 bytes for a mutex.The trouble is that in all of the special functions we cannot copy or reassign the value of the once flag, as it’s not copyable nor moveable. If you copy an object that is already initialised, then the copy will have an unset flag. Potentially that might cause call_once() to fire again. Still, we protect that with if (!_rec) condition, so we should be safe here… however I’m not 100% sure here.Unfortunately, we can still have data races here...
To improve the code we'll have to insert some memory barriers to be sure we're accesing the state for double check locking...
You can also read the following guides: 
Core Guidelines: CP.111: Use a conventional pattern if you really need double-checked locking
Double-Checked Locking is Fixed In C++11
Have a look at the working example below:In the blog post, you’ve seen a scenario where unprotected lazy init code was fired twice when only two threads performed some actions. As a simple solution, we improved the pattern by protecting the initialisation step with a mutex and then with std::call_once. Still, the code is relatively simple and might fail when the data is modified and not only read. So at the moment, I need to leave the topic and wait for your input and feedback.What patterns do you use for such lazy initialisation in a multithreaded environment?You can also read the previous article that introduces the lazy initialisation in C++.",cpp
25,"Following the pattern for other ISO C++ Meetings, I prepared a blog post where you’ll learn about:Let’s start!Disclaimer: the view presented here is mine and does not represent the opinion of the entire ISO C++ committee.Thanks to various trip reports and especially r/cpp threads we can gather a list of features that are already merged into C++20(*). (*) The C++20 is almost ready, but still we might see some changes.At cppreference there’s also a single list with all C++20 features: 
 C++2a featuresBelow you can find a list of meeting and features that were accepted or rejected during each session.The first meeting that discussed and merged things for C++20Gathered from r/cpp - 2017 Toronto ISO C++ Committee Discussion Thread (Concepts in C++20; Coroutines, Ranges and Networking TSes published)Gathered from 2017 Albuquerque ISO C++ Committee Reddit Trip Report : r/cppMore info: 2018 Jacksonville ISO C++ Committee Reddit Trip Report : cppGathered from r/cpp: 2018 Rapperswil ISO C++ Committee Trip ReportAdditionally, during this meeting, the Committee agreed on a single plan for modules, so there’s a higher chance we’ll see them in C++20.Gathered from r/cpp: 2018 San Diego ISO C++ Committee Trip Report and Trip Report: C++ Standards Meeting in San Diego, November 2018 | There’s Waldo!Parallelism TS v2 was also published as ISO/IEC TS 19570:2018 - Programming Languages – Technical Specification for C++ Extensions for Parallelism.Gathered from r/cpp: 2019-02 Kona ISO C++ Committee Trip Report  and Trip report: Winter ISO C++ standards meeting (Kona) – Sutter’s MillOther trip reports:Gathered from this r/cpp thread.Trip reports:Today - 4th November 2019 - another ISO C++ meeting is about to start (in a few minutes?). This time the committee gathers in Belfast, Northern Ireland.The main topic of this meeting is to address the first round of National Body comments for the C++20 draft (from Cologne). We probably won’t see any new features added into the draft, as the Standard is in the feature freeze mode. Mostly we’ll focus on stabilising the existing elements.If time allows the committee will discuss papers that target C++23 and beyond.It seems that the committee likes Europe now, and the next meeting (Spring 2020) will take place in Prague (Czech Republic). Then we’ll travel to Varna (Bulgaria) for the hopefully first session that will add features into the working draft of C++23.You can always find the list of ISO meetings here: 
Upcoming Meetings, Past Meetings: Standard C++The papers (mailings) for meeting “Pre-Belfast” can be found under the following link: 
JTC1/SC22/WG21 - mailing2019-10.or in a easier-to read form:Below you can find my list of papers that brought my attention. I try to select not huge documents, but something smaller… however this time I couldn’t resist and look at some more significant things.I’m also looking forward to getting your opinion and your selected papers.Let’s start with something relatively small, a nice addition to the std::filesystem component:P1882R0To iterate through directories in C++17 you can use directory_iterator or the recursive version. Hovewer, they don’t support filtering. One way to reject unwanted path is to write a custom filtering code. For example:std::vector<fs::path> paths;
fs::path inPath = /* ... */;
std::filesystem::recursive_directory_iterator dirpos{ inPath };
std::copy_if(begin(dirpos), end(dirpos), std::back_inserter(paths),
    [](const fs::directory_entry& entry) {
        return check entry object here;
    }
);In the above code, we use copy_if, and then there’s a lambda that filters out directory entries objects. In this sample, I store the final paths into a separate vector.Since filtering is a handy thing, the author proposes to have direct filter support inside the directory_iterator. That way you could pass a filter lambda (with some options) straight into the iterator:auto filter = [](const char * filename) { 
    const char* ext = get_filename_ext(filename); 
    return strcmp(ext,"".c"") == 0 || 
           strcmp(ext,"".h"") == 0 || 
           strcmp(ext,"".cpp"") == 0 || strcmp(ext,"".hpp"") == 0;
};
for (auto &entry : fs::recursive_directory_iterator(folder, filter, fs::entry_restriction::file))
{
    do_some_work(entry.path().filename().c_str());
}You can even have a look at the benchmark where the author compares the current solution, with the regex version and the proposal (with lambda filter). 
https://github.com/bonpiedlaroute/cppcon2018/blob/master/windows/rdi_bench.cppIs that something useful? Or maybe it’s better to keep the design separate? I wonder how we could build such an example with ranges and views?I want to leave you with the answers and now move to some other feature that might be very handy and modernises older techniques.P1729R1 - Text ParsingIn C++20 we’ll have the formatting library: adapted from fmt library. It’s like bringing the Python formatting code and good old printf style into the modern C++.We can follow that path and for C++23 add the parsing part! It means modernising sscanf functionality.For example:std::string key;
int value;
std::scan(""answer = 42"", ""{} = {}"", key, value);There’s also an interesting observation.According to [CODESEARCH], a C and C++ codesearch engine based on the ACTCD19 dataset, there are 389,848 calls to sprintf and 87,815 calls to sscanf at the time of writing. So although formatted input functions are less popular than their output counterparts, they are still widely used.It’s still an early stage for this paper, but I think it would be good to go into that direction and have a common interface for handling string parsing and formatting, also, with the inclusion of std::chrono stuff.Do you often use parsing routines? Would you like to see that in the standard?OK, let’s now move on to a bit bigger element:P1108R4 - web_viewThat concept seems huge! It means that the library will give you a simple interface to create and manage a compact web browser! You’ll be able to write HTML, javascript and hook your C++ callbacks.While the whole idea seems strange, I actually like the core approach for this entire paper: paraphrasing:it’s hard to do the graphics and UI right (and maybe audio), so why not embrace other existing standards (the web stack) and provide an interface to work with it? This will allow us to learn C++ with some nicer examples.The library will be totally optional, so no need to implement such complex web stack on some restricted embedded environment :)But maybe it would give us a nice way to show more cool examples out of the box, rather than just using std::cout? Or maybe we need to accept that C++ is not going into any of these directions and we should just stick to preferred third-party libraries? (like QT, WebKit or native system APIs)?You can also follow the live discussion at r/cpp https://www.reddit.com/r/cpp/comments/900dor/stdweb_view_proposal/So far, I mentioned three features that you might use at some point in your code, but now I’d like to show not a feature but rather a useful resource for learning C++:P1705R1In short, the paper proposes two things:I think that might be a super valuable thing to have! As the author wrote, it’s hard to go through 1700 pages of the current standard and look for the “undefined” word. It’s much easier to have a list as a good reference.Then we can build on that and create more examples (in the TR) and learn more. Right now it’s not easy to know all the tricks in the area of Undefined behaviour, and it’s definitely not what average C++ developers are aware of.And now we can go into more high-level discussions. A director for C++23:P0592R3 - To boldly suggest an overall plan for C++23It looks like the direction for C++ is as follows:In other words, we try to embrace what we have in C++20 and then improve the overall standard. Especially the library support for modules, coroutines.And if time allows we’ll have also:Would you like to see more of the big things in the next Standard?Through this article, I wanted to give you an overview of the C++20 status and also look ahead for some new things in the language and the library.I’m happy to see what’s your top five. What are your favourite features that might be included in the next standard? or what direction should we take?",cpp
26,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 25th October and 1st November 2019.Today you will find links to articles about refactoring, the story of std::less, what is lazy initialization and why you should learn C++. Let’s start!On Tuesday Jonathan Bocarra from fluentcpp wrote an article about a little story of std::less<>. C++ doesn’t allow you to pass operators as callable objects, so you can only wrap a comparison into a functor and then pass it. std::less is probably one of the most useful comparator that comes from STL. See how it changed over different C++ revisions. 
fluentcpp.com/2019/10/29/stdless-and-its-modern-evolution/In the second article for this week on FluentCpp, you can read about converting nested loops with std algorithms. This is a good refactoring story and shows you how to eliminate raw loops and make code more expressive: 
fluentcpp.com/2019/11/01/transforming-deeply-nested-loops-with-stl-algorithms/Lazy initialization is a concept of deferring or skipping object construction. In a new guest article at bfilipek.com you can read how to implement this handy pattern with old techniques (raw pointers), improved version (with smart pointers) and then use the latest stuff from C++17: std::optional: 
www.bfilipek.com/2019/10/lazyinit.htmlOverview of biggest four C++20 features: concepts, ranges, modules & coroutines, from Rainer Grimm: 
modernescpp.com/index.php/thebigfourNew video from Jason Turner - he showed how to setup Eclipse-based environment for C++, Cevelop, with CMake project: 
youtube.com/watch?v=nnfdvE2qNeoIn Friday’s episode of CppCast, you can listen to JeanHeyd Meneide where he talks about Unicode support in C++. Maybe we can finally get Unicode support in C++23? 
cppcast.com/jeanheyd-meneide-unicode/John Murray, in his article, shows all the positive sides of C++: why you should learn it now, what are the strong points for C++, what is modern C++, tooling and many more: 
itnext.io/the-case-for-c-4122a5b47130Extra: See Meeting C++ Blog roll from 1st November: 
meetingcpp.com/blog/blogroll/items/Meeting-Cpp-Blogroll-205.htmlExtra 2: Checkout this C++ book pack! 
leanpub.com/b/moderncpppack 
Modernize your legacy code, add modern C++17 features and then increase the performance with concurrency and parallelism!The links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
27,"Lazy initialisation is one of those design patterns which is in use in almost all programming languages. Its goal is to move the object’s construction forward in time. It’s especially handy when the creation of the object is expensive, and you want to defer it as late as possible, or even skip entirely.Keep reading and see how you can use this pattern with the C++ Standard Library.Update:Read the next article about Lazy init and Multi-threading.This article is a guest post from Mariusz Jaskółka:Mariusz is a professional programmer for whose C++ is both his job and passion. He works for Novomatic Technologies Poland and writes texts to Polish blog cpp-polska. Besides programming he loves mushroom picking, mountain hikes and everything music-related. Check out his github and linkedin profiles.Originally published in Polish at cpp-polska.plLet’s make a real-life example. We have an RAII object that represents a file on the hard drive. We deliberately won’t use std::ifstream class, as it allows late file opening so that using late initialisation pattern would be pointless. Consider the following class:class File
{
public:
    File(std::string_view fileName)
    {
        std::cout << ""Opening file "" << fileName << std::endl;
    }
    ~File()
    {
        std::cout << ""Closing file"" << std::endl;
    }
    File(const File&) = delete;
    File(File&&) = default;
    File& operator=(const File&) = delete;
    File& operator=(File&&) = default;

    void write(std::string_view str)
    {
        std::cout << ""Writing to file: "" << str << std::endl;
    }
};As we can see, the file is opened in the constructor, and that’s the only place we can do it. We can use such class to save a configuration file:class Config
{
    File file;
public:
    Config() : file{""config.txt""}
    {
        std::cout << ""Config object created"" << std::endl;
    }

    void addOption(std::string_view name, std::string_view value)
    {
        file.write(name);
        file.write("" = "");
        file.write(value);
        file.write(""\n"");
    }
};Here’s a simple usage:int main()
{
    Config c;
    std::cout << ""Some operations..."" << std::endl;
    c.addOption(""dark_mode"", ""true"");
    c.addOption(""font"", ""DejaVu Sans Mono"");
}Run on WandboxThe problem with this implementation is that we presumably open the file long time before we really need to write to it. This may block other processes from manipulating this file, which is an undesirable side effect. We would instead open the file when the first call to addOption function occurs. We can achieve such behaviour in several ways. Let’s have a look.Pointers seem to be the solution at first glance – they can point to some value or to “nothing” (nullptr). Let’s go back to the example and then discuss why this is rather a bad idea.class Config
{
    File* file{nullptr};

public:
    Config()
    {
        std::cout << ""Config object created"" << std::endl;
    }

    ~Config()
    {
        delete file;
    }

    // ah... need to implement rule of 5...7 now!

    void addOption(std::string_view name, std::string_view value)
    {
        if (!file)
            file = new File{""config.txt""};
        file->write(name);
        file->write("" = "");
        file->write(value);
        file->write(""\n"");
    }
};Run on WandboxIn modern C++, holding allocated memory on the heap, under a raw pointer is considered to be a bad idea in most scenarios. First of all, mixing them with the exception mechanism can lead us to memory leaks. They also require manual memory freeing, which can be bypassed using the handy and lightweight RAII design pattern.If we declared a destructor it also means we have to follow the Rule of Five and implement copy ctor, assignment op and move semantics for the class.Having a smart pointer can free us from extra boilerplate code:class Config
{
    std::unique_ptr<File> file{};
public:
    Config()
    {
        std::cout << ""Config object created"" << std::endl;
    }

    void addOption(std::string_view name, std::string_view value)
    {
        if (!file)
            file = std::make_unique<File>(""config.txt"");
        file->write(name);
        file->write("" = "");
        file->write(value);
        file->write(""\n"");
    }
};Run on WandboxOur problem is solved in a much more elegant way. Compared to the original implementation, this method has one drawback though - the object is allocated on the heap. Allocation on the heap requires a system call (syscall), and the number of system calls should be rather minimized. Using objects from under the pointer might also cause less possibility of program optimization compared to objects referenced from the stack. That can lead us to another solution …class Config
{
    std::optional<File> file{};
public:
    Config()
    {
        std::cout << ""Config object created"" << std::endl;
    }

    void addOption(std::string_view name, std::string_view value)
    {
        if (!file)
            file.emplace(""config.txt"");
        file->write(name);
        file->write("" = "");
        file->write(value);
        file->write(""\n"");
    }
};Run on WandboxWe can notice that the above code doesn’t differ very much with the previous one. The unique_ptr and optional references are similar, but the implementation and purpose of those classes vary significantly. First of all, in the case of std::optional our objects memory is on the stack.It is worth mentioning that if you are not using C++17, but some older language version, you can use the Boost.Optional library, which implements the almost identical class.The consequences of the above features are:The use of the optional class described earlier may not be the first that comes to mind those who use it. Instead, it is a class that expresses that an object is present or is not. Here we revealed the fact that the object does not yet exist, but it will probably be in the future. This is, however, perfectly valid usage of this class.The answer to the question “which method should I use to express late initialisation?” isn’t that trivial though. I would advise beginners to use optional by default (form std or boost). However, if we examine this issue in more detail, we can draw the following conclusions:We also cannot forget about the properties of the described classes, especially about how they are copied and moved.Update:Read the next article about Lazy init and Multi-threading.Let us know in comments",cpp
28,"What do you do when the code for a variable initialization is complicated? Do you move it to another method or write inside the current scope?In this blog post, I’d like to present a trick that allows computing a value for a variable, even a const variable, with a compact notation.Last Update: 21st October 2019I hope you’re initializing most of variables as const (so that the code is more verbose, explicit, and also compiler can reason better about the code and optimize). For example, it’s easy to write:const int myParam = inputParam * 10 + 5;or even:const int myParam = bCondition ? inputParam*2 : inputParam + 10;But what about complex expressions? When we have to use several lines of code, or when the  ? operator is not sufficient.‘It’s easy’ you say: you can wrap that initialization into a separate function.While that’s the right answer in most cases, I’ve noticed that in reality a lot of people write code in the current scope. That forces you to stop using const and code is a bit uglier. You might see something like this:int myVariable = 0; // this should be const...

if (bFirstCondition)
    myVariable = bSecondCindition ? computeFunc(inputParam) : 0;
else
    myVariable = inputParam * 2;

// more code of the current function...
// and we assume 'myVariable` is const nowThe code above computes myVariable which should be const. But since we cannot initialize it in one line, then the const modifier is dropped. I highly suggest wrapping such code into a separate method, but recently I’ve come across a new option.I’ve got the idea from a great talk by Jason Turner about “Practical Performance Practices” where among various tips I’ve noticed “IIFE”. The IIFE acronym stands for “Immediately-invoked function expression”. Thanks to lambda expression, it’s now available in C++. We can use it for complex initialization of variables. Extra: You might also encounter: IILE, which stands for Immediately Invoked Lambda Expression.How does it look like?The main idea behind IIFE is to write a small lambda that computes the value:const auto var = [&] { 
    return /* some complex code here */; 
}(); // call it!var is const even when you need several lines of code to initialize it!The critical bit is to call the lambda at the end. Otherwise it’s just a definition.The imaginary code from the previous section could be rewritten to:const int myVariable = [&] {
    if (bFirstContidion)
        return bSecondCondition ? computeFunc(inputParam) : 0;
    else
       return inputParam * 2;
}(); // call!

// more code of the current function...The above example shows that the original code was enclosed in a lambda.The expression takes no parameters but captures the current scope by reference. Also, look at the end of the code - there’s  ()  - we’re invoking the function immediately.Additionally, since this lambda takes no parameters, we can skip () in the declaration. Only [] is required at the beginning, since it’s the lambda-introducer .One of the main concerns behind IIFE is readability. Sometimes it’s not easy to see that () at the end.How can we fix that?Some people suggest declaring a lambda above the variable declaration and just calling it later:auto initialiser = [&] { 
    return /* some complex code here */; 
};
const auto var = initialiser(); // call itThe issue here is that you need to find a name for the initializer lambda, but I agree that’s easy to read.And another technique involves std::invoke() that is expressive and shows that we’re calling something:const auto var = std::invoke([&] { 
    return /* some complex code here */; 
});Note: std::invoke() is located in the <functional> header and it’s available since C++17.In the above example, you can see that we clearly express our intention, so it might be easier to read such code.Now back to you:Which method do you prefer?Ok, but the previous examples were all super simple, and maybe even convoluted… is there a better and more practical example?How about building a simple HTML string?Our task is to produce an HTML node for a link:As input, you have two strings:  link and text (might be empty).The output: a new string:<a href=""link"">text</a>or<a href=""link"">link</a> (when text is empty)We can write a following function:void BuildStringTest(std::string link, std::string text) {
    std::string html;
    html = ""<a href=\"""" + link + ""\"">"";
    if (!text.empty())
        html += text;
    else
        html += link;
    html += ""</a>"";

    std::cout << html << '\n';
}Alternatively we can also compact the code:void BuildStringTest2(std::string link, std::string text) {
    std::string html;
    const auto& inText = text.empty() ? link : text;
    html = ""<a href=\"""" + link + ""\"">"" + inText + ""</a>"";

    std::cout << html << '\n';
}Ideally, we’d like to have html as const, so we can rewrite it as:void BuildStringTestIIFE(std::string link, std::string text) {
    const std::string html = [&] {
        std::string out = ""<a href=\"""" + link + ""\"">"";
        if (!text.empty())
            out += text;
        else
            out += link;
        out += ""</a>""; 
        return out;
    }(); // call ()!

    std::cout << html << '\n';
}Or with a more compact code:void BuildStringTestIIFE2(std::string link, std::string text) {
    const std::string html = [&] {
        const auto& inText = text.empty() ? link : text;
        return ""<a href=\"""" + link + ""\"">"" + inText + ""</a>"";
    }(); // call!

    std::cout << html << '\n';
}Here’s the code @ColiruDo you think that’s acceptable? Try rewriting the example below , maybe you can write nicer code?With IIFE, we not only get a  clean way to initialize const variables, but since we have more const objects, we might get better performance.  Is that true? Or maybe longer code and creation of lambda makes things slower?For the HTML example, I wrote a benchmark that tests all four version:@QuickBenchAnd it looks like we’re getting 10% with IIFE! 
Some notes:You can check other tests here: @QuickBenchIt looks like the performance is not something you need to be concerned with. The code works sometimes faster, and in most of the cases the compiler should be able to generate similar code as the initial local versionWould you use such a thing in your code?In C++ Coding Guideline we have a suggestion that it’s viable to use it for complex init code:C++ Core Guidelines - ES.28: Use lambdas for complex initialization,I am a bit sceptical to such expression, but I probably need to get used to it. I wouldn’t use it for a long code. It’s perhaps better to wrap some long code into a separate method and give it a proper name. But if the code is 2 or three lines long… maybe why not.Also, if you use this technique, make sure it’s readable. Leveraging std::invoke() seems to be a great option.I want to thank Mariusz Jaskółka from C++ Polska for the review, hints about compacting the code and also perf improvements with reserve().BTW: maybe I should ask Java Script guys since this concept comes from their world mostly :)",cpp
29,"To write a professional C++ application, you not only need a basic text editor and a compiler. You require some more tooling. In this blog post, you’ll see a broad list of tools that make C++ programming possible: compilers, IDEs, debuggers and other.Last Update: 14th October 2019.Note: This is a blog post based on the White Paper created by Embarcadero, see the full paper here: C++ Ecosystem White Paper.The C++ computer programming language has become one of the most widely used modern programming languages. Software built with C++ is known for its performance and efficiency. C++ has been used to build numerous vastly popular core libraries, applications such as Microsoft Office, game engines such as Unreal, software tools like Adobe Photoshop, compilers like Clang, databases like MySQL, and even operating systems such as Windows across a wide variety of platforms as it continues to evolve and grow.Modern C++ is generally defined as C++ code that utilizes language features in C++11, C++14, and C++17 based compilers. These are language standards named after the year they were defined (2011, 2014 and 2017 respectively) and include a number of significant additions and enhancements to the original core language for powerful, highly performant, and bug-free code. Modern C++ has high-level features that support object-oriented programming, functional programming, generic programming, and low-level memory manipulation features.Big names in the computer industry such as Microsoft, Intel, the Free Software Foundation, and others have their modern C++ compilers. Companies such as Microsoft, The QT Company, JetBrains, and Embarcadero provide integrated development environments for writing code in modern C++. Popular libraries are available for C++ across a wide range of computer disciplines including Artificial Intelligence, Machine Learning, Robotics, Math, Scientific Computing, Audio Processing, and Image Processing.In this blog post, we are going to cover a number of these compilers, build tools, IDEs, libraries, frameworks, coding assistants, and much more that can support and enhance your development with modern C++. Let’s get started!There are a number of popular compilers that support modern C++ including GCC/g++, MSVC (Microsoft Visual C++), Clang and Intel Compiler. Each compiler has varying support for each of the major operating systems with the open-source GCC/g++ originating in the late 1980s, Microsoft’s Visual C++ in the early 1990s, and Clang in the late 2000s. All four compilers support modern C++ up to at least C++17, but the source code licenses for each of them vary greatly.GCC is a general-use compiler developed and maintained and regularly updated by the GCC Steering committee as part of the GNU Project. GCC describes a large growing family of compilers targeting many hardware platforms and several languages. While it mainly targets Unix-like platforms, Windows support is provided through the Cygwin or MinGW runtime libraries. GCC compiles modern C++ code up to C++17 with experimental support for some C++20 features. It also compiles with a variety of language extensions that build upon C++ standards. It is free and open-source (GPL3) with the GCC Runtime Library Exception. GCC has support from build tools such as CMake and Ninja and many IDEs such as CLion, Qt Creator, and Visual Studio Code. 
https://gcc.gnu.org/ 
https://gcc.gnu.org/projects/cxx-status.htmlMicrosoft Visual C++ (MSVC) is Microsoft’s compiler for their custom implementation of the C++ standard, known as Visual C++. It is regularly updated, and like GCC and Clang, supports modern C++ standards up to C++17 with experimental support for some C++20 features. MSVC is the primary method for building C++ applications in Microsoft’s own Visual Studio. It generally targets a number of architectures on Windows, Android, iOS, and Linux. Support for build tools and IDEs are limited but growing. CMake extensions are available in Visual Studio 2019. MSVC can be used with Visual Studio Code, with limited support from CLion and Qt Creator with additional extensions. MSVC is proprietary and available under a commercial license, but there’s also a Community edition. 
https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B 
https://devblogs.microsoft.com/visualstudio/ 
https://visualstudio.microsoft.com/vs/community/Clang describes a large family of compilers for the C family of languages maintained and regularly developed as part of the LLVM project. Although it targets many popular architectures, it generally targets fewer platforms than GCC. The LLVM project defines Clang through key design principles - strict adherence to C++ standards (although support for GCC extensions is offered), modular design, and minimal modification to the source code’s structure during compilation, to name a few. Like GCC, Clang compiles modern C++ code with support for the C++17 standard with experimental C++20 support. It is available under an open-source (Apache License Version 2.0) license. Clang also has widespread support from build tools such as CMake and Ninja and IDEs such as CLion, Qt Creator, Xcode, and others. 
https://clang.llvm.org/ 
https://clang.llvm.org/cxx_status.htmlIntel C++ Compiler can generate highly optimized code for various  Intel CPUs (including  Xeon, Core, and Atom processors). The compiler can seamlessly integrate with popular IDE like Visual Studio, GCC toolchain and others. It can leverage advanced instruction set (even AVX512) and generate parallel code (for example, thanks to OpenMP 5.0 support).  Intel doesn’t ship the compiler with the Standard Library implementation, so it uses the library you provide on your platform. The compiler is available as a part of Intel Parallel Studio XE or Intel System Studio. 
https://software.intel.com/en-us/c-compilers 
https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compilerOn top of compilers, you need an infrastructure that helps to build a whole application: build tools, pipelines and package managers.Make is a well-known build system widely used, especially in Unix and Unix-like operating systems.  Make is typically used to build executable programs and libraries from source code. But the tool applies to any process that involves executing arbitrary commands to transform a source file to a target result.  Make is not tight to any particular programming language. It automatically determines which source files has been changed and then performs the minimal build process to get the final output. It also helps with the installation of the results in the system 
https://www.gnu.org/software/make/CMake is a cross-platform tool for managing your build process. Building, especially large apps and with dependent libraries, can be a very complex process, especially when you support multiple compilers; CMake abstracts this. You can define complex build processes in one common language and convert them to native build directives for any number of supported compilers, IDEs, and build tools, including Ninja (below.) There are versions of CMake available for Windows, macOS, and Linux. 
https://cmake.org/Note: Here’s a good answer about the differences between Make and Cmake: Difference between using Makefile and CMake to compile the code - Stack Overflow.The Ninja build system is used for the actual process of building apps and is similar to Make. It focuses on running as fast as possible by parallelizing builds. It is commonly used paired with CMake, which supports creating build files for the Ninja build system. The feature set of Ninja is intentionally kept minimal because the focus is on speed. 
https://ninja-build.org/MSBuild is a command-line based built platform available from Microsoft under an open-source (MIT)  license. It can be used to automate the process of compiling and deploying projects. It is available standalone, packaged with Visual Studio, or from Github. The structure and function of MSBuild files is very similar to Make. MSBuild has an XML based file format and mainly has support for Windows but also macOS and Linux. IDEs such as CLion and C++Builder can integrate with MSBuild as well. 
https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuildPackage managers such as Conan, vcpkg, Buckaroo and NIX have been gaining popularity in the C++ community. A package manager is a tool to install libraries or components. Conan is a decentralized open-source (MIT) package manager that supports multiple platforms and all build systems (such as CMake and MSBuild). Conan supports binaries with a goal of automating dependency management to save time in development and continuous integration. Microsoft’s vcpkg is open source under an MIT license and supports Windows, macOS, and Linux. Out of the box, it makes installed libraries available in Visual Studio, but it also supports CMake build recipes. It can build libs for every toolchain that can be fitted into CMake.Buckaroo is a lesser-known open-source package manager that can pull dependencies from GitHub, BitBucket, GitLab, and others. Buckaroo offers integrations for a number of IDEs including CLion, Visual Studio Code, XCode, and others.Here are the links for the mentioned package managers:A host of editors and integrated development environments (IDEs) can be used for developing with modern C++. Text editors are typically lightweight, but are less featureful than a full IDE and so are used only for the process of writing code, not debugging or testing it. Full development requires other tools, and an IDE contains those and integrates into a cohesive, integrated development environment. Any number of text editors like Sublime Text, Atom, Visual Studio Code, vi/vim, and Emacs can be used for writing C++ code. However, some IDEs are specifically designed with modern C++ in mind like CLion, Qt Creator, and  C++Builder, while IDEs like Xcode and Visual Studio also support other languages.You can also compare various IDE for C++ in this handy table on Wikipedia: 
Comparison of integrated development environments - C++ - WikipediaThe list below summarises a set of advanced source code editors that thanks to various plugins and extensions allow creating applications in almost all programming languages.A wide variety of extensions are available that bring features such as debugging and code completion for modern C++ to Visual Studio Code. Sublime Text, Atom, and Visual Studio Code are all available for Windows, macOS, and Linux.Here are the links for the above tools:Vi/Vim and Emacs are free command-line based text editors that are mainly used on Linux but are also available for macOS and Windows. Modern C++ support can be added to Vi/Vim through the use of scripts while modern C++ support can be added to Emacs through the use of modules. 
https://www.vim.org/ 
https://www.gnu.org/software/emacs/CLion is a commercial IDE from JetBrains that supports modern C++. It can be used with build tools like  CMake and Gradle, integrates with the GDB and LLDB debuggers, can be used with version control systems like Git, test libraries like Boost.Test, and various documentation tools. It has features such as code generation, refactoring, on the fly code analysis, symbol navigation, and more. 
https://www.jetbrains.com/clion/Qt Creator is a (non)commercial IDE from The Qt Company which supports Windows, macOS, and Linux. Qt  Creator has features such as a UI designer, syntax highlighting, auto-completion, and integration with a number of different modern C++ compilers like GCC and Clang. Qt Creator tightly integrates with the Qt library for rapidly building cross-platform applications. Additionally, it integrates with standard version control systems like Git, debuggers like GDB and LLDB, build systems like CMake, and can deploy cross-platform to iOS and Android devices. 
https://www.qt.io/C++Builder is a commercial IDE from Embarcadero Technologies which runs on Windows and supports modern C++. It features the award-winning Visual Component Library (VCL) for Windows development and FireMonkey (FMX) for cross-platform development for Windows, iOS and Android. The C++Builder compiler features an enhanced version of Clang, an integrated debugger, visual UI designer, database library, comprehensive RTL, and standard features like syntax highlighting, code completion, and refactoring. C++Builder has integrations for CMake, can be used with Ninja, and also MSBuild. 
https://www.embarcadero.com/products/cbuilder 
https://www.embarcadero.com/products/cbuilder/starterVisual C++ is a commercial Visual Studio IDE from Microsoft. Visual Studio integrates building, debugging, and testing within the IDE. It provides the Microsoft Foundation Class (MFC) library which gives access to the Win32 APIs. Visual Studio features a visual UI designer for certain platforms, comes with MSBuild, supports CMake, and provides standard features such as code completion, refactoring, and syntax highlighting. Additionally, Visual Studio supports a number of other programming languages, and the C++ side of it is focused on Windows, with other platforms slowly being added. 
https://visualstudio.microsoft.com/Xcode is a multi-language IDE from Apple available only on macOS that supports modern C++. Xcode is proprietary but available for free from Apple. Xcode has an integrated debugger, supports version control systems like Git, features a Clang compiler, and utilizes libc++ as its standard library. It supports standard features such as syntax highlighting, code completion, and finally, Xcode supports external build systems like CMake and utilizes the LLDB debugger. 
https://developer.apple.com/xcode/KDevelop  (it’s 0.1 version was released in 1998) is a cross-platform IDE for C, C++, Python, QML/JavaScript and PHP. This IDE is part of the KDE project, and is based on KDE Frameworks and Qt. The C/C++ backend uses Clang and LLVM. 
It has UI integration with several version control systems: Git, SVN, Bazaar and more, build process based on CMake, QMake or custom makefiles. Among many interesting features, it’s essential to mention advanced syntax colouring and Context-sensitive, semantic code completion.https://www.kdevelop.org/ 
https://www.kdevelop.org/featuresThe Eclipse C/C++ Development Toolkit (CDT) is a combination of the Eclipse IDE with a C++ toolchain (usually GNU - GCC).  This IDE supports project creation and build management for various toolchains, like the standard make build. CDT IDE offers source navigation, various source knowledge tools, such as type hierarchy, call graph, include browser, macro definition browser, code editor with syntax highlighting, folding and hyperlink navigation, source code refactoring and code generation, visual debugging tools, including memory, registers, and disassembly viewers. 
https://www.eclipse.org/cdt/Cevelop is a powerful IDE based Eclipse CDT. Its main strength lies in the powerful refactoring and static analysis support for code modernization. In addition, it comes with unit testing and TDD support for the CUTE unit testing framework. What’s more, you can easily visualize your template instantiation/function overload resolution and optimize includes. 
https://www.cevelop.com/Android Studio is the official IDE for Google’s Android operating system, built on JetBrains’ IntelliJ IDEA software and designed specifically for Android development. It is available for download on Windows, macOS and Linux based operating systems. It is a replacement for the Eclipse Android Development Tools (ADT) as the primary IDE for native Android application development. Android Studio focuses mainly on Kotlin… but you can also write applications in C++.Oracle Developer Studio is Oracle Corporation’s flagship software development product for the Solaris and Linux operating systems. It includes optimizing C, C++, and Fortran compilers, libraries, and performance analysis and debugging tools, for Solaris on SPARC and x86 platforms, and Linux on x86/x64 platforms, including multi-core systems. You can download Developer Studio  at no charge but if you want the full support and patch updates, then you need a paid support contract. The C++ Compiler supports C++14. 
https://www.oracle.com/technetwork/server-storage/developerstudio/overview/index.html 
https://www.oracle.com/technetwork/server-storage/solarisstudio/features/compilers-2332272.htmlIf you want to check some shorter code samples and you don’t want to install the whole compiler/.IDE suite… then we have lots of online tools that can make those tests super simple. Just open a web browser and put the code Compiler Explorer is a web-based tool that allows you to select from a wide variety of C++ compilers and different versions of the same compiler to test out your code. This allows developers to compare the generated code for specific C++ constructs among compilers, and test for correct behaviour. Clang, GCC, and MSVC are all there but also lesser-known compilers such as DJGPP, ELLCC, Intel C++, and others. 
https://godbolt.org/Extra: Here’s a list of handy online compilers that you can use: like Coliru, Wandbox, CppInsighs and more: https://arnemertz.github.io/online-compilers/GDB is a portable command-line based debugging platform that supports modern C++ and is available under an open-source license (GPL). A number of editors and IDEs like Visual Studio, Qt Creator, and CLion support integration with GDB. It can also be used to debug applications remotely where GDB is running on one device, and the application being debugged is running on another device. It supports a number of platforms including Windows, macOS, and Linux. 
https://www.gnu.org/software/gdb/LLDB is an open-source debugging interface that supports modern C++ and integrates with the Clang compiler. It has a number of optional performance-enhancing features such as JIT but also supports debugging memory, multiple threads, and machine code analysis. It is built in C++. LLDB is the default debugger for Xcode and can be used with Visual Studio Code, CLion, and Qt Creator. It supports a number of platforms including Windows, macOS, and Linux. 
https://lldb.llvm.org/On Windows, you can use several debuggers, ranging from Visual Studio Debugger (integrated and one of the most user-friendly), WinDBG, CDB and several more.WinDbg is a multipurpose debugger for the Microsoft Windows Platform. It can be used to debug user-mode applications, device drivers, and the operating system itself in kernel mode. It has a graphical user interface (GUI) and is more powerful than Visual Studio Debugger. You can debug memory dumps obtained even from kernel drivers.One of the recent exciting features in Debugging on Windows is called Time Travel Debugging (Available in WinDBG Preview and also in Visual Studio Ultimate). It allows you to record the execution of the process and then replay the steps backwards or forwards. This flexibility enables us to easily tracks back the state that caused a bug.https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/ 
https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overviewRR is an advanced debugger that aims to replace GDB on Linux. It offers the full state recordings of the application so that you can replay the action backwards and forwards (similarly to Time Travel Debugging). The debugger is used to work with large applications like Chrome, OpenOffice or even Firefox code bases. 
https://rr-project.org/Catch2 is a cross-platform open-source (BSL-1.0) testing framework for modern C++. It is very lightweight because only a header file needs to be included. Unit tests can be tagged and run in groups. It supports both test-driven development and behaviour-driven development. Catch2 also easily integrates with CLion. 
https://github.com/catchorg/Catch2Boost.Test is a feature-rich open-source (BSL-1.0) testing framework that utilizes modern C++ standards. It can be used to quickly detect errors, failures, and time outs through customizable logging and real-time monitoring. Tests can be grouped into suites, and the framework supports both small scale testing and large scale testing. 
https://github.com/boostorg/testGoogle Test is Google’s C++ testing and mocking framework, which is available under an open-source (BSD) license. Google test can be used on a broad range of platforms, including Linux, macOS, Windows, and others. It contains a unit testing framework, assertions, death tests, detects failures, handles parameterized tests, and creates XML test reports. 
https://github.com/google/googletestCUTE is a unit testing framework integrated into Cevelop, but it can also be used standalone.  It spans C++  versions from c++98 to c++2a and is header-only. While not as popular as  Google Test it is less macro-ridden and uses macros only, where no appropriate C++ feature is available. In addition, it features a mode that easily allows it to run on embedded platforms, by sidestepping some of the I/O formatting features. 
https://cute-test.com/DocTest is a single-header unit testing framework. Available for C++11 up to C++20 and is easy to configure and works on probably all platforms. It offers regular TDD testing macros (also with subcases) as well as BDD-style test cases. 
http://bit.ly/doctest-docs 
https://github.com/onqtam/doctestMull is an LLVM-based tool for Mutation Testing with a strong focus on C and C++ languages. In general, it creates many variations of the input source code (using LLVM bytecode) and then checks it against the test cases. Thanks to this advanced testing technique, you can make your code more secure. 
https://github.com/mull-project/mull 
PDF: https://lowlevelbits.org/pdfs/Mull_Mutation_2018.pdfSanitizers are relatively new tools that add extra instrumentation to your application (for example they replace new/malloc/delete calls) and can detect various runtime errors: leaks, use after delete, double free and many others. To improve your build pipeline, many guides advice to add sanitizers steps when doing tests. Most sanitizers come from the LLVM/Clang platform, but now they also work with GCC. Unfortunately not yet with Visual Studio (but you can try Application Verifier).Valgrind is an instrumentation framework for building dynamic analysis tools. There are Valgrind tools that can automatically detect many memory management and threading bugs, and profile your programs in detail. When you run a program through Valgrind it’s run on a virtual machine that emulates your host environment. Having that abstraction the tools can leverage various information about the source code and its execution. 
http://valgrind.org/ 
http://valgrind.org/info/about.html 
http://valgrind.org/docs/manual/quick-start.htmlHeapTrack is a FOSS project and a heap memory profiler for Linux. It traces all memory allocations and annotates these events with stack traces. The tool has two forms the command line version that grabs the data, and then the UI part that you can use to read and analyze the results. This tool is comparable to Valgrind’s massif; it’s easier to use and should be faster to load and analyze for large projects. 
https://github.com/KDE/heaptrackDr. Memory is an LGPL licenced tool that allows you to monitor and intensify memory -related errors for binaries on Windows, Linux, Mac, Android. It’s based on the DynamoRIO dynamic instrumentation tool platform. With the tool, you can find errors like double frees, memory leaks, handle leaks (on Windows), GDI issues, access to uninitialized memory or even errors in multithreading memory scenarios. 
http://drmemory.org/ 
https://github.com/DynamoRIO/drmemoryThe primary role of Deleaker is to find leaks in your native applications. It supports Visual Studio (since 2008 till the latest 2019 version), Delphi/C++ Builder, Qt Creator, CLion (soon!). Can be used as an extension in Visual Studio or as a standalone application. Deleaker tracks leaks in C/C++ applications (Native and CLR), plus .NET code. Memory (new/delete, malloc…), GDI objects, User32 objects, Handles, File views, Fibres, Critical Sections, and even more. It gathers full call stack, ability to take snapshots, compare them, view source files related to allocation. 
https://www.deleaker.com/ 
https://www.deleaker.com/docs/deleaker/tutorial.htmlI hope that with the above list, you get a useful overview of the tools that are essential for C++ development.If you want to read more about other ecosystem elements: libraries, frameworks, and other tools, then please see the full report from Embarcadero: 
C++ Ecosystem White Paper 
(It’s a nice looking pdf, with more than 20 pages of content!)You might check this Resource for a super long list of tools, libs, frameworks that enhance C++ development: 
https://github.com/fffaraz/awesome-cppWhat are your favourite tools that you use when writing C++ apps?",cpp
30,"Two weeks ago, I had a pleasure to give a talk at our local C++ User Group in Cracow. This time I spoke about vocabulary types from C++17: std::optional, std::variant and std::any.Have a look at the slides and extended comments. 

During the presentation, I tried to explain the motivation and some most crucial use cases for the new types that we got in C++17.For example for std::variant we can experiment with the code for computing roots of an equation:// aX^2 + bX + c
? ? ? FindRoots(double a, double b, double c)
{
    const auto delta = b * b - 4.0 * a * c;

    if (delta > EPSILON)
    {
        const auto p = sqrt(delta);
        const auto x1 = (-b + p) / (2.0 * a);
        const auto x2 = (-b - p) / (2.0 * a);
        return ? ?
    }
    else if (delta < -EPSILON)
        return ? ? // no roots in real numbers...

    return -b / (2.0 * a);    
}What type should we return? How to transfer the information that we might have none, one or two roots of the equation?Some options:Or we can use std::variant:// aX^2 + bX + c
using TRoots = std::variant<std::monostate, 
                            double, 
                            std::pair<double, double>>;

TRoots FindRoots(double a, double b, double c)
{
    const auto delta = b*b-4.0*a*c;

    if (delta > EPSILON)
    {
        auto p = sqrt(delta);
        double x1 = (-b + p)/(2*a);
        double x2 = (-b - p)/(2*a);
        return std::pair(x1, x2);
    }
    else if (delta < -EPSILON)
        return std::monostate();

    return -b/(2*a);         
}Now, with std::variant we can express all the possible options without any hacks or output parameters.What do you think about such design?If you want to learn more about those types, you can also read the following blog posts:Plus each of the types has a separate chapter in my book:",cpp
31,"Last week was an important milestone for my book: it got a print version available at Amazon! In this post, I’ll share some details behind the event and the plans.Since March 2019, I’ve been testing a few platforms that offer print on demand. One book came from Lulu.com, and others from Amazon KDP. And I decided to stick with the latter.The KDP program is quite easy to use. You upload a manuscript, then the cover pdf (or you can use their simple builtin editor) and then you go through the review process. The system shows some potential errors (like symbols outside the print margins), or some unwanted artefacts. Several times I also ordered proof copies so I could see the almost final version.Here are some pictures of the internals:And another one: 
And here’s the back cover:And of course,  Amazon has a super-wide market share, so it’s easier to sell books through that platform. It’s also not the cheapest…For example, my book contains 378 pages, and it costs 5.39$ to print, then Amazon takes an additional 40% or even 60% (for the extended distribution option). Unless I sell hundreds of thousands of copies, I won’t be a millionaire :)Here’s the link to the US shop: 
 Here are the links to all Amazon stores where the book is available: If you own the ebook version, last week you should also get a notification about a book update. So the books are now in sync.List of changes in this update:  So far, the book was mentioned in several places.The book is listed in one of the articles from the Visual C++ Team: 
Books on C++17 | Visual C++ Team BlogThere’s a review at CppDepend blog: 
C++ 17 In Detail Book Review – CppDepend Blog (including a little discount)And there’s also a GoodReads page: 
C++17 in Detail @GoodReadsIf you (probably through some company account) have access to Skillsoft library, then you should be able to find my book there!Thanks to the collaboration with the team @Educative we published C++17 in Detail as an interactive course! 
You can see it… and even preview it for free here: 
>> C++17 in Detail: A Deep Dive  It consists of 200 lessons, many quizzes, code snippets… and what’s best is that it has more than 120 playgrounds! That means you can compile and edit code sample directly in the browser… so there’s no need for you to switch back and forth to some compiler/IDE. 
I think that such an approach increases your learning experience.  The book is now complete. I might do some smaller updates, but they will be mostly related to polishing the content, wording.I’m aware that I skipped a few things during the writing process. For example I haven’t mentioned anything about updates to aggregate initialisation (P0017), shared_mutex, std::launder, Hardware Interference sizes, std::invoke… and probably a few other smaller types and functions. I might cover them in separate blog posts.Now I need to “close” this chapter a bit and focus on new things related to C++20! I hope to gather the experience from C++17 in Detail and build a solid foundation for my new projects :)I appreciate your initial feedback and support! The book has now almost 1500 readers (and only nine refunds)!Let me know what’s your experience with the book. What would you like to change? What would you like to see more?Add your feedback/review here: 
https://www.goodreads.com/book/show/41447221-c-17-in-detailYou can use this comment site: 
https://leanpub.com/cpp17indetail/feedbackOr forum: 
https://community.leanpub.com/c/cpp17indetailTill the end of September, the book has a quite low price - only 25.99$ (Amazon US, and other book stores proportionally).As you see, this price is even lower than the suggested price for ebook version (more or less it’s the minimal price at Leanpub + printing costs). 
Since October this price will be increased to around 32$Buy the book here: 
https://www.amazon.com/dp/1798834065  ",cpp
32,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 6st and 13th September 2019.Today you will find links to an article about how to implement StringConvertible concept, how to get started with Modern C++, an article about issues with C++20 Ranges, new books and many other!Marius Bancila wrote a blog post about C++20’s Concepts implementation in the preview version of MSVC 16.3 (see tools section later). Have a quick look at how to implement StringConvertible concept: 
mariusbancila.ro/blog/2019/09/12/cpp20-concepts-in-visual-studio-2019-16-3-preview-2/Shafik Yaghmour wrote a summary of how to get started with Modern C++. See the recommended books, videos and other sources. Shafik also describes a set of handy tools to help you with coding. 
shafik.github.io/c++/learning/2019/09/05/getting_started_learning_cpp.html
And here's a GitHub repo where you can add your ideas: github.com/shafik/cpp_learning
A new episode of C++ Weekly from Jason Turner - he explains what is a high-order-function (functions that take other functions as arguments or return a function) 
youtube.com/watch?v=NoIJoL3cIJ4Jonathan Boccara, on his blog, showed how he changed his pipes library recently. In short, he had some dirty workaround called pipes::funnel, that was replaced with the detection idiom:  
fluentcpp.com/2019/09/10/good-news-for-the-pipes-library-pipesfunnel-is-now-gone/In the second article at FluentC++, this time we have a guest post with a negative view about Ranges that went into C++20. The author describes the downsides of the new library: compile-time, incrementing smart iterators and other limitations: 
fluentcpp.com/2019/09/13/the-surprising-limitations-of-c-ranges-beyond-trivial-use-cases/ 
The article also has a long discussion at this r/cpp threadSecond post from Marius Bancila - he described const, constexpr, consteval and constinit (from C++20 perspective) 
mariusbancila.ro/blog/2019/09/10/let-there-be-constants/New post from Rainer Grimm - about profiles inside C++ Core Guidelines. Profiles are a subset of rules of the C++ core guidelines for specific concerns such as type safety, bounds safety, and lifetime safety: 
modernescpp.com/index.php/profiles-in-the-c-core-guidelinesNew CppCast episode - interview with Miro Knejp, about upcoming CppCon and the C++ extensions that are out there and probably won’t ever be standardized: 
cppcast.com/miro-knejp-cpp-extensions/Video from CopperSpice - about std::any and std::optional: 
youtube.com/watch?v=6A3Y3YDTC-0“C++17 in Detail” by Bartlomiej Filipek is now available in Print @Amazon!“C++17 - The Complete Guide” by Nicolai Josuttis is also available in Print @Amazon!

Extra: See meeting C++ Blog roll from 6th September: 
meetingcpp.com/blog/blogroll/items/Meeting-Cpp-Blogroll-200.htmlThe links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
33,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 31st August and 6th September 2019.Today you will find links to a video about raw string literals, myths about C++ good practices, a Ranges library on GPU and more.Rainer Grimm, in his new post, describes some myths about C++, suggested by readers of his blog. For example - why using const reference for all passed parameters, it’s not the best idea:  
modernescpp.com/index.php/more-myths-of-my-blog-readersIn new C++ Weekly Jason Turner shows what are raw string literals and how to use it effectively:  
youtube.com/watch?v=DiZ-az_nJMMJonathan Boccara continues describing his iterator library. This time he improves “demux”. The previous post can be found here: 
fluentcpp.com/2019/09/03/the-demux-pipe/Everyone during coding in C++ asked himself at least once: “Why is the compiler trying to copy my move-only object?”. Botand Ballo is answering this question in his new article: 
botondballo.wordpress.com/2019/09/03/a-case-study-in-analyzing-c-compiler-errors-why-is-the-compiler-trying-to-copy-my-move-only-object/Great article from Paweł Dziepak. He wrote a Ranges library (similar to range-v3) executed on GPUs, in which he deals with memory throughput, instruction latency, superoptimisers, intra-block and intra-warp thread synchronisation. 
pdziepak.github.io/2019/09/01/on-gpus-ranges-latency-and-superoptimisers/Article from the Conan team - introduction to deterministic builds in C/C++. Why is it important to have them, and what are the problems in that area: 
blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.htmlNew CppCast episode - interview with Craig Scott, a CMake developer: 
cppcast.com/craig-scott-cmake/Do you remember the article about Dropbox moving away from C++? Here’s another text that defends C++. It’s more about the backed side (not the frontend as in Dropbox) however: 
https://dev.to/tanker/reacting-to-dropbox-another-take-on-cross-platform-c-development-42o0The Meeting C++ blog, published a list of User Group meetings for September. Have a look: 
C++ User Group Meetings in September 2019There will be also a meeting in Cracow about vocabulary types in C++:  
Coding with vocabulary types from C++17: optional, variant, any | Cracow C++ UGThe links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
34,"Last week’s article about smaller C++17 features mentioned updated operator new() that handles non-standard alignment of objects. How does it work? Can you use it to ask for arbitrary alignments? Let’s try some code and have a closer look.Last update: 9th September 2019Let’s examine the first example:#include <cassert>
#include <cstdint>
#include <iostream>
#include <malloc.h>
#include <new>

class alignas(32) Vec3d { 
    double x, y, z;
};

int main() {
    std::cout << ""sizeof(Vec3d) is "" << sizeof(Vec3d) << '\n';
    std::cout << ""alignof(Vec3d) is "" << alignof(Vec3d) << '\n';

    auto Vec = Vec3d{};
    auto pVec = new Vec3d[10];

    if(reinterpret_cast<uintptr_t>(&Vec) % alignof(Vec3d) == 0)
        std::cout << ""Vec is aligned to alignof(Vec3d)!\n"";
    else
        std::cout << ""Vec is not aligned to alignof(Vec3d)!\n"";

    if(reinterpret_cast<uintptr_t>(pVec) % alignof(Vec3d) == 0)
        std::cout << ""pVec is aligned to alignof(Vec3d)!\n"";
    else
        std::cout << ""pVec is not aligned to alignof(Vec3d)!\n"";

    delete[] pVec;
}The code shows a structure - Vec3d that uses three double fields; it also marks the type with alignas that makes the objects aligned to 32 bytes.Then the example creates two objects: one on the stack and one on the free store.Do they both have the same alignment (32 bytes)?And another question:Should you care about the alignment of your memory allocations?Let’s try to answer the second question first:In general… in most of the cases… probably not :)But you may need that for some CPU optimisations or general system requirements (for example some embedded environments, drivers, kernel code, or hardware-specific conditions).In my experience, I used it for SIMD code that processed particles. I wanted my types to fit nicely in SSE2/AVX registers: Flexible Particle System - Code Optimisation.Other needs for alignment, have a look at those questions/answers:And please let me know in comments if you had to align your data in some non-standard way? I wonder how often programmers need to use this technique. Maybe it's only 0.001% of C++ coders or 50%?Returning to our code, let’s try to answer the first question about the alignment.Let’s try C++11/14 with GCC 4.8.5: (See @Wandbox):sizeof(Vec3d) is 32
alignof(Vec3d) is 32
Vec is aligned to alignof(Vec3d)!
pVec is not aligned to alignof(Vec3d)!And how about C++17, for example GCC 9.1 (see @Wandbox)izeof(Vec3d) is 32
alignof(Vec3d) is 32
Vec is aligned to alignof(Vec3d)!
pVec is aligned to alignof(Vec3d)!What happened here?In both compiler results, the alignment of objects on the stack is 32, as expected.But for dynamic allocation it’s different:In C++11 and C++14, there was no guarantee that memory allocated for types that are over-aligned honours that specific alignment. In our case we want Vec3d allocations to return pointers that are 32-byte aligned… but GCC 4.8.5 allocates differently.How about C++17?Now, in the newest standard, we have updated dynamic memory allocations, and now we have a guarantee that the memory will be aligned as requested.As you see in GCC 9.1, the memory is now 32-byte aligned.You can try other numbers, for example, try 64 bytes, 128, etc… but remember than alignment must be a power of two.OK, but how does it work?In C++17, We have now 14 global new() function overloads and 8 class-specific methods!Plus corresponding delete functions.C++17 added overloads that have new parameter: std::align_val_tIt’s defined as follows:enum class align_val_t : std::size_t {};It uses a handy C++17 feature to enable initialisation of scoped enums with the underlying type. That’s why you can write:align_val_t myAlignment { 32 }; // no need to cast to size_t!And we have new() operators as below:void* operator new  ( std::size_t count, std::align_val_t al);See all of them here @cppreferenceHow does it work?What’s the difference when you type:auto p = new int{};and auto pVec = new Vec3{};How does the compiler select the function overload? Does it always use overrides with alignment parameters?By default, the popular compilers use 16-byte alignment. We can even check it because there’s now new predefined macro (since C++17):__STDCPP_DEFAULT_NEW_ALIGNMENT__MSVC, GCC and Clang specify it as 16.Now, when you ask for memory allocation that requires alignment larger than this default value the compiler will use overloads with the proper alignment parameter.It’s not possible to change the default value in MSVC (see this discussion): Add compiler switch to change __STDCPP_DEFAULT_NEW_ALIGNMENT___.But on Clang there’s a compiler option:fnew-alignment.Not sure about GCC though…As usual with operator new() you can also provide replaced implementation. For example:void* operator new(std::size_t size, std::align_val_t align) {
#if defined(_WIN32) || defined(__CYGWIN__)
    auto ptr = _aligned_malloc(size, static_cast<std::size_t>(align));
#else
    auto ptr = aligned_alloc(static_cast<std::size_t>(align), size);
#endif

    if (!ptr)
        throw std::bad_alloc{};

    std::cout << ""new: "" << size << "", align: "" 
              << static_cast<std::size_t>(align) 
              << "", ptr: "" << ptr << '\n';

    return ptr;
}

void operator delete(void* ptr, std::size_t size, std::align_val_t align) noexcept {
    std::cout << ""delete: "" << size << "", align: "" 
              << static_cast<std::size_t>(align) 
              << "", ptr : "" << ptr << '\n';
#if defined(_WIN32) || defined(__CYGWIN__) 
    _aligned_free(ptr);
#else
    free(ptr);
#endif
}

void operator delete(void* ptr, std::align_val_t align) noexcept {
    std::cout << ""delete: align: "" 
              << static_cast<std::size_t>(align) 
              << "", ptr : "" << ptr << '\n';
#if defined(_WIN32) || defined(__CYGWIN__)
    _aligned_free(ptr);
#else
    free(ptr);
#endif
}And here’s some test code:class alignas(32) Vec3dAVX { 
    double x, y, z;
};

int main() {
    std::cout << ""__STDCPP_DEFAULT_NEW_ALIGNMENT__ is "" 
              << __STDCPP_DEFAULT_NEW_ALIGNMENT__ << std::endl;

    std::cout << ""sizeof(Vec3dAVX) is "" << sizeof(Vec3dAVX) << '\n';
    std::cout << ""alignof(Vec3dAVX) is "" << alignof(Vec3dAVX) << '\n';
    auto pVec = new Vec3dAVX[10];
    assert(reinterpret_cast<uintptr_t>(pVec) % alignof(Vec3dAVX) == 0);
    delete[] pVec;

    auto p2 = new int[10];
    delete[] p2;
}The output:__STDCPP_DEFAULT_NEW_ALIGNMENT__ is 16
sizeof(Vec3dAVX) is 32
alignof(Vec3dAVX is 32
new: 320, align: 32, ptr: 0x2432e00
delete: align: 32, ptr : 0x2432e00Play with the example @WandboxAs you see the custom code was called for the allocation of Vec3dAVX, but not for int. This is because int used default alignment and it was smaller than __STDCPP_DEFAULT_NEW_ALIGNMENT__.You can also try changing the alignment of Vec3dAVX from 32 into 16, and you’ll see that the custom code won’t be called.And here's a playground where you can change the code and play:So far I showed you examples where types have alignment specified as alignas declaration. But in theory we can even ask for the alignment when calling placement new:auto pAlignedInt = new(std::align_val_t{ 64 }) int[10];
delete[] pAlignedInt;but now we got into troubles… at least on MSVC where I got the following error:error C2956:  sized deallocation function 'operator delete(void*, size_t)' 
              would be chosen as placement deallocation function.See this note Using c++17 new (std::align_val_t(n)) syntax results in error C2956.on GCC there’s no warning… but maybe it’s wrong and unsafe? Do you know which delete function needs to be called to release the memory properly?While we have placement new, there’s no placement delete. So to handle the deallocation properly, you need to call correct delete operator:::operator delete(pAlignedInt, std::align_val_t{64});What’s worse, now you also have to call the destructor for your objects! While the delete expression calls the destructor, it doesn’t happen with explicit call to delete function!So for types that have constructor/destructors you need to call destructor first:auto pAlignedType= new(std::align_val_t{ 32 }) MyType;
pAlignedType->~MyType();
::operator delete(pAlignedType, std::align_val_t{32});It’s not as nice as you see, and you need to remember about the alignment used in the new expression and call the proper delete function. So maybe the error reported by MSVC is a good thing and can save you some bugs…While memory allocated using std::aligned_alloc can be released using free() in MSVC it's not supported, and you need to use _aligned_malloc() and _alined_free(). On Windows there's a separate allocation mechanism for objects that use non-default alignments.You can admit, the whole article is about quite low-level stuff. Maybe even not typical for most of the daily tasks.What’s more, Modern C++ states that we shouldn’t even touch raw new and delete and rely on the standard containers or smart pointers.So what’s the deal here?In fact, the new new() allows us to stick to that rule even better!I didn’t write about that in the initial article, but one of the readers made a valuable comment:I thought we were not supposed to use “new” anymore?You can also see this suggestion in the core guidelines:C++ Core Guidelines - R.11: Avoid calling new and delete explicitlyAnd there was also one comment at r/cpp where an example from the Eigen library was mentioned.Eigen: Using STL Containers with EigenIf you’re compiling in [c++17] mode only with a sufficiently recent compiler (e.g., GCC>=7, clang>=5, MSVC>=19.12), then everything is taken care by the compiler and you can stop reading.All in all, if you previously needed to use _aligned_malloc or custom allocators explicitly, now, you can clean-up the code and rely on the compiler!Consider the following code which uses our previous example with 32-byte aligned Vec3dAVX class:std::cout << ""std::vector\n"";
std::vector<Vec3dAVX> vec;
vec.push_back({});
vec.push_back({});
vec.push_back({});
assert(reinterpret_cast<uintptr_t>(vec.data()) % alignof(Vec3dAVX) == 0);Play @WandboxAnd here’s the output I got (using our custom new/delete replacements)new: 32, align: 32, ptr: 0xf1ec60
new: 64, align: 32, ptr: 0xf1ece0
delete: 32, align: 32, ptr : 0xf1ec60
new: 128, align: 32, ptr: 0xf1ed80
delete: 64, align: 32, ptr : 0xf1ece0
delete: 128, align: 32, ptr : 0xf1ed80The code above creates a vector of aligned objects, and it will resize the container three times to accommodate three elements. Firstly it tries with only 32 bytes, then with 64 bytes and then 128 bytes (so four elements could be stored).As you can see, the code also checks if the memory allocated internally by the vector is still aligned correctly. And it seems to work fine :)Here are some other issues with “old” new(): 
* c++11 - Using STL vector with SIMD intrinsic data type - Stack Overflow 
* c++ - Making std::vector allocate aligned memory - Stack OverflowAnd now, in C++17, those problems are gone… for example you can hold specialized SIMD helper type __m256 in a vector:std::vector<__m256> vec(10);
vec.push_back(_mm256_set_ps(0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f));
assert(reinterpret_cast<uintptr_t>(vec.data()) % alignof(__m256) == 0);In fact, the whole deal about the new functionality is that you can forgot about the limitation of over-aligned data. It lets you write regular modern C++ code without worrying about specialized allocators or raw memory handling functions like std::aligned_alloc() or _aligned_malloc().
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in C++17, check it out here:This article described the basic idea behind the new operator new() that can guarantee alignment for types that are “over aligned”.Such technique might help with existing code that uses library functions like std::aligned_alloc or _aligned_malloc/_aligned_free() (for MSVC). And now rather than handling memory on your own you can rely on new/delete operators and still benefit from required alignment.References:The feature is available in GCC: 7.0, Clang: 4.0 and MSVC: 2017 15.5Questions for you",cpp
35,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 16th and 24th August 2019.Today you will find links new operator new, bind_front implementation, SFINAE techniques and much more.Bartłomiej Filipek wrote an article about dynamic memory allocation for over-aligned data: 
bfilipek.com/2019/08/newnew-align.htmlGuest post on FluentCpp. The author shows how to implement classical interview question - fizzbuzz - with C++17 std::optional: 
fluentcpp.com/2019/08/20/a-concise-implementation-of-fizzbuzz-with-stdoptional/Post from Ádám Balázs. He showed how to write readable code with SFINAE. He also shows how we can use if constexpr and upcoming concepts: 
fluentcpp.com/2019/08/23/how-to-make-sfinae-pretty-and-robust/Rainer Grimm showed another two myths about C++ defined in C++ Core Guidelines: 
modernescpp.com/index.php/c-core-guidelines-more-non-rules-and-mythsJason Turner on C++ Weekly continues with his bind_front implementation, he tries to fix it with lambda. WARNING! The content may be offensive or disturbing to some audiences ;)  
youtube.com/watch?v=s2Kqcn5e73cNew Overload Magazine! - inside you will find an article about low-latency logging framework, C++ reflection for python bindings and more: 
isocpp.org/blog/2019/08/overload-152-is-now-availableArticle from Ben Deane, explaining why a large number of upcoming C++20 features is not a bad thing: 
elbeno.com/blog/?p=1619Arthur O’Dwyer showed what problems we can encounter because of rule of zero and self assignments: 
quuxplusone.github.io/blog/2019/08/20/rule-of-zero-pitfall/New CppCast episode - interview with Marco Magdy, about AWS Lambda: 
cppcast.com/marco-magdy/The Second article from Barry Revzin this week, it’s about Unified Function Call Syntax (UFCS). This time he showed how it can make writing algorithms much easier. He also describes how new operator |> may work: 
brevzin.github.io/c++/2019/08/22/ufcs-custom-extension/The links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
36,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 9th and 16th August 2019.Today you will find links to a list of smaller C++17 features, a free book about Intel TBB and parallel programming, why Dropbox is moving away from C++ and many more!C++17 offers many big features, like structured bindings, if constexpr, filesystem, parallel algorithms… but how about those smaller elements? In a new article, Bartek covers 17 less significant parts of C++17:. For example sample(), from_chars, map and set improvements, scoped_lock: 
Bartek’s coding blog: 17 Smaller but Handy C++17 FeaturesFree book on intel TBB (might also help with C++17 Parallel algorithms, for example GCC’s implementation uses TBB internally): 
Link to the book 
reddit/r/cpp discussionSome time ago, Dropbox was proud that they use C++ to have a single codebase for various platforms. After some evaluation, the team changed the opinion and decided that it actually was a bad idea:  
The (not so) hidden cost of sharing code between iOS and Android | Dropbox Tech BlogJonathan Boccara provides two new articles about his “Pipes” Library. The lib comes from his work on smart output iterators, and now it got a proper name. Have a look at how to use that in your code. You can also contribute to the project: 
Smart Output Iterators >>= become(Pipes) - Fluent C++ 
Making C++ Pipes Compatible with STL Algorithms - Fluent C++ 
GitHub: joboccara/pipes: Smart iterators for operating on collections in C++Rainer Grim in his new article, discusses myths about C++. For example, single return statement, exception usage and a few others. 
C++ Core Guidelines: Non-Rules and Myths - ModernesCpp.comRob and Jason talk about mdspan, r/cpp and CppCon 2019 with Bryce Adelstein Lelbach 
C++Cast: mdspan and /r/cppJason Turner, in a new episode of C++ Weekly, discusses the meaning of whitespace in your source code: 
https://www.youtube.com/watch?v=JqhbzY04VlETools updates:Visual Studio Team continues their articles about new and improved features of VS 2019.2, this time you can read about:Resharper gets a massive update recently. Have a look at their blog post describing the features: 
ReSharper C++ 2019.2: Faster indexing, improved C++20 support, new code analysis checks, and better Unreal Engine support - ReSharper C++ BlogReSharper C++ BlogThe links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
37,"When you see an article about new C++ features, most of the time you’ll see a description of major elements. Looking at C++17, there are a lot of posts (including articles from this blog) about structured bindings, filesystem, parallel algorithms, if constexpr, std::optional, std::variant… and other prominent C++17 additions.But how about those smaller parts? Library or language improvements that didn’t require decades to standardise or violent “battles” at the ISO meetings.In this article, I’ll show you 17 smaller C++17 things that will improve your code.Let’s start with the language changes first. C++17 brought larger features like structured bindings, if constexpr, folding expressions, updated expression evaluation order - I consider them as “significant” elements.Yet, there are also smaller updates to the language that make it clearer and also allows you to write more compact code. Have a look below:If you work with SIMD instructions (for example to improve performance of some calculations, or in graphics engined, or in gamedev), you might often find some C-looking code to allocate memory.For example aligned_malloc() or _aligned_malloc() and then aligned_free().Why might you need those functions? It’s because if you have some specific types, like a Vec3 that has to be allocated to 128bits alignment (so it can fit nicely in SIMD registers), you cannot rely on Standard C++ new() functions.struct alignas(16) Vec3 {
    float x, y, z;
};

auto ptr = new Vec3[10];To work with SSE you require the ptr to be aligned to 16-byte boundary, but in C++14 there’s no guarantee about this. I’ve even seen the following guides in CERT:MEM57-CPP. Avoid using default operator new for over-aligned types - SEI CERT C++ Coding Standard - ConfluenceOr here: Is there any guarantee of alignment of address return by C++’s new operation? - Stack Overflow.Fortunately, the C++17 standard fixes this by introducing allocation functions that honour the alignment of the object.For example we have:void* operator new[](std::size_t count, std::align_val_t al);Now, when you allocate an object that has a custom alignment, then you can be sure it will be appropriately aligned.Here’s some nice description at MSVC pages: /Zc:alignedNew (C++17 over-aligned allocation).When a class contains static data members, then you had to provide their definition in a corresponding source file (in only one source file!).Now, in C++17, it’s no longer needed as you can use inline variables! The compiler will guarantee that a variable has only one definition and it’s initialised only once through all compilation units.For example, you can now write:// some header file...
class MyClass {
    static inline std::string startName = ""Hello World"";
};The compiler will make sure MyClass::startName is defined (and initialised!)) only once for all compilation units that include MyClass header file.You can also read about global constants in a recent article at Fluent C++: 
What Every C++ Developer Should Know to (Correctly) Define Global Constants where inline variables are also discussed.C++17 offers a handy preprocessor directive that allows you to check if the header is present or not.For example, GCC 7 supports many C++17 library features, but not std::from_chars, while GCC 9.1 is has updated support for that function.With __has_include we can write the following code:#if defined __has_include
#    if __has_include(<charconv>)
#        define has_charconv 1
#        include <charconv>
#    endif
#endif

std::optional<int> ConvertToInt(const std::string& str) {
    int value { };
    #ifdef has_charconv
        const auto last = str.data() + str.size();
        const auto res = std::from_chars(str.data(), last, value);
        if (res.ec == std::errc{} && res.ptr == last)
            return value;
    #else
        // alternative implementation...
    #endif

    return std::nullopt;
}In the above code, we declare has_charconv based on the __has_include condition. If the header is not there, we need to provide an alternative implementation for ConvertToInt.If you want to read more about __has_include, then see my recent article: Improve Multiplatform Code With __has_include and Feature Test Macros.With each release of C++, its Standard Library grows substantially. The Library is still not as huge as those we can use in Java or .NET frameworks, but still, it covers many useful elements.Plus not to mention that we have boost libs, that serves as the Standard Library 2.0 :)In C++17, a lot of new and updated elements were added. We have a big features like the filesystem, parallel algorithms and vocabulary types (optional, variant, any). Still, there are lots (and much more than 17) that are very handy.Let’s have a look:In C++11 and C++14, we got many traits that streamlined template code. Now we can make the code even shorter by using variable templates.All the type traits that yields ::value got accompanying _v variable templates. For example:std::is_integral<T>::value has std::is_integral_v<T>std::is_class<T>::value has std::is_class_v<T>This improvement already follows the _t suffix additions in C++14 (template aliases) to type traits that “return” ::type. One example:// before C++17
template <typename Concrete, typename... Ts>
enable_if_t<is_constructible<Concrete, Ts...>::value, unique_ptr<Concrete>>
constructArgsOld(Ts&&... params)
{
    return std::make_unique<Concrete>(forward<Ts>(params)...);
}

template <typename Concrete, typename... Ts>
enable_if_t<!is_constructible<Concrete, Ts...>::value, unique_ptr<Concrete> >
constructArgsOld(...)
{
    return nullptr;
}Can be shorten (along with using if constexpr) into:template <typename Concrete, typename... Ts>
unique_ptr<Concrete> constructArgs(Ts&&... params)
{  
  if constexpr (is_constructible_v<Concrete, Ts...>)
      return make_unique<Concrete>(forward<Ts>(params)...);
   else
       return nullptr;
}Also, if you want to create your custom trait that returns ::value, then it’s a good practice to provide helper variable template _v as well:// define is_my_trait<T>...

// variable template:
template< class T >
inline constexpr bool is_my_trait_v = is_my_trait<T>::value;C++17 adds handy template metafunctions:Here’s an example, based on the code from the proposal (P0006):#include<type_traits>

template<typename... Ts>
std::enable_if_t<std::conjunction_v<std::is_same<int, Ts>...> >
PrintIntegers(Ts ... args) { 
    (std::cout << ... << args) << '\n';
}The above function PrintIntegers works with a variable number of arguments, but they all have to be of type int.A surprisingly simple metafunction that maps a list of types into void:template< class... >
using void_t = void;Extra note: Compilers that don’t implement a fix for CWG 1558 (for C++14) might need a more complicated version of it.The void_t technique was often used internally in the library implementations, so now we have this helper type in the standard library out of the box.void_t is very handy to SFINAE ill-formed types. For example it might be used to detect a function overload:void Compute(int &) { } // example function

template <typename T, typename = void>
struct is_compute_available : std::false_type {};

template <typename T>
struct is_compute_available<T, 
           std::void_t<decltype(Compute(std::declval<T>())) >> 
               : std::true_type {};

static_assert(is_compute_available<int&>::value);
static_assert(!is_compute_available<double&>::value);is_compute_available checks if a Compute() overload is available for the given template parameter.If the expression decltype(Compute(std::declval<T>())) is valid, then the compiler will select the template specialisation. Otherwise, it’s SFINEed, and the primary template is chosen (I described this technique in a separate article: How To Detect Function Overloads in C++17, std::from_chars Example).This function was already mentioned in previous items, so let’s now see what’s that all about.from_chars gives you low-level support for text to number conversions! No exceptions (as std::stoi, no locale, no extra memory allocations), just a simple raw API to use.Have a look at the simple example:#include <charconv> // from_char, to_char
#include <iostream>
#include <string>

int main() {
    const std::string str { ""12345678901234"" };
    int value = 0;
    const auto res = std::from_chars(str.data(), 
                                     str.data() + str.size(), 
                                     value);

    if (res.ec == std::errc()) {
        std::cout << ""value: "" << value 
                  << "", distance: "" << res.ptr - str.data() << '\n';
    }
    else if (res.ec == std::errc::invalid_argument) {
        std::cout << ""invalid argument!\n"";
    }
    else if (res.ec == std::errc::result_out_of_range) {
        std::cout << ""out of range! res.ptr distance: "" 
                  << res.ptr - str.data() << '\n';
    }
}The example is straightforward, it passes a string str into from_chars and then displays the result with additional information if possible.The API is quite “raw”, but it’s flexible and gives you a lot of information about the conversion process.Support for floating-point conversion is also possible (at least in MSVC, but still not implemented in GCC/Clang - as of August 2019).And if you need to convert numbers into strings, then there’s also a corresponding function std::to_chars.Let’s now move to the area of maps and sets, in C++17 there a few helpful updates that can bring performance improvements and cleaner code.The first example is that you can now move nodes from one tree-based container (maps/sets) into other ones, without additional memory overhead/allocation.Previously you needed to copy or move the items from one container to the other.For example:#include <set>
#include <string>
#include <iostream>

struct User {
    std::string name;

    User(std::string s) : name(std::move(s)) {
        std::cout << ""User::User("" << name << "")\n"";
    }
    ~User() {
        std::cout << ""User::~User("" << name << "")\n"";
    }
    User(const User& u) : name(u.name) { 
        std::cout << ""User::User(copy, "" << name << "")\n"";
    }

    friend bool operator<(const User& u1, const User& u2) {
        return u1.name < u2.name;
    }
};

int main() {
    std::set<User> setNames;
    setNames.emplace(""John"");
    setNames.emplace(""Alex"");
    std::set<User> outSet;

    std::cout << ""move John...\n"";
    // move John to the outSet
    auto handle = setNames.extract(User(""John""));
    outSet.insert(std::move(handle));

    for (auto& elem : setNames)
        std::cout << elem.name << '\n';

    std::cout << ""cleanup...\n"";
}Output:User::User(John)
User::User(Alex)
move John...
User::User(John)
User::~User(John)
Alex
cleanup...
User::~User(John)
User::~User(Alex)
In the above example, one element “John” is extracted from setNames into outSet. The extract method moves the found node out of the set and physically detaches it from the container. Later the extracted node can be inserted into a container of the same type.Let’s see another improvement for maps:Here’s an example:The behaviour of try_emplace is important in a situation when you move elements into the map:int main() {
    std::map<std::string, std::string> m;
    m[""Hello""] = ""World"";

    std::string s = ""C++"";
    m.emplace(std::make_pair(""Hello"", std::move(s)));

    // what happens with the string 's'?
    std::cout << s << '\n';
    std::cout << m[""Hello""] << '\n';

    s = ""C++"";
    m.try_emplace(""Hello"", std::move(s));
    std::cout << s << '\n';
    std::cout << m[""Hello""] << '\n';
}The code tries to replace key/value[""Hello"", ""World""] into [""Hello"", ""C++""].If you run the example the string s after emplace is empty and the value “World” is not changed into “C++”! try_emplace does nothing in the case where the key is already in the container, so the s string is unchanged.Another method is insert_or_assign().It inserts a new object in the map or assigns the new value. But as opposed to operator[] it also works with non-default constructible types.Also, the regular insert() method will fail if the element is already in the container, so now we have an easy way to express “force insertion”.For example:struct User {
    // from the previous sample...
};

int main() {
    std::map<std::string, User> mapNicks;
    //mapNicks[""John""] = User(""John Doe""); // error: no default ctor for User()

    auto [iter, inserted] = mapNicks.insert_or_assign(""John"", User(""John Doe""));
    if (inserted)
        std::cout << iter->first << "" entry was inserted\n"";
    else 
        std::cout << iter->first << "" entry was updated\n"";
}This one finishes the section about ordered containers.Since C++11 most of the standard containers got .emplace* methods. With those methods, you can create a new object in place, without additional object copies.However, most of .emplace* methods didn’t return any value - it was void. Since C++17 this is changed, and they now return the reference type of the inserted object.For example:// since C++11 and until C++17 for std::vector
template< class... Args >
void emplace_back( Args&&... args );

// since C++17 for std::vector
template< class... Args >
reference emplace_back( Args&&... args );This modification should shorten the code that adds something to the container and then invokes some operation on that newly added object.For example: in C++11/C++14 you had to write:std::vector<std::string> stringVector;

stringVector.emplace_back(""Hello"");
// emplace doesn't return anything, so back() needed
stringVector.back().append("" World"");one call to emplace_back and then you need to access the elements through back().Now in C++17, you can have one liner:std::vector<std::string> stringVector;    
stringVector.emplace_back(""Hello"").append("" World"");New algorithm  - std::sample - that selects n elements from the sequence:#include <iostream>
#include <random>
#include <iterator>
#include <algorithm>

int main() {
    std::vector<int> v { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    std::vector<int> out;
    std::sample(v.begin(),               // range start
                v.end(),                 // range end
                std::back_inserter(out), // where to put it
                3,                       // number of elements to sample
                std::mt19937{std::random_device{}()});

    std::cout << ""Sampled values: "";
    for (const auto &i : out)
        std::cout << i << "", "";
}Possible output:Sampled values: 1, 4, 9, 
The C++17 Standard extended the library with a few extra functions.We have a simple functions like clamp , gcd and lcm :#include <iostream>
#include <algorithm>  // clamp
#include <numeric>    // for gcm, lcm

int main() {
    std::cout << std::clamp(300, 0, 255) << ', ';   
    std::cout << std::clamp(-10, 0, 255) << '\n'; 

    std::cout << std::gcd(24, 60) << ', ';
    std::cout << std::lcm(15, 50) << '\n';    
}you can find even more math functions, special math functions like reinam_zeta, besel, etc… in the following paper https://wg21.link/N1542Before C++17, only unique_ptr was able to handle arrays out of the box (without the need to define a custom deleter). Now it’s also possible with shared_ptr.std::shared_ptr<int[]> ptr(new int[10]);Please note that std::make_shared doesn’t support arrays in C++17. But this will be fixed in C++20 (see P0674 which is already merged into C++20)Another important remark is that raw arrays should be avoided. It’s usually better to use standard containers. So is the array support not needed? I even asked that question at Stack overflow some time ago:c++ - Is there any use for unique_ptr with array? - Stack OverflowAnd that rose as a popular question :)Overall sometimes you don’t have the luxury to use vectors or lists - for example, in an embedded environment, or when you work with third-party API. In that situation, you might end up with a raw pointer to an array. With C++17, you’ll be able to wrap those pointers into smart pointers (std::unique_ptr or std::shared_ptr) and be sure the memory is deleted correctly.With C++11 and C++14 we got the threading library and many support functionalities.For example, with std::lock_guard you can take ownership of a mutex and lock it in RAII style:std::mutex m;

std::lock_guard<std::mutex> lock_one(m);
// unlocked when lock_one goes out of scope...The above code works, however, only for a single mutex. If you wanted to lock several mutexes, you had to use a different pattern, for example:std::mutex first_mutex;
std::mutex second_mutex;

// ...

std::lock(fist_mutex, second_mutex);
std::lock_guard<std::mutex> lock_one(fist_mutex, std::adopt_lock);
std::lock_guard<std::mutex> lock_two(second_mutex, std::adopt_lock);
// ..With C++17 things get a bit easier as with std::scoped_lock you can lock several mutexes at the same time.std::scoped_lock lck(first_mutex, second_mutex);C++17 not only added lots of elements to the language and the Standard Library but also cleaned up several places. I claim that such clean-up is also as “feature” as it will “force” you to use modern code style.One of the best parts! Since C++11, we have smart pointers that properly support move semantics.auto_ptr was an old attempt to reduce the number of memory-related bugs and leaks… but it was not the best solution.Now, in C++17 this type is removed from the library, and you should really stick to unique_ptr, shared_ptr or weak_ptr.Here’s an example where auto_ptr might cause a disc format or a nuclear disaster:void PrepareDistaster(std::auto_ptr<int> myPtr) {
    *myPtr = 11;
}

void NuclearTest() {
    std::auto_ptr<int> pAtom(new int(10));
    PrepareDistaster(pAtom);
    *pAtom = 42; // uups!
}PrepareDistaster() takes auto_ptr by value, but since it’s not a shared pointer, it gets the unique ownership of the managed object. Later, when the function is completed, the copy of the pointer goes out of scope, and the object is deleted.In NuclearTest() when PrepareDistaster() is finished the pointer is already cleaned up, and you’ll get undefined behaviour when calling *pAtom= 32.With the addition of lambda expressions and new functional wrappers like std::bind() we can clean up old functionalities from C++98 era.Functions like bind1st()/bind2nd()/mem_fun(),  were not updated to handle perfect forwarding, decltype and other techniques from C++11. Thus it’s best not to use them in modern code. Here’s a list of removed functions from C++17:For example to replace bind1st/bind2nd you can use lambdas or std::bind (available since C++11) or std::bind_front that should be available since C++20.// old:
auto onePlus = std::bind1st(std::plus<int>(), 1);
auto minusOne = std::bind2nd(std::minus<int>(), 1);
std::cout << onePlus(10) << "", "" << minusOne(10) << '\n';

// a capture with an initializer
auto lamOnePlus = [a=1](int b) { return a + b; };
auto lamMinusOne = [a=1](int b) { return b - a; };
std::cout << lamOnePlus(10) << "", "" << lamMinusOne(10) << '\n';

// with bind:
using namespace std::placeholders; 
auto onePlusBind = std::bind(std::plus<int>(), 1, _1);
std::cout << onePlusBind(10) << ',';
auto minusOneBind = std::bind(std::minus<int>(), _1, 1);
std::cout << minusOneBind(10) << '\n';The example above shows one “old” version with bind1st and bind2nd and then provides two different approaches: with a lambda expression and one with std::bind.
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in Modern C++, check it out here:


The list is not full, and we can add more and more things, for example, I skipped std::launder,  direct initialisation of enum classes, aggregate changes, or other removed features from the library.The list consists of my picks… but what are yours? 
What’s your favourite small feature that improved (or you think might improve) your code?",cpp
38,"


Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 2nd and 9th August 2019.Today you will find links to ideas on how to Fix C++, how to bring more performance for SIMD math library with C++17, how QT 6 will look like, and more.At the official QT blog, there’s a new article that shows the future of QT6.  The report shows the next version of QML, compiling QML to efficient C++ and native code, Rendering Hardware Interface  (to support modern Graphics API), and C++17! 
Technical vision for Qt 6 - Qt BlogYou might hear about Agner’s CPU guides and his math library. Recently the library was improved and thanks to many C++17 features it’s even faster, and the code is more compact! 
Agner’s CPU blog - Major update of Vector Class LibraryMathieu Ropert, in his new blog post, writes about debugging and what it really means in C++? Is this always related to debug symbols, or maybe using no optimisations? He also discusses his recent twitter poll on the same topic. 
Fifty shades of debug · Mathieu RopertHow can we fix C++ without breaking the backward compatibility? Or maybe we can create C++2.0 and then start without the ballast? In his new controversial article, Vittorio Romero addresses that problem and discusses how we can solve this. 
vittorio romeo’s website - fixing c++ with epochsThis week Jonathan Bocarra from FluentC++ discusses smart output iterators: how they can combine with ranges, and how to chain them: 
Chaining Output Iterators Into a Pipeline - Fluent C++ 
Combining Ranges and Smart Output Iterators - Fluent C++Rainer Grim in his new article, discusses extra bits of Core Coding Guidelines. This time we have something about architectural ideas and lib dependencies: 
C++ Core Guidelines: Supporting Sections - ModernesCpp.comWith the release of VS 2019 16.2 the MSVC team has released many articles describing the new features and updates. This time you can read about getting 2..3% perf increase by smarter code optimisation and linker work: 
Game performance improvements in Visual Studio 2019 version 16.2 | C++ Team BlogThe PVS Studio Team has released a new article that will help you set up the PVS studio on Linux. 
Getting Started with the PVS-Studio Static Analyzer for C++ Development under LinuxThe links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
39,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 27th July and 2nd August 2019.Today you will find links to Bugs in Game Engines, articles about C++14 and C++20, debugging move techniques, hot to break RAII and more.Move semantics is really complicated. Sometimes move is not performed even if we assumed differently. Bartłomiej Filipek on his blog showed how to check if an object was moved, copied or copy elision was performed: 
bfilipek.com/2019/07/move-debug.htmlBarry Revzin, on his blog, described spaceship operator. A really long and detailed article, definitely worth reading:  
brevzin.github.io/c++/2019/07/28/comparisons-cpp20/Rainer Grimm, in his new article, shows you a nasty way how to break RAII. I hope you won’t find such code in your project, but it’s good to know this trick: 
modernescpp.com/index.php/c-core-guidelines-when-raii-breaksWe all know that “inline” doesn’t mean that some part of code will be copy-pasted into proper line. The compiler makes such a decision. If you are curious how it works, you must read post on MSVC site: 
devblogs.microsoft.com/cppblog/inlining-decisions-in-visual-studio/Guest post on Jonathan Boccara’s Blog, describing how static code analysis can improve working with large legacy C++ codebase 
fluentcpp.com/2019/07/30/why-static-analysis-can-improve-a-complex-c-codebase/Didn’t have time to learn C++14? Jason Turner on C++ Weekly talk briefly about most important C++14 features 
youtube.com/watch?v=mXxNvaEdNHIDidn’t have time to learn C++20? On hackaday there is a good summary of the upcoming standard: 
hackaday.com/2019/07/30/c20-is-feature-complete-heres-what-changes-are-coming/This time the PVS Studio Team analyse source code of Red Dead Redemption’s Bullet Engine. They showed 15 interesting bugs found there:  
habr.com/en/company/pvs-studio/blog/461841/Another article from Barry Revzin - he describes how to handle enums with a lambda, to be sure we don’t forget any value inside switch/case: 
brevzin.github.io/c++/2019/08/01/enums-default/Rob and Jason are joined by Clare Macrae to discuss Approval Tests and how they can be used to test legacy C++ code quickly. 
cppcast.com/2019/08/clare-macrae/Tools updates:The links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
40,"C++11 brought Move Semantics. Since then we have extra capabilities to write faster code, support movable-only types, but also more headaches :). At least I have, especially when trying to understand the rules related to that concept. What’s more, we also have copy elision, which is a very common optimisation (and even mandatory in several cases in C++17).  If you create an object based on another one (like a return value, or assignment), how do you know if that was copied or moved?In this article I’ll show you two ways how to determine the status of a new object - copied, moved or copy-elision-ed. Let’s start!Usually, when I try to show in my code samples that some object was moved or copied, I declared move operations for my type and then logged the message.That worked, but how about built-in types? For example std::string or std::vector?One day I was discussing a code sample related to std::optional and JFT (a very experienced developer and very helpful!! See his articles here or here).He showed me one trick that is simple but is very useful.Let’s have a look at those two techniques now.That’s the most “explicit” way of showing if something was moved: add extra code to log inside move/copy constructors.If you have a custom type and you want to see if the object was moved or not, then you can implement all the required move operations and log a message.For a sample class, we have to implement all special member methods (the rule of five):class MyType {
public:
    MyType(std::string str) : mName(std::move(str)) { 
        std::cout << ""MyType::MyType "" << mName << '\n'; 
    }
    ~MyType() { 
        std::cout << ""MyType::~MyType "" << mName << '\n'; 
    }
    MyType(const MyType& other) : mName(other.mName) { 
        std::cout << ""MyType::MyType(const MyType&) "" << mName << '\n'; 
    }
    MyType(MyType&& other) noexcept : mName(std::move(other.mName)) { 
        std::cout << ""MyType::MyType(MyType&&) "" << mName << '\n'; 
    }
    MyType& operator=(const MyType& other) { 
        if (this != &other)
            mName = other.mName;
        std::cout << ""MyType::operator=(const MyType&) "" << mName << '\n'; 
        return *this;
    }
    MyType& operator=(MyType&& other) noexcept { 
        if (this != &other)
            mName = std::move(other.mName);
        std::cout << ""MyType::operator=(MyType&&) "" << mName << '\n'; 
        return *this; 
    }

private:
    std::string mName;
};(The above code uses a simple approach to implement all operations. It’s C++, and as usual, we have other possibilities, like the copy and swap idom).Update: move and move assignment should be also marked with noexcept. This improves exception safety guarantees and helps when you put your class in STL containers like vectors (see this comment: http://disq.us/p/23dfunz below the article). And also Core Guideline - C.66When all of the methods are implemented, we can try using this type and checking the log output. Of course, if you have a more complicated class (more member variables), then you have to “inject” the logging code in the appropriate places.One basic test:MyType type(""ABC"");    
auto tmoved = std::move(type);The output:MyType::MyType ABC
MyType::MyType(MyType&&) ABC
MyType::~MyType ABC
MyType::~MyType 
Here,   the compiler used move constructor. The content was stolen from the first object, and that’s why the destructor prints empty name.How about move assignment?The second test:MyType tassigned(""XYZ"");
MyType temp(""ABC"");
tassigned = std::move(temp);And the log message:MyType::MyType XYZ
MyType::MyType ABC
MyType::operator=(MyType&&) ABC
MyType::~MyType 
MyType::~MyType ABC
This time the compiler created two objects and then the content of XYZ is overridden by ABC.Play with the code @Coliru.Or below:Logging is relatively straightforward, but what’s the second option we could use?In the previous section, we worked with a custom type, our class. But what if you have types that cannot be modified? For example: the Standard Library types, like std::vector or std::string. Clearly, you shouldn’t add any logging code into those classes :)A motivating code:#include <iostream>
#include <string>

std::string BuildString(int number) {
    std::string s { "" Super Long Builder: "" };
    s += std::to_string(number);
    return { s };
}

int main()
{
    auto str42 = BuildString(42);
    std::cout << str42;
}In the above code, what happens to the returned value from BuildString()? Is it copied, moved or maybe the copy is elided?Of course, there are rules that specify this behaviour which are defined in the standard, but if we want to see it and have the evidence, we can add one trick.What’s that?Look at their .data() property!For example, you can add the following log statement:std::cout << &s << "", data: "" << static_cast<void *>(s.data())  << '\n';To the BuildString function and to main(). With that we might get the following output:0x7ffc86660010, data: 0x19fec40
0x7ffc866600a0, data: 0x19fec20
Super Long Builder: 42The addresses of strings 0x7ffc86660010 and 0x7ffc866600a0 are different, so the compiler didn’t perform copy elision.What’s more, the data pointers 0x19fec40 and 0x19fec20 are also different.That means that the copy operation was made!How about changing code from return { s }; into return s;?In that context we’ll get:0x7ffd54532fd0, data: 0xa91c40
0x7ffd54532fd0, data: 0xa91c40
Super Long Builder: 42Both pointers are the same! So it means that the compiler performed copy elision.And one more test: return std::move(s);:0x7ffc0a9ec7a0, data: 0xd5cc50
0x7ffc0a9ec810, data: 0xd5cc50This time the object was moved only. Such behaviour is worse than having full copy elision. Keep that in mind.You can play with code sample @ColiruA similar approach will work with std::vector - you can also look at vector::data property.All in all:Here’s another example, this time the function returns optional<vector>, and we can leverage the second technique and look at the address.#include <iostream>
#include <string>
#include <vector>
#include <optional>

std::vector<int> CreateVec() {
    std::vector<int> v { 0, 1, 2, 3, 4 };
    std::cout << std::hex << v.data() << '\n';
    //return {std::move(v)}; // this one will cause a copy
    return (v); // this one moves
    //return v; // this one moves as well
}

std::optional<std::vector<int>> CreateOptVec() {
    std::vector<int> v { 0, 1, 2, 3, 4 };
    std::cout << static_cast<void *>(v.data()) << '\n';
    return {v}; // this one will cause a copy
    //return v; // this one moves
}

int main() {
    std::cout << ""CreateVec:\n"";
    auto vec = CreateVec();
    std::cout << static_cast<void *>(vec.data()) << '\n';

    std::cout << ""CreateOptVec:\n"";
    auto optVec = CreateOptVec();
    std::cout << static_cast<void *>(optVec->data()) << '\n';
}Play with code @ColiruOr below:The example uses two functions that create and return a vector of integers and optional of vector of integers. Depending on the return statement, you’ll see different output. Sometimes the vector is fully moved, and then the data pointer is the same, sometimes the whole vector is elided.This article is a rather straightforward attempt to show the “debugging” techniques you might use to determine the status of the object.In one case you might want to inject logging code into all of the copy/move/assignment operations of a custom class. In the other case, when code injections are not possible, you can look at the addresses of their properties.In the example section, we looked at the samples with std::optional, std::vector and also a custom type.I believe that such checks might help in scenarios where you are not sure about the state of the object. There are rules to learn. Still, if you see proof that an object was moved or copied, it’s more comfortable. Such checks might allow you to optimise code, improve the correctness of it and reduce some unwanted temporary objects.Some extra notes:Once again, thanks to JFT for valuable feedback for this article!Some referencesHow about your code? Do you scan for move/copy operations and try to optimise it better? Maybe you found some other helpful technique?",cpp
41,"

Welcome to new C++ Links - most relevant and useful articles, podcasts and videos that happen between 19th and 26th of July 2019.Today you will find links to Cologne Trip reports, where the final shape of C++20 was formulated! And then you’ll also read about constant globals, __has_include and some tools updates.A new episode of C++Cast with two guests, Botond Ballo and Tom Honermann. This time they discuss what happened in the last ISO Meeting In Cologne. 
cppcast.com/2019/07/botond-ballo-tom-honermann/lSpeaking about Cologne. Here’s a full trip report build at r/cpp. This is a massive summary of all the elements that were merged into the upcoming C++20 standard. 
/r/cpp/comments/cfk9de/201907_cologne_iso_c_committee_trip_report_the/lAfter r/cpp thread we also have a Trip Report from Herb Sutter. He discusses the overall shape of C++20 and the standardisation process. 
herbsutter.com/2019/07/20/trip-report-summer-iso-c-standards-meeting-cologne/One of the features of C++20 is a new way to print and format text through std::format. This is a library based on the {fmt} library by Victor Zverovich. See the full story behind this process: 
zverovich.net/2019/07/23/std-format-cpp20.htmlThis week on fluentcpp there’s a super thorough article about constant globals in C++. See how you can optimise the final binary size, what are the tricks and what was improved in C++17 - especially through inline variables. 
fluentcpp.com/2019/07/23/how-to-define-a-global-constant-in-cpp/In Friday’s article on fluentcpp, you can read about how to compose containers with strong types. Variadic templates in use, so be prepared :) 
fluentcpp.com/2019/07/26/strong-types-on-collections/Article about using a fresh __has_include utility from C++17 and also feature test macros adopted for C++20. With both parts, you can effortlessly test for a feature existence. 
bfilipek.com/2019/07/hasincludeThe links are brought to you through collaboration with Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
42,"Two weeks ago, I showed you a sample that can detect if a function has a given overload. The example revolved around std::from_chars - low-level conversion routine for C++17.  In the example, some “heavy” template patterns helped me to write the final code (most notably std::void_t and if constexpr).  Maybe there are some other techniques we can use to check if a feature is available or not?Today I’d like to have a look at __has_include and discuss the upcoming feature test macros that we’ll have in C++20.For many years __has_include was available as an extension in Clang. Now it’s in the Standard!As the name suggests, it can help us checking if a given header exists. For example, OpenGL headers under MacOS are located in OpenGL\ directory, while on other platforms they are in GL\. Usually, we can check for a platform macro and write the following code:#ifdef __APPLE__
#   include <OpenGL/gl.h>
#   include <OpenGL/glu.h>
#else
#   include <GL/gl.h>
#   include <GL/glu.h>
#endifWith __has_include the previous code can be rewritten into:#if __has_include(<GL/gl.h>)
#   include <GL/gl.h>
#   include <GL/glu.h>
#else
#   include <OpenGL/gl.h>
#   include <OpenGL/glu.h>
#endifNow, the code doesn’t depend on the platform name, which might be better in some cases.What’s more, we can leverage it to test for a whole feature of C++. For example, GCC 7 supports many C++17 features, but not std::from_chars, while GCC 9.1 is improved and contains that header.We can write the following code:#if defined __has_include
#    if __has_include(<charconv>)
#        define has_charconv 1
#        include <charconv>
#    endif
#endif

std::optional<int> ConvertToInt(const std::string& str) {
    int value { };
    #ifdef has_charconv
        const auto last = str.data() + str.size();
        const auto res = std::from_chars(str.data(), last, value);
        if (res.ec == std::errc{} && res.ptr == last)
            return value;
    #else
        // alternative implementation...
    #endif

    return std::nullopt;
}In the above code, we declare has_charconv based on the __has_include condition. If the header is not there, we need to provide an alternative implementation for ConvertToInt. You can check this code against GCC 7.1 and GCC 9.1 and see the effect as GCC 7.1 doesn’t expose the charconv header.For example at @WandboxAnother example is related to optional. The paper that proposes __has_include (P0061) shows the following example:#if __has_include(<optional>)
#  include <optional>
#  define have_optional 1
#elif __has_include(<experimental/optional>)
#  include <experimental/optional>
#  define have_optional 1
#  define experimental_optional 1
#else
#  define have_optional 0
#endif

// later in code
#if have_optional == 1
#ifndef experimental_optional 
std::optional<int> oint;
#else
std::experimental::optional<int> oint;
#endif
/// ...Now, we check for optional, and we can even try switching back to experimental/optional.__has_include is available even without the C++17 flag switch, that’s why you can check for a feature also if you work in C++11, or C++14 “mode”.Thanks to comments at r/cpp (Thanks to Billy O'Neil) I realised that I skipped one important aspect: what if a compiler/library provides only header stubs? You might think that a feature is enabled, but the header is “empty”.Let’s have a look at a <execution> header - that should mean if parallel algorithms are available (in C++17).If you compile with C++14 flag, then the header is “empty”:// MSVC 2019:
// ...
// ...

#if _HAS_CXX17      // <<!!
#include <algorithm>
// ... the rest
#endif _HAS_CXX17   // <<!!Similarly GCC and Clang also check if you compiler with the C++17 flag (or above).If you compile with a wrong language flag, then the header will be present and __has_include returns 1, but still the feature is turned off.__has_include can check for a full header, and it’s convenient when a feature has a separate file (assuming it's not a stub). But what if you want to check for some small feature that shares the same source file? Or when you ask for a general feature like if if constexpr is available?It appears we might get some help in C++20 :)In C++20 we’ll have standardised feature test macros that simplify checking C++ feature existence. For example, you’ll be able to test for std::optional through __cpp_lib_optional or even if the compiler supports an attribute: __has_cpp_attribute.The code from the previous section about optional can be simplified a bit as we don’t need to define have_optional macros:#if __has_include(<optional>)
#  include <optional>
#else __has_include(<experimental/optional>)
#  include <experimental/optional>
#  define experimental_optional 1
#endif

// later:
#ifdef __cpp_lib_optional   // <<
#  ifndef experimental_optional 
   std::optional<int> oint;
#  else
   std::experimental::optional<int> oint;
#endifGCC, Clang and Visual Studio exposes many of the macros already, even before C++20 is ready. Before C++20 we can also look at boost.config that already exposes lots of macros that defines if a compiler support given feature. For many compilers boost has to use complex checks, for example:// BOOST_NO_CXX11_LAMBDAS
#if (BOOST_INTEL_CXX_VERSION >= 1200) && \
 (!defined(BOOST_INTEL_GCC_VERSION) || \
 (BOOST_INTEL_GCC_VERSION >= 40500)) && (!defined(_MSC_VER) || \
 (_MSC_VER >= 1600))
#  undef BOOST_NO_CXX11_LAMBDAS
#endifBut if all compilers support feature test macros, the you’ll be able to just check#if __cpp_lambdas
//code
#endifAs you see that can significantly simplify the code for many libraries that works on many platforms and compilers!Read more in Feature testing (C++20) - cppreference
Sorry for a little interruption in the flow :) 
I've prepared a little bonus if you're interested in C++17, check it out here:With so many different platforms and compilers, it’s sometimes hard to check if you can use some feature or not. This is especially crucial if your code is built on many configurations and systems.Fortunately, with C++17 (through __has_include) and feature test macros in C++20, such tests should be much more straightforward.Have you used __has_include in your code? Did it simplify the check for some header or feature? Let us know in comments!You can also watch Jason Turner’s episode about this feature: C++ Weekly - Ep 23 C++17’s __has_include. His example showed how to check if your code has POSIX support.",cpp
43,"Today is the start day of Summer C++ISO meeting, this time in Cologne, Germany! This is the “feature-complete” meeting for C++20. It’s the last time we’ll see some new elements that are merged into the working draft. Let’s see what’s already in C++20 and let’s have a look at some smaller, but very handy proposals that might get into the standard. This is similar to article that I did for Kona and San Diego Meetings.Update! 20th July 2019: Cologne Meeting has just ended, and we have a nice report what happened. See r/cpp: Cologne ISO C++ Committee Trip Report .Thanks to various trip reports and especially r/cpp threads we can gather a list of features that are already merged into C++20.  I tried to list the most essential elements.(*) Although a lot of items are “merged” into the working draft of the Standard, it’s still not 100% guaranteed that a particular feature will be in the final Standard. There are several review stages that the whole draft has to pass.At cppreference there’s also a single list with all C++20 features: C++2a featuresThe first meeting that discussed and merged things for C++20Gathered from r/cpp - 2017 Toronto ISO C++ Committee Discussion Thread (Concepts in C++20; Coroutines, Ranges and Networking TSes published) 
(Thanks Yehezkel for reminding about that meeting!)Gathered from 2017 Albuquerque ISO C++ Committee Reddit Trip Report : r/cppMore info: 2018 Jacksonville ISO C++ Committee Reddit Trip Report : cppGathered from r/cpp: 2018 Rapperswil ISO C++ Committee Trip ReportAdditionally, during this meeting, the Committee agreed on a single plan for modules, so there’s a higher chance we’ll see them in C++20.Gathered from r/cpp: 2018 San Diego ISO C++ Committee Trip Report and Trip Report: C++ Standards Meeting in San Diego, November 2018 | There’s Waldo!Parallelism TS v2 was also published as ISO/IEC TS 19570:2018 - Programming Languages – Technical Specification for C++ Extensions for Parallelism.Gathered from r/cpp: 2019-02 Kona ISO C++ Committee Trip Report  and Trip report: Winter ISO C++ standards meeting (Kona) – Sutter’s MillOther trip reports:Today (Monday 15th July) the Cologne Meeting has started. There are over 300 papers proposed so the Committee has a lot of to discuss!A few days ago Herb Sutter created a poll that hopefully will help to add your voice into the prioritization of the proposals.Have a look: Your “top five” ISO C++ feature proposalslHerb Sutter also published another blog post with a FAQ of the current standardization process. That’s a great way to learn about why we have 3-year cycle, why C++20 is much bigger than C++17 and C++14 and what’s the overall plan.Draft FAQ: Why does the C++ standard ship every three years?The next meeting will also take place in Europe, this time in Belfast in November 2019.. and then in Prague Spring next year.You can always find the list of ISO meetings here: 
Upcoming Meetings, Past Meetings: Standard C++The papers (mailings) for the upcoming Cologne meeting can be found under the following link: 
JTC1/SC22/WG21 - mailing2019-06.or in a easier-to read form:Below you can find my list of papers that brought my attention. The papers might still not be in merged C++20!. Those are not big features like Modules, Ranges, Networking… but rather some smaller items that should also simplify the language and help in our daily tasks.P0323The initial proposal for this feature was send 5 years ago, later the whole idea was a bit abandoned (without any clear reason). But now the work has been restated with the plan that we might get that into C++20.The helper type would give us another way of reporting errors, and would be an improvement over returning “bool” or error code from functions… For example:Error codes and output parameter:MathError safe_divide(int i,int j, int& outVal) {
    if(j == 0) return MathError::divide_by_zero;
    if(i%j !=0) return MathError::not_integer_division;
    outVal = i/j;
    return MathError::OK;
}With Optional:std::optional<int> safe_divide(int i,int j) {
    if(j == 0) return std::nullopt;
    if(i%j !=0) return std::nullopt;
    return i/j;
}As you see the version with optional doesn’t use the output parameter, but we lose the full information about the error. This can improve with expected:expected<int, error_condition> safe_divide(int i,int j) {
    if(j == 0) return make_unexpected(arithmetic_errc::divide_by_zero);
    if(i%j !=0) return make_unexpected(arithmetic_errc::not_integer_division);

    return i / j;
}You can read about the rationale in the earlier version of the paper, for example V1: P0323R1.One doubt: we have several ways of reporting errors. Is having another method good or will just make our code more complicated and confusing to use?P0881R5This feature is based on a boost library: Boost.Stacktrace 1.0 - 1.70.0 and, as name suggests allows to gather information about the stack frames at runtime.This might be helpful in environments where setting up debuggers is hard and also enhance log messages. For example when an error happens you can also attach the stack information. That will simplify the diagnostics.P1152R3One of the dark corners of C++ is probably how to use volatile properly. The authors of the proposals make a bold suggestion on how to remove this concept from C++ so it doesn’t bother programmers in common code, but still leave it for some specific cases.The ful rationale is nicely explained in the early version of the paper: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.htmlFor example the proposal suggests:I think it might be a good approach to make the language easier without the need to know advanced concepts.This change might break existing code, thus it might take us some time to properly add that into the Standard.Update: This paper was merged into C++20 during the Cologne Meeting! :)P1222A new type of containers in the Standard Library. As you might already know std::set, std::map (and their multi counterparts) are node based containers. They usually form a binary tree and then insertion, find and other operations work on that tree.However, an alternative solution for set is to have a sorted vector of objects. Such approach changes the performance characteristics of the container and has several advantages: especially the cache locality (a vector is contiguous in memory) and less memory consumption. This is especially important for embedded environments, or games or performance critical apps.The downsides: possibly slower insertion and removal time (as we need to sort the vector again after insertion/removal) and we cannot store non-copyable elements inside.A really nice summary can be found in boost: Non-standard containers - 1.70.0 - flat_set.More motivation and scope can be found in the early version of the paper: P1222R0P1708R0New and common stats functions for the Standard Library! The proposal wants to add the following functions into the <numerics> header:For example:std::vector<​int​> v{1, 2, 3, 4, 5, 6};
double ​m1 = std::mean(v.begin(), v.end());
std::cout << ""mean: "" << m1 << '\n'; // mean: 3.5The statistics functions are pure additions to the library, so I don’t see any issues in having them. I wonder if there will be a version with ranges so that you can call std::mean(myRange).C++20 is getting closer and closer. I hope that during the Cologne meeting will have consensus over the major features and we’ll have time to fix bugs on time.In the article, I wanted to show the current list of items in C++20 and also mention some interesting papers that brought my attention.What’s your top five? ",cpp
44,"The problem: a library function offers several overloads, but depending on the implementation/compiler, some of the overloads are not available. How to check the existence of an overload? And how to provide a safe fallback?In this article, I’ll show you a background “theory” and one case - std::from_chars that exposes full support for numbers or only integer support (in GCC, Clang).Before we jump into a more complex problem, let’s start with something simpler. This will allow us to understand the final solution easily.Imagine a library that provides a function Compute() :// lib V1:
void Compute(int in, int& out) { }Later in the second version of the library, you’ll have a new overload. // lib V2:
void Compute(int in, int& out) { }
void Compute(double in, double& out) { }The problem is that you want to have support both int and double in your project no matter what’s the version of the library used. In a case, the library version doesn’t contain a necessary overload you can provide a custom alternative.But how to check it effectively?If you know the version of the library and you have all required defines, you can use preprocessor and create a following solution:// provide custom overload for double if we use V1
#if LIB_VERSION == LIBV1
void Compute(double in, double& out) { /* custom code */ }
#endifIn the above code, you use defines and macros to provide a custom overload for the Compute() function.This might work, but what if you have another version of the library? With even more complex overloads. The #if approach might quickly become a mess of preprocessor code. What if we could “detect” if a function has a given overload?What we need is a way to ask the compiler:// pseudocode:
if (overload Compute(double, double&) not exists) { }While it’s not possible with macros and preprocessor, you can detect a function existence using templates.The detection idiom might work in the following way for our Compute() function:template <typename T, typename = void>
struct is_compute_available : std::false_type {};

template <typename T>
struct is_compute_available<T, 
           std::void_t<decltype(Compute(std::declval<T>(), 
                       std::declval<T&>())) >> : std::true_type {};The above code creates a template structure is_compute_available. By default, the structure derives from false_type. But when you provide a T for which Compute() has an overload, then we “activate” the partial template specialisation that derives from true_type.The core part is  void_t magic that tries to check if the overload is available. If the whole expression is not valid, it’s SFINAEd, and the specialisation is gone. Otherwise, the template specialisation is, and the compiler will select it.std::void_t is a relatively simple template that can help with SFINAE magic. It was added in C++17 and it’s implementation is surprisingly straightforward:template< class... >  
using void_t = void;See more info at cppreferenceThe basic idea is that you can put many compile-time checks, and if something fails, then the whole expression is SFINAEd. This helper type is often used for detection pattern.For our Compute() check we use the following code:template <typename T>
struct is_compute_available<T, 
           std::void_t<decltype(Compute(std::declval<T>(), 
                       std::declval<T&>())) >> : std::true_type {};The internal check uses:decltype(Compute(std::declval<T>(), std::declval<T&>()))What we do here is we’re trying to find the return type of a function overload that takes std::declval<T>() and std::declval<T&>(). std::declval is a helper (added in C++11) that allows us to “pretend” that we have an object of some type (even if default constructor s not available).If Compute() cannot be called with T and T& objects, then the compiler will SFINAE the whole expression inside void_t.Equipped with the tool we can now create the following wrapper code:// helper variable template
template< class T> inline constexpr bool is_compute_available_v = 
          is_compute_available<T>::value;

template <typename T>
void ComputeTest(T val)
{
    if constexpr (is_compute_available_v<T>)
    {
        T out { };
        Compute(val, out);
    }
    else
    {
        std::cout << ""fallback...\n"";
    }
}You can play with code @ColiruOk, so we covered a basic scenario with Compute() function, but let’s check some more practical example. How about implementing a fallback for std::from_chars? This is a robust set of functions that allows fast string to number conversions. I wrote about that feature in my separate article: How to Use The Newest C++ String Conversion Routines.The problem is that on some compilers (GCC and Clang), as of July 2019 not all conversions are possible. For example, in MSVC you can convert into integral types and also into floating point types, but GCC and Clang offer only integer support.So we want to implement:template <typename T>
[[nodiscard]] std::optional<T> TryConvert(std::string_view sv);The function takes a string view and then returns optional<T>. The value will be there if the conversion is possible.In the code samples for my book, I had explicit #ifdefs to check if the code is compiled on MSVC and if not, then I provided some fallback function. But then, after discussion with Jacek Galowicz (Technical Reviewer) we tried to use templated based approach.For example, the basic approach is to check the compiler:// for GCC/Clang:
#ifndef _MSC_VER
template<>
[[nodiscard]] std::optional<double> TryConvert(std::string_view sv) {
    // implementation...
}
#endifThis works, but when GCC and clang improve the Standard Library implementations, then I have to adjust the code.For new C++ features, we can also check their availability by using feature test macros. They are defined for C++20, but most of the compilers support it already.For from_chars we have __cpp_lib_to_chars.Still, this feature test is too broad as it won’t tell us about the floating point support. It would be nice to have some distinct “sub” features enabled in this case.See more test macros @cppreferenceLet’s try with templates.Here’s the detection code:template <typename T, typename = void>
struct is_from_chars_convertible : false_type {};
template <typename T>
struct is_from_chars_convertible<T, 
                 void_t<decltype(from_chars(declval<const char*>(), declval<const char*>(), declval<T&>()))>> 
                 : true_type {};
// std:: omited...And the function:template <typename T>
[[nodiscard]] std::optional<T> TryConvert(std::string_view sv) noexcept {
    T value{ };
    if constexpr (is_from_chars_convertible<T>::value) {
        const auto last = sv.data() + sv.size();
    const auto res = std::from_chars(sv.data(), last, value);
    if (res.ec == std::errc{} && res.ptr == last)
            return value;
    }
    else  {
        try {
            std::string str{ sv };
            size_t read = 0;
            if constexpr (std::is_same_v<T, double>)
                value = std::stod(str, &read);
            else if constexpr (std::is_same_v<T, float>)
                value = std::stof(str, &read);

            if (str.size() == read)
                return value;
        }
        catch (...) {  }
    }
}As the fallback code, we’re using stod or stof depending on the floating point type. The functions require null-terminated strings, so we have to convert from string view into a string before we pass the parameter. This is not the best approach but might work as a fallback solution.You can play with the code @ColiruAdd code like std::cout << ""fallback...""; to check if a fallback was selected or the proper from_chars overload.The code is still not perfect, so I’m happy to see suggestions in the comments. Maybe you can came up with something easier?Working with real examples is better in most of the cases, so I like that we could show how the detection pattern works on a real function: std::from_chars. The full check used various of techniques: SFINAE, void_t, decltype, std::declval, std::true_type, std::false_type and partial template specialisation. Plus we even used if constexpr!I wonder about the compilation time for such templated code. While the preprocessor approach is old-style and not scalable, it’s super simple, and I guess it offers the best compilation time. Having a single SFINAE detector on a function it usually ok, but what if you have tens or hundreds of such checks? I leave that as an open question.Do you use detector pattern in your projects? Let us know in comments below!Here are some good references:",cpp
45,"If you have two function overloads foo(): one is taking const std::string& and the other taking bool. Which one of them will be selected when you call foo(""hello world""); ?Let’s see where such a case might bite us and cause troubles?Here’s the example once againvoid foo(const std::string& in) { std::cout << in << '\n'; }
void foo(bool in) { std::cout << ""bool: "" << in << '\n';}

foo(""Hello World"");What’s the output?. 
. 
.bool: true
And why is that?Let’s see the standard:C++17 Draft: Boolean conversions, conv.bool:A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true….In other words, when performing a function overload resolution lookup the compiler doesn’t have a function that exactly matches the input parameter (it’s an array of const char), so it has to perform a conversion. We have two options: convert to bool or convert to a user defined type (std::string is still a custom type).Both conversion produce a viable function, but (from cppreference):A standard conversion sequence is always better than a user-defined conversion sequenceThat’s why the bool conversion is selected.Of course, the conversion of a pointer to bool is not always causing troubles. For example, you can write:if (myPTR) { }(assuming myPTR is a pointer)Another unwanted scenario that might happen is when you have a std::variant with bools and strings. The same conversion to pointer and to bool might happen.Have a look:std::variant<std::string, bool, int> var { 42 };
var = ""Hello World"";Initially, the variant will have the active type of int, but then you assign a string literal… so it will convert to bool, not to std::string.Same thing can happen when you initialise a variant with const char*:std::variant<std::string, bool, int> var { ""Hello World"" };Fortunately, such unwanted conversions it about to be fixed for a variant. You can check GCC trunk (10.0) which implements already this C++17 fix: A sane variant converting constructor - P0608.The paper adds additional enforcements on the constructor and the assignment operator:Quoting the part from std::variantvariant<float, long, double> v = 0;Before the fix, this line won’t compile (we have several narrowing conversions possible), but after the improvement, it will hold long.Here’s a commit for libstdc++ that implements that change: 
Implement sane variant converting constructor (P0608R3)In this short blog post, I wanted to tackle an issue of unwanted conversions that might happen when selection a function overload, or an alternative type in std::variant. Although for custom types like variant the library implementations can fix unwanted conversions it’s still good to keep your types as much “consistent” as possible so that you limit the number of conversions.You can play with code at @Wandbox and switch between compilers, GCC 9.1 and GCC 10.0 to see the differenceHave you encountered some “unwanted” conversions that cause bugs in your code? Please share your stories in comments.",cpp
46,"Last Friday my book got a fresh update! It’s been three months since the previous release, and this time I brought foreword, new book format and some small content changes. Here are the main changes:First of all the book has now a foreword, and it’s written by Herb Sutter!  Herb Sutter is a key person in the C++ World; he drives the language into a better future. I’m honoured and thankful that he used his precious time and wrote the text!  A quote from that foreword:“If you’ve ever asked “what’s in C++17 and what does it mean for me and my code?” — and I hope you have — then this book is for you.” 
  Now that the C++ standard is being released regularly every three years, one of the challenges we have as a community is learning and absorbing the new features that are being regularly added to the standard language and library. That means not only knowing what those features are, but also how to use them effectively to solve problems. Bartlomiej Filipek does a great job of this by not just listing the features, but explaining each of them with examples…Do you like e-books or prefer their physical version?For me, e-books are very convenient to read and write. This format allowed me even to self publish in an easy way, and they are simple to update.Yet, having a physical copy is my preferred option. For example, I often buy an e-book or download some free pdfs… and then forget to read them. With print books, it’s harder to ignore, and most of the time I do read them :)Since March I’ve been testing some self-printing services with the idea to prepare a physical version of “C++17 in Detail”. It appears that it’s not so hard!Leanpub already offers a “print ready” pdf version which is perfect for sending it to printing services. There’s even Adobe InDesign version if you want to make more adjustments.The first thing I tried was to print it through lulu.com. It was quite quick and in a week or so I got my first version!But, as you can see, the book was too large! Initially, I used some default options - US Letter in the book format setting. It looks good on Desktop, but not when printed.I decided to reduce the size of the book, into Technical, and now it looks like a regular coding book.For the second print, I went with Amazon KDP.Here are the results:All in all, KDP is a bit easier to use than, and what’s more, it can print each copy cheaper. Amazon also gives me access to a broader market so I’ll try to sell my book through that service. I still need to make some small changes in the content, design a back cover, and then it should be ready for printing. I’ll let you know when it’s available.Here’s the link to the book: 


C++17 In Detail @Leanpub
So far, the book was mentioned in several places.The book is listed in one of the articles from the Visual C++ Team: 
Books on C++17 | Visual C++ Team BlogThere’s a review at CppDepend blog: 
C++ 17 In Detail Book Review – CppDepend Blog (including a little discount)And there’s also a GoodReads page: 
C++17 in Detail @GoodReadsIf you (probably through some company account) have access to Skillsoft library, then you should be able to find my book there!Thanks to the collaboration with the team @Educative we published C++17 in Detail as an interactive course! 
You can see it… and even preview it for free here: 
>> C++17 in Detail: A Deep Dive  It consists of 200 lessons, many quizzes, code snippets… and what’s best is that it has more than 120 playgrounds! That means you can compile and edit code sample directly in the browser… so there’s no need for you to switch back and forth to some compiler/IDE. 
I think that such an approach increases your learning experience.  I appreciate your initial feedback and support! The book has now almost 1300 readers (and only nine refunds)!Let me know what’s your experience with the book. What would you like to change? What would you like to see more?Add your feedback/review here: 
https://www.goodreads.com/book/show/41447221-c-17-in-detailYou can use this comment site: 
https://leanpub.com/cpp17indetail/feedbackOr forum: 
https://community.leanpub.com/c/cpp17indetailHere’s the link to the book: 


C++17 In Detail @Leanpub
",cpp
47,"One of a powerful uses of std::variant is to implement State Machines. Some time ago I showed a simple example, but today we have something bigger. In today’s article by Nikolai Wuttke you’ll see how to leverage std::variant and build a space game!This article is a guest post from Nikolai WuttkeNikolai Wuttke is a technical principal at Ableton, a Berlin-based music software company. In his free time, he likes to create metal guitar covers of video game soundtracks, play with his band, collect DOS-era computers, and stare at 16-bit assembly code.One of the new additions C++ 17 brought to the standard library is std::variant, an object which can hold values of different types, but only one type at a time. In type theory, this is called a sum type. It’s a very useful thing to have, and there are many use cases. For a general overview of std::variant and what it can do, have a look at Everything You Need to Know About std::variant from C++17 . In this post, I want to focus on one specific use case: Modelling state machines.State machines have a wide variety of applications, from video games to managing HTTP connections. Whenever you are dealing with an inherently stateful problem, consider using a state machine - it requires you to be very explicit about all the states your system can be in, and all the possible ways to transition between these states. This, in my experience, often results in code that’s more maintainable and easier to understand compared to tracking state in a less structured way (e.g. using a number of boolean values etc.).So what exactly is a state machine? There is a formal definition (finite state machine), but I’ll explain it by example. Let’s say we want to make a space combat game. The player is in control of a spaceship, and has to fight another ship controlled by the computer. The enemy ship should behave as follows:While this is happening, the enemy is also shooting at the player.  
Furthermore, we want the enemy to smoothly transition between being in the center and circling the player.Thus, we have four distinct states the enemy can be in at any given time:If we get to state 4, once we have reached the outer edge of the playing field, we check if the player is still outside the center. Depending on that, we either switch to state 1 (to start circling the player again) or state 2 (to go back into the center).To express this as a state machine, we draw an ellipse for each state, and lines to indicate possible state transitions, resulting in the following diagram:Now, pictures are nice, but we ultimately need to write code in order to make our game. How can we turn this state machine specification into a working implementation?First, we need to keep track of the enemy’s current state. We could use an enum to achieve this:enum class EnemyState {
  Circling,
  FlyToCenter,
  ShootingFromCenter,
  FlyOut
};And if that was the only state we had to keep track of, this would be a great solution. But unless we want our game to be a text adventure, there’s more we need:Expressed in code, that gives us 3 additional state variables:double timeSinceLastShot;
double timeSpentInCenter;

// Assuming we have an array with all corner positions
int targetCornerIndex;Now, we could add these next to a variable of the enum type we declared above, and we would have all the state we need. But there is one problem: All of these variables are only valid in specific states, as shown in the table below: You might ask yourself: “What’s the big deal, I know when to use which variable and I’ll be careful not to use the wrong one at the wrong time.” And you may be right for a simple example like this, but imagine a much more complicated scenario, with many more states, variables, and possible transitions. At some point, it’s going to become tricky to make sure that all variables are only used when they are actually valid, that we reset variables correctly when transitioning between states, etc. Sure, it’s not impossible to get this right, but at what cost in terms of hours spent in front of the debugger? In the end, we are using modern C++ so that we can leverage its features to make our lives easier, right?And that’s where std::variant comes in: By encoding the various states of our state machine as types, we can have exactly the variables we need for a certain state as members of the type representing that state. If we then combine all these types into a variant, we have also encoded the state machine’s current state thanks to the variant knowing which alternative it currently holds. Let’s see how this looks in code:struct Circling
{
  explicit Circling(const int startIndex)
    : mNextCirclePosIndex(startIndex)
  {
  }

  double mTimeSinceLastShot = 0.0;
  int mNextCirclePosIndex = 0;
};


struct FlyToCenter
{
};


struct ShootingFromCenter
{
  double mTimeSinceLastShot = 0.0;
  double mTimeSpentInCenter = 0;
};


struct FlyOut
{
  explicit FlyOut(const int cornerIndex)
    : mTargetCornerIndex(cornerIndex)
  {
  }

  int mTargetCornerIndex;
};

using State = std::variant<
  Circling,
  FlyToCenter,
  ShootingFromCenter,
  FlyOut>;Doing things this way nicely solves our issues with the enum-based approach:The key takeaway is that we’ve now leveraged C++’s type system to make invalid states impossible to represent in our code. This means we have fewer things to think about, since the compiler will catch mistakes for us, and can focus on the really important part: Writing the actual logic. Only one question remains: How do we implement said logic based on a variant?For this, The overload Pattern comes in handy. It allows us to write a lambda as a handler for each of our states, almost like pattern matching - a nice language feature which already exists in various other languages like Scala or Rust, and is a core building block in most functional languages (e.g. Haskell). As of today, we can only emulate pattern matching in C++ using libraries, but there are already proposals on the way to add this as a native language feature in the future (P1371, P1260). So, let’s have a look at implementing our enemy’s update function:mState = match(mState,
    [=](Circling& state) -> State
    {
        // implement circling logic here

        if (playerInOuterZone()) {
          // Switch to next state if applicable
          return FlyToCenter();
        }

        return state;
    },

    [=](const FlyToCenter&) -> State
    {
        // implement flying to center logic here
    },

    [=](ShootingFromCenter& state) -> State
    {
        // implement shooting from center logic here
      },

    [=](const FlyOut& state) -> State
    {
    // implement flying out of center logic here
    }
  );The function match is a little wrapper around the overloaded helper mentioned above, which doesn’t do much besides saving me a little bit of typing, and putting the variant argument first instead of last (see the source).  Here’s the implementation:template <typename Variant, typename... Matchers>
auto match(Variant&& variant, Matchers&&... matchers)
{
    return std::visit(
         detail::overloaded{std::forward<Matchers>(matchers)...},
         std::forward<Variant>(variant));
}In order to implement our state machine, we do a match on our variant, and then have a little bit of logic for each state. This logic involves shooting, moving etc., as well as checking if we need to transition to a new state. If that’s the case, we return a state object representing the state we want to transition to, otherwise we return the current state. Whatever we returned from the chosen lambda is then returned by match and assigned to mState.Why update mState via return value, when we could also capture the this pointer in our lambdas and modify mState directly inside the lambdas? This is a safe-guard to avoid undefined behavior. The problem is that the lambdas take a reference to the current state, which is stored in the variant. If we were to change the variant from inside the lambda, we would turn the lambda’s argument into a dangling reference pointing to an object which is now destroyed. Since the compiler doesn’t prevent us from continuing to access the argument after we’ve assigned to the variant, it’s quite easy to run into undefined behavior if we’re not careful. Since the whole point of using a variant to represent our state machine was making it harder to make mistakes, we should go all the way and make this particular mistake impossible as well.The above mechanism has one drawback: extra state self-assignment when there’s no state change. That’s probably not an issue when the state is simple, but if you want to avoid this cost then you might want to try using std::optional.using MaybeNextState = std::optional<State>;
auto maybeNextState = match(mState,
    [=](Circling& state) -> MaybeNextState 
    {
        // implement circling logic here

        if (playerInOuterZone()) {
          // Switch to next state if applicable
          return FlyToCenter();
        }

        return std::nullopt;
    },...

if (maybeNextState)
  {
    mState = *maybeNextState;
 }Above, we only reassign mState if maybeNextState is present so we avoid extra copies.Note: Such technique was originally implemented by Nikolai, but I wanted to make the code a bit shorter and suggested skipping std::optional. See in this pull request.If you want to see the game discussed in this article in action, check it out on GitHub. The full source is in the state-machine directory. The enemy logic shown above can be found in enemy.cpp.We’ve seen how to implement a simple state machine in a robust way using the C++ 17 standard library and a few lines of utility code. The implementation is quite expressive, and also type-safe, making it harder to make mistakes, while still being fairly lean. I like using this approach whenever I come across a problem that lends itself well to using a state machine. It’s worth noting that this approach to state machines has its limits, so once the number of states and transitions in your state machine reaches a certain size, it might make sense to formalize things a bit more, and look into state machine libraries.You can also see Niko’s presentation from Meeting C++ 2018:",cpp
48,"If you have a map of strings, like std::map<std::string, int> m; and you want to find some element by m.find(""abc""). Do you have to pay the price and construct a std::string object? Can you optimize it? Let’s have a look at one feature enabled in C++14 that might help optimize such container access.Let’s expand the example mentioned earlier.std::map<std::string, int> intMap { 
    { ""Hello Super Long String"", 1 }, 
    { ""Another Longish String"", 2 }, 
    { ""This cannot fall into SSO buffer"", 3 }
};

if (intMap.find(""Hello Super Long String"") != intMap.end())
    std::cout << ""Found \n"";
else
    std::cout << ""Not found\n"";In the above code although “Hello Super Long String” is a string literal, it has to be converted into a regular std::string (so a memory allocation needed here), and then the search is performed.The std::string supports comparing against const char*, so why we cannot use it here?The reason: The definition of the comparator in the map (by default it’s std::less<Key>). It requires that you compare the same types. If you use std::string as a key, you can only compare with std::string, not even with something compatible.Let’s have a look at a larger key for std::set. In that case the lookup cost might be even higher.How about a set container that stores products:struct Product {
    std::string mName;
    std::string mDescription;
    double mPrice;
};

bool operator<(const Product& p1, const Product& p2) { 
    return p1.mName < p2.mName; 
}

std::set<Product> products {
    { ""Car"", ""This is a super car that costs a lot"", 100'000.0 },
    { ""Ball"", ""A cheap but nice-looking ball to play"", 100.0 },
    { ""Orange"", ""Something to eat and refresh"", 50.0 }
};Products are compared by Name, which is a member variable.If you want to find a “Car” then you need to create temporary Product and fill its name:if (products.find({""Car"", """", 0.0}) != products.end())
    std::cout << ""Found\n""; But cannot we specify products.find(""Car"") and provide extra comparison options (comparing vs string_view for example)? Side-note: Another reason for heterogeneous lookup might be when you have a set of movable only objects (one example is a set of unique_ptr). In that case, you cannot compare by creating temporary objects.While it was not possible in C++11, we can do that by using heterogeneous lookup, available since C++14.Now, we can have a look at a possible improvement: heterogeneous lookup in ordered containers.And surprisingly it’s straightforward to enable.All you have to do is to use std::less<> (or some other functor, more on that later) and implement correct comparison functions!For example for the first example with map of std::string:std::map<std::string, int, std::less<>> intMap;And now you can find by using const char* or string_view:if (intMap.find(""Hello Super Long String""))
    std::cout << ""Found \n"";
else
    std::cout << ""Not found\n"";You can play with the code @Coliru.In the previous section, I showed implementation for a map of strings, now let’s cover the example with a set of Products. In this case, the key is much larger.Let’s create an implementation that compares products via string_view.bool operator<(const Product& prod, const std::string_view& sv) { 
    return prod.mName < sv; 
}
bool operator<(const std::string_view& sv, const Product& prod) { 
    return sv < prod.mName; 
}And now we can search:std::set<Product, std::less<>> products { ... };

if (products.find(std::string_view(""Car"")) != products.end())
    std::cout << ""Found \n"";
else
    std::cout << ""Not found\n"";Great! We can search for products by their name without creating temporary objectsYou know how to use such this new search pattern, but how is it implemented? What’s the difference between those two lines:std::map<std::string, int> myMap;
std::map<std::string, int, std::less<>> myOtherMap;The first thing is that myMap declaration resolves tostd::map<std::string, int, std::less<std::string>> myMap; 
// allocator omitted above...The full declaration is as follows:template<class Key, class T,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<std::pair<const Key, T> >
> class map;Note: the text refers to std::less, but the rules apply to all standard functors like std::greater, std::plus, etc, etc. And your custom functors as well.The design choice for heterogeneous lookup suggested using the existing syntax as much as possible, without the need to invent some new extra names (like Greater vs greater).std::less has operator () defined as follows:template <class _Ty = void>
struct less {
    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left < _Right;
    }
};The type must be the same for _Left and _Right.The solution was to specialize std::less for empty (void) and also enhance it with `is_transparent” property.Now we can define a template method (rather than a type) that uses two different (but compatible) types:template <>
struct less<void> { 
    using is_transparent = int;

    // simplified version...
    template <class _Ty1, class _Ty2>
    constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }
};Now _Left and _Right can be distinct types, but they need to be comparable.The find method overload can be defined as:template <class _Other, class _Mycomp = key_compare, 
          class = typename _Mycomp::is_transparent>
iterator find(const _Other& _Keyval) { ... }In other words, if the comparator is transparent (through having is_transparent tag), then the implementation can leverage heterogeneous lookup.You can also implement your custom functions that expose is_transparent. There was even a similar article on that at fluentcpp:  is_transparent: How to search a C++ set with another type than its key - Fluent C++.You can read more about the feature in the proposals that were accepted in C++14: Making Operator Functors greater<>  N3421 and Adding heterogeneous comparison lookup to associative containers - N3657.Ordered containers are implemented as balanced trees. The order is specified by the key you provide in the container declaration. If you try to search for another key, the search might fail.For example, for our std::set<Product> case you might be tempted to search by the price:You need to add comparison functions:bool operator<(const Product& prod, const double& price) { 
    return prod.mPrice < price; 
}
bool operator<(const double& price, const Product& prod) { 
    return price < prod.mPrice; 
}And then the code:std::set<Product, std::less<>> products {
    { ""Car"", ""This is a super car that costs a lot"", 100'000.0 },
    { ""Ball"", ""A cheap but nice-looking ball to play"", 100.0 },
    { ""Orange"", ""Something to eat and refresh"", 50.0 }
};

std::cout << ""Lookup by Price: \n"";
if (products.find(50.0) != products.end())
    std::cout << ""Found \n"";
else
    std::cout << ""Not found\n"";The output:Not Found
There is an object that has the price of 50 units… so why the search failed?The primary key that we use here is the name. The implementation might create the following tree structure:       ""Ball""
     /      \
   ""Car""    ""Orange"" When comparing 50.0 with “Ball”, we compare the prices, and 50 is smaller than Ball’s price of 100.0. So we go into the left subtree. Then we see only “Car”, which has a different price than “50”. Maybe that’s quite obvious, but be sure to look for keys that are also equal to the primary key that is used.In C++14 we got heterogeneous lookup for ordered containers (std::map, std::set, etc) and the natural extension was to have a similar approach for unordered containers (std::unorederd_map, std::unordered_set, etc).If everything goes fine, we’ll have that in C++20 through the paper:  P0919 by Mateusz Pusz. Right now, the paper was accepted for the C++20 draft.You can also try your implementation and use the ideas from this video. 
https://www.youtube.com/watch?v=0QFPKgvLhaoOne of the reasons we have heterogeneous lookup is to increase the performance of searching. But how much you can achieve?The main gain will come from reducing the number of temp objects and extra memory allocations.  So the less temp memory you need to allocate the better is the final boost.We can draw some numbers from the paper P0919 where the author - Mateusz - presents several experiments for unordered containers (Github repo here: mpusz/unordered_v2):Can we get the same performance with ordered containers? I hope to cover that in my next article. So stay tuned. But if you have some results already, please share that in comments.With C++14 we got a new and flexible way to lookup in ordered containers. The main idea was to provide “transparent” functors that can compare two “compatible” objects that represent a key. For example, in a map of strings, you can search by string_view or const char*. That reduced the number of temp objects. This technique is also handy when your keys are large.In C++20 we’ll probably get a similar pattern but for unordered containers. We need to wait for the final Standard.Have you used heterogeneous lookup before? Do you think that might help in your projects? Let us know in comments.",cpp
49,"You’re writing a document about C++, one feature or some cool programming technique. At one point you think that you have to prove that something works and that’s why you need to quote text from the Standard. How to do it?Referencing the C++ Standard, or maybe a proposal might be quite confusing. Where can you find the latest documents and papers and how to link to them efficiently?In this blog post, I’d share with you some useful tips, links and tools that will help you with this task.Firstly, let’s start with a set of useful links.Official Links:Handy Links:Other:Let’s say you want to describe closure type of a lambda. You know that in C++17 the closure type has no default constructor. You need to find the page from the Standard where such lambda behaviour is specified.You can find the paragraph in the official ISO Specification. That’s the correct way (if your document is also official, then it might be best to buy the ISO Spec). But if you don’t want to pay for the official paper, you can use drafts. While they might contain some differences vs the final Specification (especially some minor changes and editorials), it might be good enough for most of the purposes.One way to reference the spec is from the latest draft. You might use services like using timsong-cpp.github.io or eel.is, and you see that in section 7.5.5.1 Closure types #13 there’s:The closure type associated with a lambda-expression has no default constructor if the lambda-expression has a lambda-capture and a defaulted default constructor otherwise.So there’s a default constructor in some cases!What’s wrong here?The ongoing changes for C++20! (and you wanted C++17 state)How to fix this?You need to reference “frozen” C++ standard. The official github repo doesn’t have revisions, but you can do it with timsong-cpp. It lists several important revisions:You can also use wg21.link service (returns PDFs):For our example with lambdas, we can go to C++17’s latest draft - N4659 and then reference the following section:8.1.5.1 Closure types # 11:The closure type associated with a lambda-expression has no default constructor and a deleted copy assignment operator.Now you’re fineAdditionally it might be handy to reference the name of the section (like [expr.prim.lambda.capture]), rather than its number (7.5.5.2 Captures). Names don’t change that often, but numbers might.[tip]: Don’t reference to draft as it might change, it’s best to select a published C++ version (or a final draft before publication).Proposals are documents that describe some feature that might potentially be merged into the final Standard. It evolves according to the support from the Committee.Many papers can be rejected, of course.Where can you find them?At isocpp.org there are mailings that are published before each (and after) ISO Meetings. 
You can reference papers that “live” and are actively discussed at meetings.For example, here’s a mailing from the last meeting (Kona 2019):Another way to find a paper with a feature is through a list of C++ supported features. That way you can find a paper for an already merged feature.You can use C++ compiler support - cppreference.com that contains long list of various C++ features. Similar lists can be found for GCC, Clang, and MSVC respectively.Recently, for C++17, we also have a paper that describes all the changes, with the papers that were merged:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0636r2.htmlTo sum up:  
 I showed you at least two sources where you can find a proposal.Should you use that long URL starting with http://www.open-std.org/jtc1 ? Is there a better way?As you see, linking to papers might be confusing.But there’s a handy tool that might help.Have a look:Just use https://wg21.link/ (there’s a description of that linking service there)Basically, you need to select a paper number, for example, P0636 (C++17 changes) and then put that after https://wg21.link/https://wg21.link/P0636 will resolve to: 
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0636r3.htmlyou might notice that it pointed to r3 - so the latest version.I’ve noticed that usually, the first version of the paper shows the motivation and longer descriptions. So if you want to explain a proposal better then you might refer to some earlier version. For a paper that eventually went into the Standard, the latest revisions are mostly smaller changes and wording.If you want to refer to a selected version of the paper, then provide the full name like P0636r1resolves to : http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0636r1.html[tip]:  you can find a paper through ISO mailings (published at isocpp.org) or through C++ compiler support or other lists with C++ changes.[tip]: use wg21.link system to refer to a paper. 
In this post I showed you my ways of linking to the selected C++ Standard that I use for my blog posts. Do you use some other ways? Do you have other resources? Let me know in comments.",cpp
50,"

Welcome to new C++ Links - most important and useful articles, podcasts and videos that happen between 11th and 17th of May 2019.In this week you will find links for two interesting resources: one about coroutines and the second about modern C++. You will also find a link describing what is the point of declaration, how to use constexpr for investigating errors and many more!Rainer Grimm wrote another post about upcoming C++ modules. He presents a few practical examples: 
modernescpp.com/index.php/c-20-more-details-to-modulesIn new C++ Weekly Episode Jason Turner shows what is variable shadowing and how the compiler may warn us about it: 
youtube.com/watch?v=L0YG2x7E87wNew post from Jonathan Boccara - he describes 3 types of macro that can be useful in our code: 
fluentcpp.com/2019/05/14/3-types-of-macros-that-improve-c-code/Someone published a list of resources about coroutines. Many talks, articles and even podcasts about this amazing C++20 feature! 
gist.github.com/MattPD/9b55db49537a90545a90447392ad3aeb#file-cpp-std-coroutines-draft-mdArticle from Dawid Pilarski - he explains what is the point of declaration and why we should care about it: 
blog.panicsoftware.com/point-of-declaration/C++ is Fun. Marius Bancila shows few examples with unicode characters instead of a code: 
mariusbancila.ro/blog/2019/05/16/cpp-is-fun/Really interesting article from Shafik Yaghnour - he showed how to use constexpr to explore Undefined Behaviour. 
shafik.github.io/c++/undefined%20behavior/2019/05/11/explporing_undefined_behavior_using_constexpr.htmlAnother article from Jonathan Boccara - he explores how to implement start_with from std::string before C++20 (isn’t sad that we don’t have this method already?): 
fluentcpp.com/2019/05/17/how-to-check-if-a-string-is-a-prefix-of-another-one-in-cpp/Another nice list - sources for learning modern c++: 
github.com/rigtorp/awesome-modern-cpp/blob/master/README.mdThe links are brought to you by Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
51,"

Welcome to new C++ Links - most important and useful articles, podcasts and videos that happen between 4th and 10th of May 2019.Today you will find a link to a video that shows how Uniform Container Erasure will simplify erasing elements from containers, link to an introduction to modules, and tutorial how to change boost::filesystem to std::filesystem.New post on bfilipek.com, by Scott Furry, about migration from boost::filesystem to std::filesystem. The author shows differences - starting from linking flags to tiny details, e.g. difference in path reverse iterator: 
bfilipek.com/2019/05/boost-to-stdfs.htmlAn article that shows how to start a project in Visual Studio 2019 and Windows Subsystem for Linux. Contains lots of screens and shows step-by-step how to set up the environment: 
devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/New post from Rainer Grimm. This time he describes upcoming C++20 feature - Modules: 
modernescpp.com/index.php/c-20-modulesJason Turner on his C++ weekly shows really nice addition to C++20 - Uniform Container  Erasure. C++ devs will no longer have to use erase-remove idiom! 
youtube.com/watch?v=YGAX509TCQsJonathan Boccara writes an article about how to output strings separated by a comma in C++, without trailing comma at the end: 
fluentcpp.com/2019/05/07/output-strings-separated-commas-cpp/Result of the last CppDevSUrvey is already on-line: 
isocpp.org/files/papers/CppDevSurvey-2019-04-summary.pdfNew video from CopperSpice- an episode about declarations and type conversions: 
youtube.com/watch?v=ZmBvx2acQ2oJonathan Boccara is improving his class - csvPrinter, introduced in the last post. He tries to integrate it with STL - e.g. he implements custom insert iterator: 
fluentcpp.com/2019/05/10/integrating-curried-objects-with-the-stl/New CppCast episode - interview with Alex Denisov, Software Engineer who is working at PTScientists GmbH, a German aerospace startup. The episode about mutation testing with Mull - LLVM-based tool for Mutation Testing: 
cppcast.com/2019/05/alex-denisov/New blog post at Solarian Programmer about setting up the latest GCC 9.1 and linking to Intel TBB - so that you can play with C++17’s parallel algorithms: 
solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/The links are brought to you by Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
52,"As you may know std::filesystem evolved directly from Boost filesystem library. For a long time, it was available as a Technical Specification and later merged into C++17. Developers who used Boost can ask themselves what the differences between the two libs are. Can the code be easily converted to use std::filesystem? Today’s article is written by Scott Furry who writes about the differences he found when working with the two libs.This article is a guest post from Scott FurryScott (see his Linkedin profile) is an independent software developer based in Edmonton,  Alberta,  Canada. He is a retired electronic technician from the Royal Canadian Navy.  Over the years of work in civilian life, he has developed projects with many different languages for a variety of computer systems, including legacy architectures. He also contributions to and assists others using Open Source software.To the uninitiated, the Boost Libraries can seem very intimidating. I have often seen discussion threads where a user’s problem is answered with “use Boost”. There is a myriad of web pages filled with how-tos and advice on usage. My use case at the time years ago was quite simple. I wanted a cross-platform means to handle file paths. And that was my introduction, boost::filesystem library.Unlike a large portion of the Boost ecosystem, boost::filesystem is not header-only. However, integration into a project was quite simple, and the functionality it provided was impressive. For the most part, a few extra keystrokes were needed to tell the compiler which shared objects to build against and where to find them. And into my personal skills toolkit it went.I recently got it in my head to get back up to speed on C++ developments. There was a long stretch of time where I wasn’t fully using my coding skills, pounding away at the keyboard, bending bits to whims and will. Being stuck on C++11 ideas with C++20 looming somehow seemed wrong to me in many ways. I decided to take the time get acquainted with, at least, C++17 - the latest released standard.While doing a deep dive on web articles about C++17, I tripped over the news that boost::filesystem had been merged into the C++17 standard.Really?!?!?blink. blinkI gotta try that!!!Off I went cleaning off digital dust on old example code to see if the news was true or just hype. Seeing that the news was true, I documented my surprise with the change in a Reddit post. In exchanging comments with others, and with other experimentation, I came to understand that there are differences between the two implementations.I’m not going to go on about “Do A. Do B. Do C. Easy.” when it comes to using std::filesystem. There are numerous other pages with content as if the reader has never seen this topic before. Instead, I am approaching the subject from the viewpoint the reader has some familiarity with boost::filesystem and may be looking to update the existing code to incorporate C++17.One major caveat is to ensure your compiler of choice is up to the task of using std::filesystem. None of this will work if the compiler is too old or has not implemented, at least experimentally, C++17 features. So, check your version now before making code changes.The Filesystem Library (C++ technical specification ISO/IEC TS 18822:2015) was merged into the final release of C++17 in December 2017. In the two-plus years while C++17 was being assessed, std::filesystem was available as an experimental library.GCC, in versions before 8.0, had users use the namespacestd::experimental::filesystem
This is no longer required in current 8.x releases. Exact details for GCC C++17 support can be found on the GNU CXX Status page.LLVM states C++17 has been incorporated into Clang/LLVM since version 5.0. However, the implementation of std::filesystem was only available after the Clang/LLVM 7.0 release. See the LLVM CXX Status page for more details.For those who use LLVM’s C++ library, see the Using Libcxx page for caveats about using std::filesystem. It basically boils down to ensuring you have LLVM Libcxx 9.0 installed. Note the name for the Libcxx Filesystem library, -lc++fs. You will need that for linking.Visual Studio 2017 15.7 incorporated the full implementation of <filesystem>. Prior releases after VS2012 used the similar convention as GCC where uses had to invoke <experimental/filesystem>.For this article, I will reference two, almost identical, programs:a) main_boostfs.cpp; and 
b) main_stdfs.cpp.The exact differences to the programs can be found in this diff patch.These programs were developed to highlight commonality and differences in transitioning from boost::filesystem to std::filesystem.For most uses, this is about the only real change that needs to be made to the code. You have to tell the compiler that you want to use the C++ Standard Filesystem Library. With boost::filesystem, code like:#ifndef BOOST_FILESYSTEM_NO_DEPRECATED
#define BOOST_FILESYSTEM_NO_DEPRECATED
#endif

#include <boost/filesystem.hpp>
namespace fs = boost::filesystem;now gets replaced with this:#include <filesystem>
namespace fs = std::filesystem;The #ifndef is not needed any more as we do not have to worry about deprecated boost::filesystem declarations. The #include directive is rather self-explanatory. And if, like me, you attempt to cut down the amount of typed code by using namespace aliases, swap out boost with std in the alias statement. The rest of the code should work as-is.To compile, the changes are equally straight forward. Without the need for the external Boost Filesystem library, we do not need to declare search directories for includes(-I) or linking(-L), if used.A typical usage of boost::filesystem was to identify link libraries as:CXX ... -lboost_system -lboost_filesystem
With std::filesystem, we only have to tell the compiler that C++17 is being used and to link against std::filesystem instead. The command becomesCXX ... -std=c++17 ... -lstdc++fs
With the release of GCC 9.0, or bleeding edge latest release, there is no need for linkage to the external filesystem library. See GCC 9.0 Release Notes.As noted earlier, when using LLVM’s Libcxx, the link library is -lc++fs.For IDE users, check upstream if this is supported. You may need to explicitly change project settings to enable C++17, as well as std::filesystem.For example, Visual Studio supports C++17 with the flags /std:c++17 or /std:c++latest set inproject options -> C/C++ -> Language -> C++ Language Standard
Eclipse, however, has not enabled C++17 support as of publication date.If your project makes use of autotools or CMake, the needed changes are just as equally simple. If you’re only using boost::filesystem, you can remove the instructions entirely to search for the Boost libraries. Otherwise, just remove filesystem from the search for Boost.One issue that I tripped over rather quickly was code where I used the function boost::filesystem::system_complete().I vaguely recalled that I found this function after web searches leading to Stack Overflow comments. I had written code to handle situations where I needed to pass a normalized path for that operating system to other functions. And then I just got into the habit of reusing the call in all my code.After my edits of changing headers, the compile stopped with an error stating that the function could not be found in Standard C++. I could see it on the boost::filesystem API page, but not on any pages describing std::filesystem.I think I found my solution after reading the description to the system_complete function on the boost::filesystem API page:Effects: Composes an absolute path from p, using the same rules used by the 
  operating system to resolve a path passed as the filename argument to standard 
  library open functions.The absolute() function does exist in std::filesystem. Depending on usage, the canonical() function could also be applied. After some further reading, it appears as both Boost and C++ Standard are going through some kind of collaborative revisions. This function, in its current form, may disappear in future. See the Version History section of the boost::filesystem front page.Another notable difference found between the two Filesystem implementations was with path iterators. For example, let’s say you are working on a game project. You start with a path to a map file, and it contains text that are the file names of images or music resources. You may jump to the thought of wrestling with the string mangling or even regex. That’s too hard an effort. There is an easier way to do this.With the Filesystem library, you create a filesystem::path, passing in the location of an existing file, say the map file from the above hypothetical situation. A path iterator would then be used to walk up the directory tree, each iteration would produce the directory name found between the directory separators. The code could iterate up some number of directories to the resources root. From here, append paths back down into a folder, say the location of our game’s image or music resources. A reverse path iterator would be ideal in this situation to help break down, or decompose, the path without having to wrestle with directory separators for each platform.Path iterator usage is shown in the example code for the article. At line 55 in main_boostfs.cpp, the parent to a user-supplied path is pulled apart with a reverse path iterator. The value of that iterator is then appended to another path variable.fs::path revPath;
fs::path decompPath( testpath.parent_path() );
cout << ""Decoposition: "" << endl;
for( auto it = decompPath.rbegin(); it != decompPath.rend(); ++it )
{
    // (*it) is type fs::path
    cout << setw(6) << ' ' << (*it).string() << endl;
    // path append operator - separator added by library
    revPath /= (*it);
}
cout << ""Reverse Path:"" << setw(11) << ' ' << revPath.string() << endl;We define decompPath to the value of the parent path passed in by the user. Creating another path variable is necessary since path::parent_path() cannot be used with path iterators. When executing the program, you pass in, for example, /home/me/somefolder/subfolder/article.txt. The parent path is /home/me/somefolder/subfolder. At the end of each iteration of the for loop, the path iterator value, whatever is found between director separators, is appended to the variable revPath. After executing this code, the expected output should be subfolder/somefolder/me/home/. The parent path backwards.Problem is that std::filesystem does not implement a path reverse iterator, no path::rend() and path::rbegin(). There is only a forward iterator. It takes some creative manipulations to use forward iterators and go in reverse. In main_stdfs.cpp, at line 58, we do just that:...
for(auto it = decompPath.end(); it != decompPath.begin();)
{
    --it;
    ...We point an iterator to path::end(), decrement the iterator, and keep going only to stop when we reach the beginning iterator, path::begin(). The for loop step value is in the loop itself, not in the for loop line. Not a hard prospect but it does make the code appear awkward, in my opinion. This last difference was pointed out to me in an online discussion. There is some deviation in how each implementation handles the append operator, path::operator /=().With boost::filesystem, the library will append whatever you give it. If the value to be appended begins with a directory separator, boost::filesystem will add a directory separator and whatever value you pass to append. A trim of any extra separators, along with any dot folders ./ or ../, can be done after calls to path::absolute(). Append means just that, append.For std::filesystem, the library behaviour is similar to what a user experiences on the command line. As an analogy, doingls dir/subdir/
performs a directory listing on a path relative to the current working directory. 
Executingls /dir/subdr/
means to list contents of the path starting from the root directory, otherwise a directory listing of an absolute path.This is similar to how std::filesystem interprets appending values. Any path that starts with a directory separator, or /, is interpreted as meaning to append an absolute path. The path::operator /=() resets the variable to the value being appended, discarding previous contents. This behaviour is highlighted in path decomposition in the article example code. Building up the path in reverse, the path iterator value on the last iteration is the root name, or / on Linux. Using boost::filesystem, the resulting value of revPath is exactly as one would expect from append operations, the parent path in reverse. Using std::filesystem, if we were to printout the value of revPath at the end of each iteration, we would see accumulation of appends. At the last append, the directory separator, indicating a root, is added to revPath. This last append resets revPath to what we pass to the operator, discarding the accumulated contents from previous iterations.What this means for developers is that extra caution is needed in code. Developers will need to incorporate some validation or data checking to ensure that appended values do not start with a directory separator. All values that you intend to append must be relative paths.There are indeed some differences between the two implementations. What is listed here is by no means a comprehensive listing. You may find others because of how you used boost::filesystem. Both boost and std::filesystem are evolving. You may find other differences not listed here.Extra note: there’s one Stack Overflow questions with a conscience list of differences, so you might also review it: How similar are Boost filesystem and the standard C++ filesystem libraries? - Stack Overflow.C++17 and std::filesystem are recent additions, relatively speaking. The virtual dust from implementation is still settling. Organizations behind operating systems, IDE’s, and compilers are still working on releases that fully implement all of the changes contained in C++17. Boost and the C++ Standard are both evolving.With that being said, incorporating std::filesystem is rather straightforward for most use cases. If your development environment is up to date, and there is no, or minimal, impact to users or program behaviour then I would encourage the change to std::filesystem. Removing the dependency on an external library from a project, in my opinion, is boon for code maintenance. With improved C++17 integration into GCC 9.0, maintenance will get easier.How about you? Have you used boost filesystem? do you plan to move to std::filesystem?",cpp
53,"

Welcome to new C++ Links - most important and useful articles, podcasts and videos that happen between 27th of April 3rd of May 2019.In this week you will find a little bit of C++ history - how namespaces were introduced in C++ and what design choices they have. You will also find a link to an extremely hard C++ quiz!Great article from Krister Walfridsson. He explains how compiler optimizes geometric sums. Lots of assembly and math inside! 
kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html?m=1Article from Rainer Grimm - he showed some rules from C++ Core Guidelines related to source files: 
modernescpp.com/index.php/c-core-guidelines-the-remaining-rules-to-source-filesNew post from Bartlomiej Filipek - he showed how to print useful logging information, like file name and line number. Did you know, that in C++20 you don’t have to use any macros? 
bfilipek.com/2019/04/file-pos-log.htmlNew C++ Weekly episode from Jason Turner - he presents new trait from C++20 - is_constant_evaluated: 
youtube.com/watch?v=nkhhV5uSSLkIf you like C++ quizzes, this post is for you! Lots of tricky questions presented on C++ Russia conference. I warn you - nightmare level! 
blog.jetbrains.com/rscpp/cpp-quiz-cpp-russia-2019/Arthur O’Dwyer explains in his article what is Argument Depend Lookup (ADL). A little bit history inside, plenty of examples: 
quuxplusone.github.io/blog/2019/04/26/what-is-adl/Jonathan Boccara explains what are “Curried objects”. In a short - they are intermediate objects between a caller and a callee. Jonathan presents when they can be useful: 
fluentcpp.com/2019/05/03/curried-objects-in-cpp/Post inspired by old standard committee paper that introduces namespaces in C++, about using class, Uniform function call syntax: 
tristanbrindle.com/posts/opt-in-ufcsNew CppCast episode, interview with David Sankel, author of C++ Reflection proposal: 
cppcast.com/2019/05/david-sankel/Another C++ Podcast, CpcpChat, with Gor Nishanov, author of the Coroutines: 
cppchat.fireside.fm/53Bonus: Lots of ACCU videos are online: 
youtube.com/channel/UCJhay24LTpO1s4bIZxuIqKwBonus 2: Meeting C++ has also great blogroll: 
meetingcpp.com/blog/blogroll/items/Meeting-Cpp-Blogroll-188.htmlBonus 3: Remember to fill C++ Standard Committee journey: 
surveymonkey.com/r/NCMCJDZThe links are brought to you by Wojciech Razik. 
  Wojtek is a Senior C++ developer at Thaumatec, currently writing software for a face & iris recognition device. He enjoys reading C++ Standard before bed, and he loves to hate JS from dawn to dusk.
  If you know Polish, take a look at cpp-polska.pl where Wojtek is one of the co-authors.",cpp
54,"No matter how proficient you are, I think, you might still use one of the primary methods of debugging: trace values using printf, TRACE, outputDebugString, etc… and then scan the output while debugging. Adding information about the line number and the file where the log message comes from is a very efficient method that might save you a lot of time. In this post, I’ll describe one trick that is especially useful in Visual Studio but might also help in other IDE/compilers.I’ll also show you how modern C++ and C++20 make code nicer.When you’re debugging C++ code, it’s very convenient to output values to console or the output window and scan the log. As simple as:std::cout << ""my val: "" << val << '\n';You can easily enhance this technique by adding LINE and FILE information. That way you’ll see the source of that message. Which might be very handy when you scan lots of logs.In Visual Studio, there’s a trick that allows you to move quickly from the debug output window to a particular line of code.All you have to do is to use the following format:""%s(%d): %s"", file, line, message
For example:myfile.cpp(32) : Hello World
You can now double-click on the line in VS output window, and immediately VS opens myfile at line 32. See below:Why is it so important? In my case, I’ve lost a lot of time when I tried to look for the origin of some log output. When I see a message, I copy it, search the solution, and then usually after scrolling around I finally get to the right line of code. You cannot beat this double-clicking approach, which is much more efficient!Now that you know the proper format of the message, how do you use it in the code? Let’s go step by step.We’ll implement this code with “standard” C++, then move to modern C++ and finally see what’s coming with C++20.For VS, first of all, you need to output the message using OutputDebugString (Win specific function):    OutputDebugString(""myfile.cpp(32) : super"");Secondly, it’s better to wrap the above function with a trace/log macro:#define MY_TRACE(msg, ...) \
    MyTrace(__LINE__, __FILE__, msg, __VA_ARGS__)You can use it in the following way:MY_TRACE(""hello world %d"", myVar);The above code calls the MyTrace function that internally calls OutputDebugString.Why a macro? It’s for convenience. Otherwise, we would have to pass the line number and the filename manually. File and Line cannot be fetched inside MyTrace because it would always point to the source code where MyTrace is implemented – not the code that calls it.What are __FILE__ and __LINE__? In Visual Studio (see msdn), those are predefined macros that can be used in your code. As the name suggest they expand into the filename of the source code and the exact line in a given translation unit. To control the __FILE__ macro you can use the compiler option /FC. The option makes filenames longer (full path), or shorter (relative to the solution dir). Please note that /FC is implied when using Edit and Continue.Please note that __FILE__ and __LINE__ are also specified by the standard, so other compilers should also implement it. See in 19.8 Predefined macro names .Same goes for __VA_ARGS__: see 19.3 Macro replacement - cpp.replaceAnd here’s the implementation of MyTrace:void MyTrace(int line, const char *fileName, const char *msg, ...)
{
    va_list args;
    char buffer[256] = { 0 };
    sprintf_s(buffer, ""%s(%d) : "", fileName, line);
    OutputDebugString(buffer);

    // retrieve the variable arguments
    va_start(args, msg);
    vsprintf_s(buffer, msg, args);
    OutputDebugString(buffer);
    va_end(args);
}But macros are not nice… we have also those C-style va_start methods… can we use something else instead?Let’s see what how can we use modern C++ hereMyTrace supports a variable number of arguments… but we’re using va_start/va_end technique which scans the arguments at runtime… but how about compile time?In C++17 we can leverage fold expression and use the following code:#define MY_TRACE_TMP(...) MyTraceImplTmp(__LINE__, __FILE__, __VA_ARGS__)

template <typename ...Args>
void MyTraceImplTmp(int line, const char* fileName, Args&& ...args)
{
    std::ostringstream stream;
    stream << fileName << ""("" << line << "") : "";
    (stream << ... << std::forward<Args>(args)) << '\n';

    OutputDebugString(stream.str().c_str());
}

// use like:
MY_TRACE_TMP(""hello world! "", 10, "", "", 42);The above code takes a variable number of arguments and uses ostringstream to build a single string. Then the string goes to OutputDebugString.This is only a basic implementation, and maybe not perfect. If you want you can experiment with the logging style and arrive with a fully compile-time approach.There are also other libs that could help here: for example {fmt} or pprint - by J. Galowicz.During the last ISO meeting, the committee accepted std::source_location which is a part of library fundamentals TS v2.C++ Extensions for Library Fundamentals, Version 2 -  14.1 Class source_locationThis new library type is declared as follows:struct source_location {
    static constexpr source_location current() noexcept;
    constexpr source_location() noexcept;
    constexpr uint_least32_t line() const noexcept;
    constexpr uint_least32_t column() const noexcept;
    constexpr const char* file_name() const noexcept;
    constexpr const char* function_name() const noexcept;
  };And here’s a basic example, adapted from cppreference/source_location:#include <iostream>
#include <string_view>
#include <experimental/source_location>

using namespace std;
using namespace std::experimental; 

void log(const string_view& message, 
      const source_location& location = source_location::current())
{
    std::cout << ""info:""
              << location.file_name() << "":""
              << location.line() << "" ""
              << location.function_name() << "" ""
              << message << '\n';         
}

int main()
{
    log(""Hello world!"");

    // another log
    log(""super extra!"");
}We can rewrite or log example intotemplate <typename ...Args>
void TraceLoc(const source_location& location, Args&& ...args)
{
    std::ostringstream stream;
    stream << location.file_name() << ""("" << location.line() << "") : "";
    (stream << ... << std::forward<Args>(args)) << '\n';

    std::cout << stream.str();
}Play with the code @Coliru 
(source_location is not available in VS, so that’s why I used GCC)Now, rather than using  __FILE__ and __LINE__ we have a Standard Library object that wraps all the useful information.Unfortunately, we cannot move that source location argument after variadic args… so we still have to use macros to hide it.Do you know how to fix it? so we can use a default argument at the end?Ideally:template <typename ...Args>
void TraceLoc(Args&& ...args, 
              const source_location& location = source_location::current())
{
   // ...
}But I leave that as an open question.In this article, I showed a useful technique that might enhance simple printf-style debugging and logging.Initially, we took a “standard” code that is mostly C-style and then we tried to update it with modern C++. The first thing was to use variadic template arguments. That way we can scan the input params at compile time, rather than use va_start/va_end C runtime functions. The next step was to look at the future implementation of source_location a new type that will come in C++20.With source_location we could skip using __FILE__ and __LINE__ predefined macros, but still, the logging macro (#define LOG(...)) is helpful as it can hide a default parameter with the location info.code from the article: @github.How about your compiler/IDE? Do you use such line/pos functionality as well? Maybe your logging library already contains such improvements?",cpp
55,"Last Tuesday, 16th April, I had a pleasure to talk about std::filesystem in our Cracow C++ User Group.Here are the slides and additional comments.The plan for the presentation was to describe the whole library and build a high-level overview.  I also wanted to show examples where the std::filesystem simplifies the code.As an introduction, I wanted to know what are the tasks related to the filesystem. Is that something common among programmers, or quite a rare thing? (let me know in comments what are your example filesystem tasks)For example, in my work (a powerful Document Editor, Windows Platform) recently I had to manipulate some paths to load files with dictionaries. Or there was also a task that required to iterate through a directory and look for specific files. Yet working with filesystem is not typical for me, as the most requires elements are already written and working well. Still, when I have a filesystem-related task I might struggle with the following things:After that part, I showed a few examples of “before and after.”In both cases, we see how it’s now easy and straightforward with C++17!After the intro… there was the “concrete” part where I showed all the major elements of the library:In the end, I also showed an example of a simple file watcher - and all credits go to Solarian Programmer for his post and code about that: C++17 Filesystem - Writing a simple file watcher. This app is maybe not suited for production (yet), but it allows you to create a multiplatform solution in a matter of a few lines of code. I think it’s good to know such a possibility and understand it bacis concepts.During the presentation, we also discussed several things (that were quite hard to explain!)The filesystem is a broad topic! As I see there are two layers to understand:I highly suggest trying std::filesystem as it offers many ways to simplify the code and make it safer. I love the filesystem::path class which offers probably all things you need to compose and work with paths. Without direct string manipulation! And then directory iteration or even creating whole dir tree structures.Let me know in comments what your everyday tasks related to the filesystem are? Do you use some third-party API? Maybe Boost?",cpp
